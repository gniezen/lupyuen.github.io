<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>PineCone BL602 RISC-V Board Receives LoRa Packets</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="PineCone BL602 RISC-V Board Receives LoRa Packets" 
    data-rh="true">
<meta property="og:description" 
    content="How PineCone BL602 RISC-V Board with SX1276 receives LoRa packets... Transmitted by RAKwireless WisBlock"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/lora2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">PineCone BL602 RISC-V Board Receives LoRa Packets</h1>
    <nav id="TOC"><ul>
<li><a href="#connect-bl602-to-lora-transceiver">1 Connect BL602 to LoRa Transceiver</a><ul></ul></li>
<li><a href="#initialise-lora-transceiver">2 Initialise LoRa Transceiver</a><ul></ul></li>
<li><a href="#receive-lora-packet">3 Receive LoRa Packet</a><ul>
<li><a href="#receive-callback">3.1 Receive Callback</a><ul></ul></li>
<li><a href="#timeout-and-error-callbacks">3.2 Timeout and Error Callbacks</a><ul></ul></li></ul></li>
<li><a href="#bl602-gpio-interrupts">4 BL602 GPIO Interrupts</a><ul>
<li><a href="#register-handler-function">4.1 Register Handler Function</a><ul></ul></li>
<li><a href="#gpio-interrupt-handler">4.2 GPIO Interrupt Handler</a><ul></ul></li>
<li><a href="#handling-dio0-to-dio5">4.3 Handling DIO0 to DIO5</a><ul></ul></li></ul></li>
<li><a href="#multitask-with-nimble-porting-layer">5 Multitask with NimBLE Porting Layer</a><ul>
<li><a href="#background-task">5.1 Background Task</a><ul></ul></li>
<li><a href="#event-queue">5.2 Event Queue</a><ul></ul></li>
<li><a href="#timer">5.3 Timer</a><ul></ul></li></ul></li>
<li><a href="#bl602-stack-trace">6 BL602 Stack Trace</a><ul></ul></li>
<li><a href="#always-initialise-stack-variables">7 Always Initialise Stack Variables!</a><ul></ul></li>
<li><a href="#start-the-rakwireless-wisblock-transmitter">8 Start the RAKwireless WisBlock Transmitter</a><ul></ul></li>
<li><a href="#build-and-run-the-bl602-lora-firmware">9 Build and Run the BL602 LoRa Firmware</a><ul>
<li><a href="#flash-the-firmware">9.1 Flash the firmware</a><ul></ul></li>
<li><a href="#run-the-firmware">9.2 Run the firmware</a><ul></ul></li>
<li><a href="#enter-lora-commands">9.3 Enter LoRa commands</a><ul></ul></li></ul></li>
<li><a href="#troubleshoot-lora">10 Troubleshoot LoRa</a><ul></ul></li>
<li><a href="#whats-next">11 What's Next</a><ul></ul></li>
<li><a href="#notes">12 Notes</a><ul></ul></li></ul></nav><p>üìù <em>31 Mar 2021</em></p>
<p>Not too long ago (and not so far away) we embarked on an epic quest to create a low-power, long-range <a href="https://en.wikipedia.org/wiki/LoRa"><strong>LoRa IoT Sensor</strong></a> with <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 RISC-V Board</strong></a></p>
<ol>
<li>
<p>We created a <strong>LoRa Transmitter</strong> with BL602...</p>
<p><a href="https://lupyuen.github.io/articles/lora"><strong>&quot;Connect PineCone BL602 to LoRa Transceiver&quot;</strong></a></p>
</li>
<li>
<p>Then we tested it with a <strong>LoRa Receiver</strong>: RAKwireless WisBlock...</p>
<p><a href="https://lupyuen.github.io/articles/wisblock"><strong>&quot;RAKwireless WisBlock talks LoRa with PineCone BL602 RISC-V Board&quot;</strong></a></p>
</li>
</ol>
<p>Today we shall create the LoRa Firmware for BL602 that will <strong>Receive LoRa Packets</strong>. And test it with RAKwireless WisBlock as the LoRa Transmitter.</p>
<p><em>Why do we need to receive LoRa Packets... If our BL602 LoRa Sensor will only transmit sensor data?</em></p>
<p>Because we'll soon connect our BL602 LoRa Sensor to a <strong>secure, managed LoRaWAN Network</strong> like <a href="https://www.thethingsnetwork.org/"><strong>The Things Network</strong></a>. (Or maybe <a href="https://www.helium.com/lorawan"><strong>Helium</strong></a>)</p>
<p>Our BL602 gadget can't join these networks unless it can receive packets and respond to the network.</p>
<p>Let's make it so! (Because we do... Or do not... There is no try!)</p>
<p>The LoRa Firmware in this article will run on <strong>PineCone, Pinenut and Any BL602 Board</strong>.</p>
<ul>
<li>
<p><a href="https://youtu.be/3TSvo0dwwnQ"><strong>Watch the demo video on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lora#lora-vs-lorawan"><strong>More about the 3 Levels of LoRa and LoRaWAN</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/lora2-title.jpg" alt="PineCone BL602 RISC-V Board with Hope RF96 LoRa Transceiver (top) receives LoRa packets from RAKwireless WisBlock (bottom)" /></p>
<p><em>PineCone BL602 RISC-V Board with Hope RF96 LoRa Transceiver (top) receives LoRa packets from RAKwireless WisBlock (bottom)</em></p>
<h1 id="connect-bl602-to-lora-transceiver" class="section-header"><a href="#connect-bl602-to-lora-transceiver">1 Connect BL602 to LoRa Transceiver</a></h1>
<p>Connect BL602 to Semtech SX1276 or Hope RF96 as follows...</p>
<p><img src="https://lupyuen.github.io/images/lora2-connect3.jpg" alt="PineCone BL602 RISC-V Board connected to Hope RF96 LoRa Transceiver" /></p>
<table><thead><tr><th align="left">BL602 Pin</th><th align="left">SX1276 / RF96 Pin</th><th align="left">Wire Colour</th></tr></thead><tbody>
<tr><td align="left"><strong><code>GPIO 0</code></strong></td><td align="left"><code>DIO1</code></td><td align="left">Dark Green</td></tr>
<tr><td align="left"><strong><code>GPIO 1</code></strong></td><td align="left"><code>ISO</code> <em>(MISO)</em></td><td align="left">Light Green (Top)</td></tr>
<tr><td align="left"><strong><code>GPIO 2</code></strong></td><td align="left">Do Not Connect</td><td align="left">(Unused Chip Select)</td></tr>
<tr><td align="left"><strong><code>GPIO 3</code></strong></td><td align="left"><code>SCK</code></td><td align="left">Yellow (Top)</td></tr>
<tr><td align="left"><strong><code>GPIO 4</code></strong></td><td align="left"><code>OSI</code> <em>(MOSI)</em></td><td align="left">Blue (Top)</td></tr>
<tr><td align="left"><strong><code>GPIO 5</code></strong></td><td align="left"><code>DIO2</code></td><td align="left">Blue (Bottom)</td></tr>
<tr><td align="left"><strong><code>GPIO 11</code></strong></td><td align="left"><code>DIO0</code></td><td align="left">Yellow (Bottom)</td></tr>
<tr><td align="left"><strong><code>GPIO 12</code></strong></td><td align="left"><code>DIO3</code></td><td align="left">Light Green (Bottom)</td></tr>
<tr><td align="left"><strong><code>GPIO 14</code></strong></td><td align="left"><code>NSS</code></td><td align="left">Orange</td></tr>
<tr><td align="left"><strong><code>GPIO 17</code></strong></td><td align="left"><code>RST</code></td><td align="left">White</td></tr>
<tr><td align="left"><strong><code>3V3</code></strong></td><td align="left"><code>3.3V</code></td><td align="left">Red</td></tr>
<tr><td align="left"><strong><code>GND</code></strong></td><td align="left"><code>GND</code></td><td align="left">Black</td></tr>
</tbody></table>
<p><a href="https://electronics.stackexchange.com/questions/335912/can-i-break-a-radio-tranceiving-device-by-operating-it-with-no-antenna-connected"><strong>CAUTION: Always connect the Antenna before Powering On... Or the LoRa Transceiver may get damaged! See this</strong></a></p>
<p>Here's a closer look at the pins connected on BL602...</p>
<p><img src="https://lupyuen.github.io/images/lora2-connect4.jpg" alt="PineCone BL602 RISC-V Board connected to Hope RF96 LoRa Transceiver" /></p>
<p><em>Why is BL602 Pin 2 unused?</em></p>
<p><strong><code>GPIO 2</code></strong> is the <strong>Unused SPI Chip Select</strong> on BL602.</p>
<p>We won't use this pin because we'll control Chip Select ourselves on <code>GPIO 14</code>. <a href="https://lupyuen.github.io/articles/spi#control-our-own-chip-select-pin">(See this)</a></p>
<p>Here are the pins connected on our LoRa Transceiver: SX1276 or RF96...</p>
<p>(<code>ISO</code> and <code>OSI</code> appear flipped in this pic... Rotate your phone / computer screen 180 degrees for the proper perspective)</p>
<p><img src="https://lupyuen.github.io/images/lora2-connect5.jpg" alt="PineCone BL602 RISC-V Board connected to Hope RF96 LoRa Transceiver" /></p>
<p><em>Why do we connect so many pins on SX1276 (or RF96)?</em></p>
<p>The SX1276 and RF96 transceivers have <strong>6 (!) Digital Input / Output pins: <code>DIO0</code> to <code>DIO5</code></strong></p>
<p>The transceiver shifts the Logic Levels of these pins from <strong>Low to High</strong> when specific conditions occur...</p>
<ul>
<li>
<p><strong><code>DIO0</code> Packet Received</strong>: This pin is triggered when the transceiver <strong>receives a LoRa Packet.</strong></p>
<p><code>DIO0</code> is also triggered after the transceiver has transmitted a LoRa Packet, but that's not so useful.</p>
</li>
<li>
<p><strong><code>DIO1</code> Receive Timeout</strong>: This pin is triggered when the transceiver <strong>doesn't receive any LoRa Packets</strong> within a timeout window.</p>
<p>This works only when the transceiver is configured for <strong>Single Receive Mode</strong>.</p>
<p>However today we're configuring our transceiver for <strong>Continuous Receive Mode</strong> so we won't be using <code>DIO1</code>. We shall trigger receive timeouts with a BL602 Timer.</p>
</li>
<li>
<p><strong><code>DIO2</code> Change Channel</strong>: This is used for <strong>Spread Spectrum Transmission</strong> (Frequency Hopping). </p>
<p>When we transmit / receive LoRa Packets over multiple frequencies (spread spectrum), we reduce the likelihood of packet collisions over the airwaves.</p>
<p>We won't be using Spread Spectrum Transmission today, so <code>DIO2</code> shall stay idle.</p>
</li>
<li>
<p><strong><code>DIO3</code> Channel Activity Detection</strong>: The transceiver lets us <strong>detect whether there's any ongoing transmission</strong> in a LoRa Radio Channel, in a power-efficient way.</p>
<p>We won't be using Channel Activity Detection today.</p>
</li>
<li>
<p><strong><code>DIO4</code></strong> and <strong><code>DIO5</code></strong> are not connected to BL602.  They are used for <strong>FSK Radio Modulation</strong> only.</p>
<p>(We're using LoRa Radio Modulation)</p>
</li>
</ul>
<p>Only <strong>1 pin <code>DIO0</code></strong> is required for receiving simple LoRa Packets, without the frills (like Spread Spectrum Transmission).</p>
<p>But for now we shall connect <strong>4 pins <code>DIO0</code> to <code>DIO3</code></strong>, just in case they will be needed later for LoRaWAN. (Which will probably use Spread Spectrum Transmission)</p>
<p>We shall configure BL602 to trigger <strong>GPIO Interrupts</strong> when the 4 pins shift from Low to High.</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/lora#getting-the-lora-transceiver-and-antenna"><strong>More about Semtech SX1276 and Hope RF96</strong></a></p>
</li>
<li>
<p><a href="https://semtech.my.salesforce.com/sfc/p/E0000000JelG/a/2R0000001Rbr/6EfVZUorrpoKFfvaF_Fkpgp5kzjiNyiAbqcpqh9qSjE?__hstc=212684107.81023fceb80b3e55c1c4e19a916804ba.1616925682449.1616925682449.1616925682449.1&amp;__hssc=212684107.1.1616925682449&amp;__hsfp=1469659345"><strong>Semtech SX1276 Datasheet</strong></a></p>
</li>
</ul>
<h1 id="initialise-lora-transceiver" class="section-header"><a href="#initialise-lora-transceiver">2 Initialise LoRa Transceiver</a></h1>
<p>Let's look at the code inside our LoRa Firmware for BL602: <code>sdk_app_lora</code></p>
<p><strong>Super Important:</strong> We should set the LoRa Frequency in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L43-L58"><code>demo.c</code></a> like so...</p>
<pre><code class="language-c">/// TODO: We are using LoRa Frequency 923 MHz 
/// for Singapore. Change this for your region.
#define USE_BAND_923
</code></pre>
<p>In a while we shall change <code>923</code> to the LoRa Frequency for our region: <code>434</code>, <code>780</code>, <code>868</code>, <code>915</code> or <code>923</code> MHz. <a href="https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html">(Check this list)</a></p>
<p>For now we'll study this function <strong><code>init_driver</code></strong> that initialises the LoRa Driver for SX1276 (and RF96) in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L126-L179"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Command to initialise the SX1276 / RF96 driver
static void init_driver(char *buf, int len, int argc, char **argv) {
    //  Set the LoRa Callback Functions
    RadioEvents_t radio_events;
    memset(&amp;radio_events, 0, sizeof(radio_events));  //  Must init radio_events to null, because radio_events lives on stack!
    radio_events.TxDone    = on_tx_done;
    radio_events.RxDone    = on_rx_done;
    radio_events.TxTimeout = on_tx_timeout;
    radio_events.RxTimeout = on_rx_timeout;
    radio_events.RxError   = on_rx_error;
</code></pre>
<p><code>init_driver</code> begins by defining the <strong>Callback Functions</strong> that will be called when we have transmitted or received a LoRa Packet (successfully or unsuccessfully)...</p>
<ul>
<li>
<p><strong>Packet Transmitted: <code>on_tx_done</code></strong></p>
<p>Called when the transceiver has successfully transmitted a LoRa Packet.</p>
</li>
<li>
<p><strong>Packet Received: <code>on_rx_done</code></strong></p>
<p>Called when the tranceiver has received a LoRa Packet. (More about this in a while)</p>
</li>
<li>
<p><strong>Transmit Timeout: <code>on_tx_timeout</code></strong></p>
<p>Called if the transceiver is unable to transmit a LoRa Packet.</p>
</li>
<li>
<p><strong>Receive Timeout: <code>on_rx_timeout</code></strong>:</p>
<p>Called if the transceiver doesn't receive any LoRa Packets within a timeout window. (More about this in a while)</p>
</li>
<li>
<p><strong>Receive Error: <code>on_rx_error</code></strong>:</p>
<p>Called if the transceiver encounters an error when receiving a LoRa Packet. (More about this in a while)</p>
</li>
</ul>
<p>Next we call <strong><code>Radio.Init</code> to initialise BL602's SPI Port and the LoRa Transceiver</strong>...</p>
<pre><code class="language-c">    //  Init the SPI Port and the LoRa Transceiver
    Radio.Init(&amp;radio_events);
</code></pre>
<p><code>Radio.Init</code> will set some registers on our LoRa Transceiver (over SPI).</p>
<p>Then we call <strong><code>Radio.SetChannel</code> to set the LoRa Frequency</strong>...</p>
<pre><code class="language-c">    //  Set the LoRa Frequency, which is specific to our region.
    //  For USE_BAND_923: RF_FREQUENCY is set to 923000000.
    Radio.SetChannel(RF_FREQUENCY);
</code></pre>
<p><code>Radio.SetChannel</code> configures the LoRa Frequency by writing to the <strong>Frequency Registers</strong> in our LoRa Transceiver.</p>
<p>We get ready to transmit by calling <strong><code>Radio.SetTxConfig</code></strong>...</p>
<pre><code class="language-c">    //  Configure the LoRa Transceiver for transmitting messages
    Radio.SetTxConfig(
        MODEM_LORA,
        LORAPING_TX_OUTPUT_POWER,
        0,        //  Frequency deviation: Unused with LoRa
        LORAPING_BANDWIDTH,
        LORAPING_SPREADING_FACTOR,
        LORAPING_CODINGRATE,
        LORAPING_PREAMBLE_LENGTH,
        LORAPING_FIX_LENGTH_PAYLOAD_ON,
        true,     //  CRC enabled
        0,        //  Frequency hopping disabled
        0,        //  Hop period: N/A
        LORAPING_IQ_INVERSION_ON,
        LORAPING_TX_TIMEOUT_MS
    );
</code></pre>
<p>At the end of the function we call <strong><code>Radio.SetRxConfig</code></strong> to configure the transceiver for receiving LoRa Packets...</p>
<pre><code class="language-c">    //  Configure the LoRa Transceiver for receiving messages
    Radio.SetRxConfig(
        MODEM_LORA,
        LORAPING_BANDWIDTH,
        LORAPING_SPREADING_FACTOR,
        LORAPING_CODINGRATE,
        0,        //  AFC bandwidth: Unused with LoRa
        LORAPING_PREAMBLE_LENGTH,
        LORAPING_SYMBOL_TIMEOUT,
        LORAPING_FIX_LENGTH_PAYLOAD_ON,
        0,        //  Fixed payload length: N/A
        true,     //  CRC enabled
        0,        //  Frequency hopping disabled
        0,        //  Hop period: N/A
        LORAPING_IQ_INVERSION_ON,
        true      //  Continuous receive mode
    );    
}
</code></pre>
<p><em>What's Continuous Receive Mode?</em></p>
<p><strong>Continuous Receive Mode</strong> means that the transceiver will wait forever for incoming packets... Until we tell it to stop.</p>
<p>(We'll stop the transceiver with a BL602 Timer)</p>
<p>But before that, we need to tell the transceiver to begin receiving packets. That's coming up next...</p>
<p>(The code in this article is based on the <a href="https://github.com/apache/mynewt-core/blob/master/apps/loraping/src/main.c">LoRa Ping</a> program from Mynewt OS. <a href="https://lupyuen.github.io/articles/lora#appendix-porting-lora-driver-from-mynewt-to-bl602">More about this</a>)</p>
<h1 id="receive-lora-packet" class="section-header"><a href="#receive-lora-packet">3 Receive LoRa Packet</a></h1>
<p>We're creating a <strong>battery-powered</strong> IoT Sensor with LoRa.</p>
<p>To conserve battery power, we don't listen for incoming LoRa Packets all the time... We <strong>listen for 5 seconds</strong> then go to sleep.</p>
<p>This is how we do it: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L207-L213"><code>demo.c</code></a></p>
<pre><code class="language-c">/// LoRa Receive Timeout in 5 seconds
#define LORAPING_RX_TIMEOUT_MS 5000  //  Milliseconds

/// Command to receive a LoRa message. Assume that SX1276 / RF96 driver has been initialised.
/// Assume that create_task has been called to init the Event Queue.
static void receive_message(char *buf, int len, int argc, char **argv) {
    //  Receive a LoRa message within 5 seconds
    Radio.Rx(LORAPING_RX_TIMEOUT_MS);
}
</code></pre>
<p>The <strong><code>receive_message</code></strong> command calls <strong><code>Radio.Rx</code></strong> (from the SX1276 Driver) to receive a LoRa Packet within 5 seconds.</p>
<h2 id="receive-callback" class="section-header"><a href="#receive-callback">3.1 Receive Callback</a></h2>
<p>Upon receiving the LoRa Packet, the SX1276 Driver calls the Callback Function <strong><code>on_rx_done</code></strong> in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L355-L381"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Callback Function that is called when a LoRa message has been received
static void on_rx_done(
    uint8_t *payload,  //  Buffer containing received LoRa message
    uint16_t size,     //  Size of the LoRa message
    int16_t rssi,      //  Signal strength
    int8_t snr) {      //  Signal To Noise ratio

    //  Switch the LoRa Transceiver to low power, sleep mode
    Radio.Sleep();
</code></pre>
<p>At the start of <code>on_rx_done</code>, we <strong>power down the LoRa Transceiver</strong> to conserve battery power.</p>
<p>Next we <strong>copy the received packet</strong> into our 64-byte buffer <strong><code>loraping_buffer</code></strong>...</p>
<pre><code class="language-c">    //  Copy the received packet (up to 64 bytes)
    if (size &gt; sizeof loraping_buffer) {
        size = sizeof loraping_buffer;
    }
    loraping_rx_size = size;
    memcpy(loraping_buffer, payload, size);
</code></pre>
<p>At the end of the callback, we <strong>display the contents</strong> of the copied packet...</p>
<pre><code class="language-c">    //  Dump the contents of the received packet
    for (int i = 0; i &lt; loraping_rx_size; i++) {
        printf(&quot;%02x &quot;, loraping_buffer[i]);
    }
    printf(&quot;\r\n&quot;);

    //  Log the signal strength, signal to noise ratio
    loraping_rxinfo_rxed(rssi, snr);
}
</code></pre>
<p><em>Is it really OK to call <code>printf</code> here?</em></p>
<p>Yes because this code runs in the context of the <strong>FreeRTOS Application Task</strong>, not in the context of the Interrupt Handler. We'll learn why in a while.</p>
<p>(This differs from the original <a href="https://github.com/apache/mynewt-core/blob/master/apps/loraping/src/main.c">LoRa Ping</a> program... On Mynewt OS, <code>on_rx_done</code> and other Callback Functions will run in the context of the Interrupt Handler)</p>
<h2 id="timeout-and-error-callbacks" class="section-header"><a href="#timeout-and-error-callbacks">3.2 Timeout and Error Callbacks</a></h2>
<p><em>What happens when we don't receive a LoRa Packet in 5 seconds?</em></p>
<p>The SX1276 Driver calls our Callback Function <strong><code>on_rx_timeout</code></strong> that's defined in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L398-L412"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Callback Function that is called when no LoRa messages could be received due to timeout
static void on_rx_timeout(void) {
    //  Switch the LoRa Transceiver to low power, sleep mode
    Radio.Sleep();

    //  Log the timeout
    loraping_stats.rx_timeout++;
    loraping_rxinfo_timeout();
}
</code></pre>
<p>Here we power down the LoRa Transceiver to conserve battery power.</p>
<p>We do the same in the Callback Function <strong><code>on_rx_error</code></strong>, which the SX1276 Driver calls when it hits an error receiving LoRa Packets: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L414-L427"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Callback Function that is called when we couldn't receive a LoRa message due to error
static void on_rx_error(void) {
    //  Log the error
    loraping_stats.rx_error++;

    //  Switch the LoRa Transceiver to low power, sleep mode
    Radio.Sleep();
}
</code></pre>
<h1 id="bl602-gpio-interrupts" class="section-header"><a href="#bl602-gpio-interrupts">4 BL602 GPIO Interrupts</a></h1>
<p>Let's talk about <strong>handling GPIO Interrupts</strong> on BL602...</p>
<p><img src="https://lupyuen.github.io/images/lora2-interrupt.png" alt="BL602 handling GPIO interrupts" /></p>
<ol>
<li>
<p>When our LoRa Transceiver (SX1276) <strong>receives a LoRa Packet</strong>...</p>
</li>
<li>
<p>It shifts the Logic Level of <strong>Pin <code>DIO0</code> from Low to High</strong></p>
</li>
<li>
<p>We shall configure BL602 to detect this shift in the connected GPIO Pin and trigger a <strong>GPIO Interrupt</strong></p>
</li>
<li>
<p>The <strong>GPIO Interrupt Handler</strong> in our firmware code will then process the received LoRa Packet. (And reset <code>DIO0</code> back to Low)</p>
</li>
</ol>
<p>Here's how we configure a GPIO Interrupt Handler on BL602: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276-board.c#L144-L240"><code>sx1276-board.c</code></a></p>
<pre><code class="language-c">//  SX1276 DIO0 is connected to BL602 at GPIO 11
#define SX1276_DIO0 11

//  Register GPIO Handler for DIO0
int rc = register_gpio_handler(   //  Register GPIO Handler...
    SX1276_DIO0,                  //  GPIO Pin Number
    SX1276OnDio0Irq,              //  GPIO Handler Function
    GLB_GPIO_INT_CONTROL_ASYNC,   //  Async Control Mode
    GLB_GPIO_INT_TRIG_POS_PULSE,  //  Trigger when GPIO level shifts from Low to High
    0,                            //  No pullup
    0                             //  No pulldown
);
assert(rc == 0);
</code></pre>
<p>This call to <strong><code>register_gpio_handler</code></strong> says...</p>
<ol>
<li>
<p>When BL602 detects <strong>GPIO Pin 11</strong> (connected to <code>DIO0</code>) shifting from <strong>Low to High</strong> (Positive Edge)...</p>
</li>
<li>
<p>BL602 will call our GPIO Handler Function <strong><code>SX1276OnDio0Irq</code></strong></p>
</li>
</ol>
<p>We'll cover <code>register_gpio_handler</code> in the next section.</p>
<p>Then to enable GPIO Interrupts we call these functions from the <strong>BL602 Interrupt Hardware Abstraction Layer (HAL)</strong>...</p>
<pre><code class="language-c">//  Register Common Interrupt Handler for GPIO Interrupt
bl_irq_register_with_ctx(
    GPIO_INT0_IRQn,         //  GPIO Interrupt
    handle_gpio_interrupt,  //  Interrupt Handler
    NULL                    //  Argument for Interrupt Handler
);

//  Enable GPIO Interrupt
bl_irq_enable(GPIO_INT0_IRQn);
</code></pre>
<p><strong><code>handle_gpio_interrupt</code></strong> is the low-level <strong>Interrupt Handler</strong> that will be called by the BL602 GPIO HAL when the GPIO Interrupt is triggered.</p>
<p>We'll look inside <code>handle_gpio_interrupt</code> in a while.</p>
<h2 id="register-handler-function" class="section-header"><a href="#register-handler-function">4.1 Register Handler Function</a></h2>
<p>Let's look inside our function <strong><code>register_gpio_handler</code></strong> and learn how it <strong>registers a Handler Function for GPIO</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276-board.c#L341-L403"><code>sx1276-board.c</code></a></p>
<pre><code class="language-c">/// Register Handler Function for GPIO. Return 0 if successful.
/// GPIO Handler Function will run in the context of the Application Task, not the Interrupt Handler.
/// Based on bl_gpio_register in https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/bl_gpio.c
static int register_gpio_handler(
    uint8_t gpioPin,         //  GPIO Pin Number
    DioIrqHandler *handler,  //  GPIO Handler Function
    uint8_t intCtrlMod,      //  GPIO Interrupt Control Mode (see below)
    uint8_t intTrgMod,       //  GPIO Interrupt Trigger Mode (see below)
    uint8_t pullup,          //  1 for pullup, 0 for no pullup
    uint8_t pulldown) {      //  1 for pulldown, 0 for no pulldown
</code></pre>
<p>Above are the parameters for <code>register_gpio_handler</code>.</p>
<p>The <strong>GPIO Interrupt Control Modes</strong> are...</p>
<ul>
<li>
<p><strong><code>GLB_GPIO_INT_CONTROL_SYNC</code></strong>:  Synchronous Mode</p>
<p>(We never use sync mode)</p>
</li>
<li>
<p><strong><code>GLB_GPIO_INT_CONTROL_ASYNC</code></strong>: Asynchronous Mode</p>
<p>(We ALWAYS use async mode)</p>
</li>
</ul>
<p>The BL602 Reference Manual doesn't mention GPIO Interrupt Control modes. But according to the BL602 HAL code, only <strong>Async Mode</strong> should be used. <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_button.c#L309">(See this)</a></p>
<p>The <strong>GPIO Interrupt Trigger Mode</strong> specifies how the GPIO should trigger the interrupt...</p>
<ul>
<li>
<p><strong><code>GLB_GPIO_INT_TRIG_NEG_PULSE</code></strong>: Negative Edge Pulse Trigger</p>
<p>Trigger the interrupt when the GPIO Logic Level shifts from <strong>High to Low</strong></p>
</li>
<li>
<p><strong><code>GLB_GPIO_INT_TRIG_POS_PULSE</code></strong>: Positive Edge Pulse Trigger</p>
<p>Trigger the interrupt when the GPIO Logic Level shifts from <strong>Low to High</strong></p>
<p>(We use this for SX1276)</p>
</li>
<li>
<p><strong><code>GLB_GPIO_INT_TRIG_NEG_LEVEL</code></strong>: Negative Edge Level Trigger (32k 3T)</p>
<p>Trigger the interrupt when the GPIO Logic Level stays <strong>Low</strong></p>
</li>
<li>
<p><strong><code>GLB_GPIO_INT_TRIG_POS_LEVEL</code></strong>: Positive Edge Level Trigger (32k 3T)</p>
<p>Trigger the interrupt when the GPIO Logic Level stays <strong>High</strong></p>
</li>
</ul>
<p>The GPIO Interrupt Trigger Mode is (partially) documented in the <a href="https://github.com/bouffalolab/bl_docs/tree/main/BL602_RM/en">BL602 Reference Manual</a> (Section 3.2.12: &quot;GPIO Interrupt&quot;). <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_button.c#L270-L312">(This BL602 HAL code offers more hints)</a></p>
<p>Our GPIO Handler Function <code>handler</code> shall be triggered through an Event (from the NimBLE Porting Layer). We'll learn why later...</p>
<pre><code class="language-c">    //  Init the Event that will invoke the handler for the GPIO Interrupt
    int rc = init_interrupt_event(
        gpioPin,  //  GPIO Pin Number
        handler   //  GPIO Handler Function that will be triggered by the Event
    );
    assert(rc == 0);
</code></pre>
<p>Next we call <code>GLB_GPIO_Func_Init</code> to configure the pin as a <strong>GPIO Pin</strong>...</p>
<pre><code class="language-c">    //  Configure pin as a GPIO Pin
    GLB_GPIO_Type pins[1];
    pins[0] = gpioPin;
    BL_Err_Type rc2 = GLB_GPIO_Func_Init(
        GPIO_FUN_SWGPIO,  //  Configure as GPIO 
        pins,             //  Pins to be configured
        sizeof(pins) / sizeof(pins[0])  //  Number of pins (1)
    );
    assert(rc2 == SUCCESS);    
</code></pre>
<p><code>GLB_GPIO_Func_Init</code> comes from the BL602 Standard Driver: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_glb.c"><code>bl602_glb.c</code></a></p>
<p>We configure the pin as a <strong>GPIO Input Pin</strong> (instead of GPIO Output)...</p>
<pre><code class="language-c">    //  Configure pin as a GPIO Input Pin
    rc = bl_gpio_enable_input(
        gpioPin,  //  GPIO Pin Number
        pullup,   //  1 for pullup, 0 for no pullup
        pulldown  //  1 for pulldown, 0 for no pulldown
    );
    assert(rc == 0);
</code></pre>
<p>Finally we disable the GPIO Pin Interrupt, configure the <strong>GPIO Interrupt Control and Trigger Modes</strong>, and enable the GPIO Pin Interrupt...</p>
<pre><code class="language-c">    //  Disable GPIO Interrupt for the pin
    bl_gpio_intmask(gpioPin, 1);

    //  Configure GPIO Pin for GPIO Interrupt
    bl_set_gpio_intmod(
        gpioPin,     //  GPIO Pin Number
        intCtrlMod,  //  GPIO Interrupt Control Mode (see below)
        intTrgMod    //  GPIO Interrupt Trigger Mode (see below)
    );

    //  Enable GPIO Interrupt for the pin
    bl_gpio_intmask(gpioPin, 0);
    return 0;
}
</code></pre>
<p>We're ready to handle GPIO Interrupts triggered by our LoRa Transceiver!</p>
<p><em>There seems to be 2 types of GPIO Interrupts?</em></p>
<p>Yep, earlier we saw this...</p>
<pre><code class="language-c">//  Enable GPIO Interrupt
bl_irq_enable(GPIO_INT0_IRQn);
</code></pre>
<p>This enables the GPIO Interrupt for <strong>ALL GPIO Pins</strong> (by calling the BL602 Interrupt HAL).</p>
<p>Then we saw this...</p>
<pre><code class="language-c">//  Enable GPIO Interrupt for the pin
bl_gpio_intmask(gpioPin, 0);
</code></pre>
<p>This enables the GPIO Interrupt for <strong>ONE Specific GPIO Pin</strong> (by calling the BL602 GPIO HAL).</p>
<p>We need both to make GPIO Interrupts work.</p>
<h2 id="gpio-interrupt-handler" class="section-header"><a href="#gpio-interrupt-handler">4.2 GPIO Interrupt Handler</a></h2>
<p><em>GPIO Interrupt Handler vs GPIO Handler Function... Are these different things?</em></p>
<p>I'm sorry to muddle my dearest readers, they are indeed different things and they work at different levels...</p>
<ol>
<li>
<p><strong>GPIO Interrupt Handler</strong> (<code>handle_gpio_interrupt</code>) is the low-level <strong>Interrupt Service Routine</strong> that handles the GPIO Interrupt.</p>
<p>This Interrupt Handler (called by BL602 Interrupt HAL) services the GPIO Interrupt that's triggered when SX1276 receives a LoRa Packet.</p>
</li>
<li>
<p><strong>GPIO Handler Function</strong> (like <code>SX1276OnDio0Irq</code>) is the high-level <strong>Application Function</strong> (running in a FreeRTOS Task) that processes the received LoRa Packet.</p>
<p>This Handler Function is invoked (indirectly) by the Interrupt Handler (via an Event from NimBLE Porting Layer).</p>
<p>(What's an Event and why are we using it? We'll learn about the NimBLE Porting Layer in a while)</p>
</li>
</ol>
<p>Let's study the low-level <strong>GPIO Interrupt Handler <code>handle_gpio_interrupt</code></strong> that services all GPIO Interrupts: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276-board.c#L405-L433"><code>sx1276-board.c</code></a></p>
<pre><code class="language-c">/// Interrupt Handler for GPIO Pins DIO0 to DIO5. Triggered by SX1276 when LoRa Packet is received 
/// and for other conditions.  Based on gpio_interrupt_entry in
/// https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/bl_gpio.c#L151-L164
static void handle_gpio_interrupt(void *arg) {
    //  Check all GPIO Interrupt Events
    for (int i = 0; i &lt; MAX_GPIO_INTERRUPTS; i++) {
        //  Get the GPIO Interrupt Event
        struct ble_npl_event *ev = &amp;gpio_events[i];

        //  If the Event is unused, skip it
        if (ev-&gt;fn == NULL) { continue; }

        //  Get the GPIO Pin Number for the Event
        GLB_GPIO_Type gpioPin = gpio_interrupts[i];

        //  Get the Interrupt Status of the GPIO Pin
        BL_Sts_Type status = GLB_Get_GPIO_IntStatus(gpioPin);

        //  If the GPIO Pin has triggered an interrupt...
        if (status == SET) {
            //  Forward the GPIO Interrupt to the Application Task to process
            enqueue_interrupt_event(
                gpioPin,  //  GPIO Pin Number
                ev        //  Event that will be enqueued for the Application Task
            );
        }
    }
}
</code></pre>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276-board.c#L435-L469"><code>sx1276-board.c</code></a></p>
<pre><code class="language-c">/// Interrupt Counters
int g_dio0_counter, g_dio1_counter, g_dio2_counter, g_dio3_counter, g_dio4_counter, g_dio5_counter, g_nodio_counter;

/// Enqueue the GPIO Interrupt to an Event Queue for the Application Task to process
static int enqueue_interrupt_event(
    uint8_t gpioPin,                //  GPIO Pin Number
    struct ble_npl_event *event) {  //  Event that will be enqueued for the Application Task

    //  Disable GPIO Interrupt for the pin
    bl_gpio_intmask(gpioPin, 1);

    //  Note: DO NOT Clear the GPIO Interrupt Status for the pin!
    //  This will suppress subsequent GPIO Interrupts!
    //  bl_gpio_int_clear(gpioPin, SET);

    //  Increment the Interrupt Counters
    if (SX1276_DIO0 &gt;= 0 &amp;&amp; gpioPin == (uint8_t) SX1276_DIO0) { g_dio0_counter++; }
    //  Omitted: Increment Interrupt Counters
    //  for DIO1 to DIO4
    ...
    else if (SX1276_DIO5 &gt;= 0 &amp;&amp; gpioPin == (uint8_t) SX1276_DIO5) { g_dio5_counter++; }
    else { g_nodio_counter++; }

    //  Use Event Queue to invoke Event Handler in the Application Task, 
    //  not in the Interrupt Context
    if (event != NULL &amp;&amp; event-&gt;fn != NULL) {
        extern struct ble_npl_eventq event_queue;  //  TODO: Move Event Queue to header file
        ble_npl_eventq_put(&amp;event_queue, event);
    }

    //  Enable GPIO Interrupt for the pin
    bl_gpio_intmask(gpioPin, 0);
    return 0;
}
</code></pre>
<p>TODO</p>
<h2 id="handling-dio0-to-dio5" class="section-header"><a href="#handling-dio0-to-dio5">4.3 Handling DIO0 to DIO5</a></h2>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276.h#L48-L53"><code>sx1276.h</code></a></p>
<pre><code class="language-c">#define SX1276_DIO0        11  //  DIO0: Trigger for Packet Received
#define SX1276_DIO1         0  //  DIO1: Trigger for Sync Timeout
#define SX1276_DIO2         5  //  DIO2: Trigger for Change Channel (Spread Spectrum / Frequency Hopping)
#define SX1276_DIO3        12  //  DIO3: Trigger for CAD Done
#define SX1276_DIO4        -1  //  DIO4: Unused (FSK only)
#define SX1276_DIO5        -1  //  DIO5: Unused (FSK only)
</code></pre>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276.c#L208-L213"><code>sx1276.c</code></a></p>
<pre><code class="language-c">//  DIO Handler Functions
DioIrqHandler *DioIrq[] = { 
    SX1276OnDio0Irq, SX1276OnDio1Irq,
    SX1276OnDio2Irq, SX1276OnDio3Irq,
    SX1276OnDio4Irq, NULL };
</code></pre>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276-board.c#L144-L240"><code>sx1276-board.c</code></a></p>
<pre><code class="language-c">/// Register GPIO Interrupt Handlers for DIO0 to DIO5.
/// Based on hal_button_register_handler_with_dts in https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_button.c
void SX1276IoIrqInit(DioIrqHandler **irqHandlers) {
    int rc;

    //  DIO0: Trigger for Packet Received and Packet Transmitted
    if (SX1276_DIO0 &gt;= 0 &amp;&amp; irqHandlers[0] != NULL) {
        rc = register_gpio_handler(       //  Register GPIO Handler...
            SX1276_DIO0,                  //  GPIO Pin Number
            irqHandlers[0],               //  GPIO Handler Function
            GLB_GPIO_INT_CONTROL_ASYNC,   //  Async Control Mode
            GLB_GPIO_INT_TRIG_POS_PULSE,  //  Trigger when GPIO level shifts from Low to High
            0,                            //  No pullup
            0                             //  No pulldown
        );
        assert(rc == 0);
    }

    //  Omitted: Register GPIO Handler Functions
    //  for DIO1 to DIO4
    ...

    //  DIO5: Unused (FSK only)
    if (SX1276_DIO5 &gt;= 0 &amp;&amp; irqHandlers[5] != NULL) {
        rc = register_gpio_handler(       //  Register GPIO Handler...
            SX1276_DIO5,                  //  GPIO Pin Number
            irqHandlers[5],               //  GPIO Handler Function
            GLB_GPIO_INT_CONTROL_ASYNC,   //  Async Control Mode
            GLB_GPIO_INT_TRIG_POS_PULSE,  //  Trigger when GPIO level shifts from Low to High
            0,                            //  No pullup
            0                             //  No pulldown
        );
        assert(rc == 0);
    }

    //  Register Common Interrupt Handler for GPIO Interrupt
    bl_irq_register_with_ctx(
        GPIO_INT0_IRQn,         //  GPIO Interrupt
        handle_gpio_interrupt,  //  Interrupt Handler
        NULL                    //  Argument for Interrupt Handler
    );

    //  Enable GPIO Interrupt
    bl_irq_enable(GPIO_INT0_IRQn);
}
</code></pre>
<p>TODO</p>
<h1 id="multitask-with-nimble-porting-layer" class="section-header"><a href="#multitask-with-nimble-porting-layer">5 Multitask with NimBLE Porting Layer</a></h1>
<p>TODO</p>
<h2 id="background-task" class="section-header"><a href="#background-task">5.1 Background Task</a></h2>
<p>TODO</p>
<h2 id="event-queue" class="section-header"><a href="#event-queue">5.2 Event Queue</a></h2>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276-board.c#L471-L498"><code>sx1276-board.c</code></a></p>
<pre><code class="language-c">//  Init the Event that will the Interrupt Handler will invoke to process the GPIO Interrupt
static int init_interrupt_event(
    uint8_t gpioPin,           //  GPIO Pin Number
    DioIrqHandler *handler) {  //  GPIO Handler Function

    //  Find an unused Event with null handler and set it
    for (int i = 0; i &lt; MAX_GPIO_INTERRUPTS; i++) {
        struct ble_npl_event *ev = &amp;gpio_events[i];

        //  If the Event is used, skip it
        if (ev-&gt;fn != NULL) { continue; }

        //  Set the Event handler
        ble_npl_event_init(   //  Init the Event for...
            ev,               //  Event
            handler,          //  Event Handler Function
            NULL              //  Argument to be passed to Event Handler
        );

        //  Set the GPIO Pin Number for the Event
        gpio_interrupts[i] = gpioPin;
        return 0;
    }

    //  No unused Events found, should increase MAX_GPIO_INTERRUPTS
    assert(false);
    return -1;
}
</code></pre>
<p>TODO</p>
<h2 id="timer" class="section-header"><a href="#timer">5.3 Timer</a></h2>
<p>TODO</p>
<h1 id="bl602-stack-trace" class="section-header"><a href="#bl602-stack-trace">6 BL602 Stack Trace</a></h1>
<p>TODO</p>
<h1 id="always-initialise-stack-variables" class="section-header"><a href="#always-initialise-stack-variables">7 Always Initialise Stack Variables!</a></h1>
<p>TODO</p>
<h1 id="start-the-rakwireless-wisblock-transmitter" class="section-header"><a href="#start-the-rakwireless-wisblock-transmitter">8 Start the RAKwireless WisBlock Transmitter</a></h1>
<p>TODO</p>
<h1 id="build-and-run-the-bl602-lora-firmware" class="section-header"><a href="#build-and-run-the-bl602-lora-firmware">9 Build and Run the BL602 LoRa Firmware</a></h1>
<p>TODO</p>
<p>Let's run the LoRa Demo Firmware for BL602.</p>
<p>Find out which <strong>LoRa Frequency</strong> we should use for your region...</p>
<ul>
<li><a href="https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html"><strong>LoRa Frequencies by Country</strong></a></li>
</ul>
<p>Download the Firmware Binary File <strong><code>sdk_app_lora.bin</code></strong> for your LoRa Frequency...</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/releases/tag/v6.0.1"><strong>434 MHz <code>sdk_app_lora</code> Binary</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/releases/tag/v6.0.2"><strong>780 MHz <code>sdk_app_lora</code> Binary</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/releases/tag/v6.0.3"><strong>868 MHz <code>sdk_app_lora</code> Binary</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/releases/tag/v6.0.4"><strong>915 MHz <code>sdk_app_lora</code> Binary</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/releases/tag/v6.0.0"><strong>923 MHz <code>sdk_app_lora</code> Binary</strong></a></p>
</li>
</ul>
<p>Alternatively, we may build the Firmware Binary File <code>sdk_app_lora.bin</code> from the <a href="https://github.com/lupyuen/bl_iot_sdk/tree/lora/customer_app/sdk_app_lora">source code</a>...</p>
<pre><code class="language-bash"># Download the lorarecv branch of lupyuen's bl_iot_sdk
git clone --recursive --branch lorarecv https://github.com/lupyuen/bl_iot_sdk
cd bl_iot_sdk/customer_app/sdk_app_lora

# TODO: Set the LoRa Frequency in sdk_app_lora/demo.c. 
# Edit the file and look for the line...
#   #define USE_BAND_923
# Change 923 to the LoRa Frequency for your region: 
#   434, 780, 868, 915 or 923 MHz
# See https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html

# TODO: Change this to the full path of bl_iot_sdk
export BL60X_SDK_PATH=$HOME/bl_iot_sdk
export CONFIG_CHIP_NAME=BL602
make

# TODO: Change ~/blflash to the full path of blflash
cp build_out/sdk_app_lora.bin ~/blflash
</code></pre>
<p><a href="https://lupyuen.github.io/articles/pinecone#building-firmware">More details on building bl_iot_sdk</a></p>
<p>(Remember to use the <strong><code>lorarecv</code></strong> branch, not the default <strong><code>master</code></strong> branch)</p>
<h2 id="flash-the-firmware" class="section-header"><a href="#flash-the-firmware">9.1 Flash the firmware</a></h2>
<p>Follow these steps to install <code>blflash</code>...</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>&quot;Install rustup&quot;</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>&quot;Download and build blflash&quot;</strong></a></p>
</li>
</ol>
<p>We assume that our Firmware Binary File <code>sdk_app_lora.bin</code> has been copied to the <code>blflash</code> folder.</p>
<p>Set BL602 to <strong>Flashing Mode</strong> and restart the board...</p>
<p><strong>For PineCone:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ol>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>Enter these commands to flash <code>sdk_app_lora.bin</code> to BL602 over UART...</p>
<pre><code class="language-bash"># TODO: Change ~/blflash to the full path of blflash
cd ~/blflash

# For Linux:
sudo cargo run flash sdk_app_lora.bin \
    --port /dev/ttyUSB0

# For macOS:
cargo run flash sdk_app_lora.bin \
    --port /dev/tty.usbserial-1420 \
    --initial-baud-rate 230400 \
    --baud-rate 230400

# For Windows: Change COM5 to the BL602 Serial Port
cargo run flash sdk_app_lora.bin --port COM5
</code></pre>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">More details on flashing firmware</a></p>
<h2 id="run-the-firmware" class="section-header"><a href="#run-the-firmware">9.2 Run the firmware</a></h2>
<p>Set BL602 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board...</p>
<p><strong>For PineCone:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ol>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>After restarting, connect to BL602's UART Port at 2 Mbps like so...</p>
<p><strong>For Linux:</strong></p>
<pre><code class="language-bash">sudo screen /dev/ttyUSB0 2000000
</code></pre>
<p><strong>For macOS:</strong> Use CoolTerm (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>For Windows:</strong> Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">More details on connecting to BL602</a></p>
<h2 id="enter-lora-commands" class="section-header"><a href="#enter-lora-commands">9.3 Enter LoRa commands</a></h2>
<p>Let's enter some commands to transmit a LoRa Packet!</p>
<ol>
<li>
<p>Press Enter to reveal the command prompt.</p>
</li>
<li>
<p>Enter <code>help</code> to see the available commands...</p>
<pre><code class="language-text"># help
====User Commands====
read_registers           : Read registers
send_message             : Send LoRa message
spi_result               : Show SPI counters
</code></pre>
</li>
<li>
<p>First we <strong>initialise our LoRa Transceiver</strong>. </p>
<p>Enter this command...</p>
<pre><code class="language-text"># init_driver
</code></pre>
<p>This command calls the function <code>init_driver</code>, which we have seen earlier.</p>
</li>
<li>
<p>We should see this...</p>
<pre><code class="language-text"># init_driver
port0 eventloop init = 42010760
[HAL] [SPI] Init :
port=0, mode=0, polar_phase = 1, freq=200000, tx_dma_ch=2, rx_dma_ch=3, pin_clk=3, pin_cs=2, pin_mosi=1, pin_miso=4
set rwspeed = 200000
hal_gpio_init: cs:2, clk:3, mosi:1, miso: 4
hal_gpio_init: SPI controller mode
hal_spi_init.
</code></pre>
<p>The above messages say that our SPI Port has been configured by the BL602 SPI HAL.</p>
<pre><code class="language-text">hal_spi_transfer = 1
transfer xfer[0].len = 1
Tx DMA src=0x4200cc58, dest=0x4000a288, size=1, si=1, di=0, i=1
Rx DMA src=0x4000a28c, dest=0x4200cc54, size=1, si=0, di=1, i=1
recv all event group.
...
</code></pre>
<p><code>init_driver</code> has just configured our SPI Transceiver by setting the registers over SPI.</p>
</li>
<li>
<p>Next we <strong>transmit a LoRa Packet</strong>...</p>
<pre><code class="language-text"># send_message
</code></pre>
<p>This command calls the function <code>send_message</code>, which we have seen earlier.</p>
</li>
<li>
<p>We should see this...</p>
<pre><code class="language-text"># send_message
hal_spi_transfer = 1
transfer xfer[0].len = 1
Tx DMA src=0x4200cc58, dest=0x4000a288, size=1, si=1, di=0, i=1
Rx DMA src=0x4000a28c, dest=0x4200cc54, size=1, si=0, di=1, i=1
recv all event group.
...
</code></pre>
<p>That's <code>send_message</code> blasting the 64-byte LoRa Packet to the airwave, in the simple &quot;Fire And Forget&quot; Mode.</p>
<p>(The LoRa Driver copies the 64-byte Transmit Buffer to our LoRa Transceiver over SPI, byte by byte. Hence the numerous SPI requests.)</p>
<p><a href="https://youtu.be/9F30uEY-nIk"><strong>Watch the video on YouTube</strong></a></p>
<p><a href="https://gist.github.com/lupyuen/31ac29aa776601ba6a610a93f3190c72"><strong>Check out the complete log</strong></a></p>
</li>
<li>
<p>If we wish to <strong>transmit LoRa Packets automatically on startup</strong> (without entering any commands), check out the LoRa Ping Firmware...</p>
<p><a href="https://lupyuen.github.io/articles/wisblock#appendix-lora-ping-firmware-for-bl602"><strong>LoRa Ping Firmware for BL602</strong></a></p>
</li>
</ol>
<h1 id="troubleshoot-lora" class="section-header"><a href="#troubleshoot-lora">10 Troubleshoot LoRa</a></h1>
<p>TODO</p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">11 What's Next</a></h1>
<p>TODO</p>
<p>We have come a loooong way since I first <a href="https://github.com/lupyuen/LoRaArduino"><strong>experimented with LoRa in 2016</strong></a>...</p>
<ul>
<li>
<p><strong>Cheaper Transceivers</strong>: Shipped overnight from Thailand!</p>
</li>
<li>
<p><strong>Mature Networks</strong>: LoRaWAN, The Things Network</p>
</li>
<li>
<p><strong>Better Drivers</strong>: Thanks to Apache Mynewt OS!</p>
</li>
<li>
<p><strong>Powerful Microcontrollers</strong>: Arduino Uno vs RISC-V BL602</p>
</li>
<li>
<p><strong>Awesome Tools</strong>: RAKwireless WisBlock, Airspy SDR, RF Explorer</p>
</li>
</ul>
<p>Now is the <strong>right time to build LoRa gadgets.</strong> Stay tuned for more LoRa Adventures!</p>
<p>Meanwhile there's plenty more code in the <a href="https://github.com/bouffalolab/bl_iot_sdk"><strong>BL602 IoT SDK</strong></a> to be deciphered and documented: <strong>ADC, DAC, WiFi, Bluetooth LE,</strong> ...</p>
<p><a href="https://wiki.pine64.org/wiki/Nutcracker"><strong>Come Join Us... Make BL602 Better!</strong></a></p>
<p>üôè üëç üòÄ</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read &quot;The RISC-V BL602 Book&quot;</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here...</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/lora2.md"><code>lupyuen.github.io/src/lora2.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">12 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1370708936739885056?s=20">this Twitter Thread</a></li>
</ol>

    
</body>
</html>