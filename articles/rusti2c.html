<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Rust talks I2C on Apache NuttX RTOS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Rust talks I2C on Apache NuttX RTOS" 
    data-rh="true">
<meta property="og:description" 
    content="Reading the Bosch BME280 I2C Sensor with Rust Embedded HAL... On BL602 RISC-V SoC and Apache NuttX RTOS"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/rusti2c-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Rust talks I2C on Apache NuttX RTOS</h1>
    <nav id="TOC"><ul>
<li><a href="#read-sensor-data-from-bme280">1 Read Sensor Data from BME280</a><ul></ul></li>
<li><a href="#connect-bme280">2 Connect BME280</a><ul></ul></li>
<li><a href="#run-bme280-app">3 Run BME280 App</a><ul></ul></li>
<li><a href="#rust-driver-for-bme280">4 Rust Driver for BME280</a><ul></ul></li>
<li><a href="#nuttx-embedded-hal">5 NuttX Embedded HAL</a><ul></ul></li>
<li><a href="#from-c-to-rust">6 From C to Rust</a><ul></ul></li>
<li><a href="#c-types-and-constants">7 C Types and Constants</a><ul></ul></li>
<li><a href="#read-i2c-register-in-rust">8 Read I2C Register in Rust</a><ul></ul></li>
<li><a href="#test-i2c-port">9 Test I2C Port</a><ul></ul></li>
<li><a href="#rust-embedded-hal">10 Rust Embedded HAL</a><ul></ul></li>
<li><a href="#read-i2c-register">11 Read I2C Register</a><ul></ul></li>
<li><a href="#test-i2c-hal">12 Test I2C HAL</a><ul></ul></li>
<li><a href="#write-i2c-register">13 Write I2C Register</a><ul></ul></li>
<li><a href="#fix-i2c-write">14 Fix I2C Write</a><ul></ul></li>
<li><a href="#whats-next">15 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">16 Notes</a><ul></ul></li>
<li><a href="#appendix-build-flash-and-run-nuttx">17 Appendix: Build, Flash and Run NuttX</a><ul>
<li><a href="#download-nuttx">17.1 Download NuttX</a><ul></ul></li>
<li><a href="#configure-nuttx">17.2 Configure NuttX</a><ul></ul></li>
<li><a href="#configure-rust-target">17.3 Configure Rust Target</a><ul></ul></li>
<li><a href="#build-nuttx">17.4 Build NuttX</a><ul></ul></li>
<li><a href="#flash-nuttx">17.5 Flash NuttX</a><ul></ul></li>
<li><a href="#run-nuttx">17.6 Run NuttX</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>26 Mar 2022</em></p>
<p><img src="https://lupyuen.github.io/images/rusti2c-title.jpg" alt="Bosch BME280 Sensor connected to Pine64 PineCone BL602 RISC-V Board" /></p>
<p><em><a href="https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/">Bosch BME280 Sensor</a> connected to <a href="https://lupyuen.github.io/articles/pinecone">Pine64 PineCone BL602 RISC-V Board</a></em></p>
<p><a href="https://en.wikipedia.org/wiki/I%C2%B2C"><strong>I2C</strong></a> is a great way to connect all kinds of <strong>Sensor Modules</strong> when we‚Äôre creating an <strong>IoT Gadget</strong>. Like sensors for temperature, light, motion, spectroscopy, soil moisture, GPS, LIDAR, ‚Ä¶ <a href="https://www.sparkfun.com/categories/tags/i2c"><strong>and many more!</strong></a></p>
<p><em>But where will we get the Software Drivers for the I2C Sensors?</em></p>
<p><a href="https://github.com/rust-embedded/awesome-embedded-rust#driver-crates"><strong>Embedded Rust</strong></a> has a large collection of drivers for I2C Sensors. And they will work on <a href="https://github.com/rust-embedded/awesome-embedded-rust#hal-implementation-crates"><strong>many platforms!</strong></a></p>
<p>Today we shall experiment with the Rust Driver for <a href="https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/"><strong>Bosch BME280 Sensor</strong></a> (Temperature / Humdity / Air Pressure). And learn how we made it work on the (Linux-like) <a href="https://lupyuen.github.io/articles/nuttx"><strong>Apache NuttX RTOS</strong></a>.</p>
<p>We‚Äôll run this on the <a href="https://lupyuen.github.io/articles/pinecone"><strong>BL602 RISC-V SoC</strong></a> (pic above), though it should work fine on ESP32 and other NuttX platforms.</p>
<p>Let‚Äôs dive into our <strong>Rust I2C App for NuttX</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/rust-i2c-nuttx"><strong>lupyuen/rust-i2c-nuttx</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/rusti2c-code10a.png" alt="Read Sensor Data from BME280" /></p>
<h1 id="read-sensor-data-from-bme280" class="section-header"><a href="#read-sensor-data-from-bme280">1 Read Sensor Data from BME280</a></h1>
<p>Here‚Äôs how we read the <strong>Temperature, Humidity and Air Pressure</strong> from the BME280 Sensor: <a href="https://github.com/lupyuen/rust-i2c-nuttx/blob/main/rust/src/bme280.rs">rust/src/bme280.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Read Temperature, Pressure and Humidity from BME280 Sensor over I2C</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">read_bme280</span>() {

  <span class="comment">//  Open I2C Port</span>
  <span class="kw">let</span> <span class="ident">i2c</span> <span class="op">=</span> <span class="ident">nuttx_embedded_hal::I2c::new</span>(
    <span class="string">&quot;/dev/i2c0&quot;</span>,  <span class="comment">//  I2C Port</span>
    <span class="number">400000</span>,       <span class="comment">//  I2C Frequency: 400 kHz</span>
  ).<span class="ident">expect</span>(<span class="string">&quot;open failed&quot;</span>);</code></pre></div>
<p>We begin by opening the I2C Port ‚Äú<strong>/dev/i2c0</strong>‚Äù, configured for 400 kHz.</p>
<p>(This halts with an error if the I2C Port doesn‚Äôt exist)</p>
<p><em>What‚Äôs <strong>nuttx_embedded_hal</strong>?</em></p>
<p>That‚Äôs the <strong>Hardware Abstraction Layer</strong> (HAL) for NuttX, coded in Rust. (More about this in a while)</p>
<p>Next we <strong>initialise the BME280 Driver</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Init the BME280 Driver</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bme280</span> <span class="op">=</span> <span class="ident">bme280::BME280::new</span>(
    <span class="ident">i2c</span>,   <span class="comment">//  I2C Port</span>
    <span class="number">0x77</span>,  <span class="comment">//  I2C Address of BME280</span>
    <span class="ident">nuttx_embedded_hal::Delay</span>  <span class="comment">//  Delay Interface</span>
  );</code></pre></div>
<p><strong>BME280</strong> comes from the BME280 Driver Crate. (As we‚Äôll see soon)</p>
<p>Before reading from the BME280 Sensor, we need to <strong>initialise the sensor</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Init the BME280 Sensor</span>
  <span class="ident">bme280</span>.<span class="ident">init</span>()
    .<span class="ident">expect</span>(<span class="string">&quot;init failed&quot;</span>);</code></pre></div>
<p>This halts with an error if the initialisation fails.</p>
<p>We‚Äôre ready to read the <strong>Temperature, Humidity and Air Pressure</strong> from the BME280 Sensor‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Measure Temperature, Pressure and Humidity</span>
  <span class="kw">let</span> <span class="ident">measurements</span> <span class="op">=</span> <span class="ident">bme280</span>.<span class="ident">measure</span>()
    .<span class="ident">expect</span>(<span class="string">&quot;measure failed&quot;</span>);</code></pre></div>
<p>Finally we <strong>print the Sensor Data</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Print the measurements</span>
  <span class="macro">println!</span>(<span class="string">&quot;Relative Humidity = {}%&quot;</span>, <span class="ident">measurements</span>.<span class="ident">humidity</span>);
  <span class="macro">println!</span>(<span class="string">&quot;Temperature = {} deg C&quot;</span>,  <span class="ident">measurements</span>.<span class="ident">temperature</span>);
  <span class="macro">println!</span>(<span class="string">&quot;Pressure = {} pascals&quot;</span>,   <span class="ident">measurements</span>.<span class="ident">pressure</span>);
}</code></pre></div>
<p>That‚Äôs all we need to read the Sensor Data from the BME280 Sensor!</p>
<p><em>Where is <strong>println</strong> defined?</em></p>
<p><strong>println</strong> comes from our NuttX Embedded HAL. This is how we import it‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Import Libraries</span>
<span class="kw">use</span> <span class="ident">nuttx_embedded_hal</span>::{  <span class="comment">//  NuttX Embedded HAL</span>
  <span class="ident">println</span>,                 <span class="comment">//  Print a formatted message</span>
};</code></pre></div>
<p>Before running our Rust App, let‚Äôs connect the BME280 Sensor.</p>
<p><img src="https://lupyuen.github.io/images/bme280-connect.jpg" alt="Bosch BME280 Sensor connected to Pine64 PineCone BL602 RISC-V Board" /></p>
<h1 id="connect-bme280" class="section-header"><a href="#connect-bme280">2 Connect BME280</a></h1>
<p>We connect BME280 to Pine64‚Äôs <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 Board</strong></a> as follows‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">BL602 Pin</th><th style="text-align: center">BME280 Pin</th><th style="text-align: left">Wire Colour</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>GPIO 3</code></strong></td><td style="text-align: center"><code>SDA</code></td><td style="text-align: left">Green</td></tr>
<tr><td style="text-align: center"><strong><code>GPIO 4</code></strong></td><td style="text-align: center"><code>SCL</code></td><td style="text-align: left">Blue</td></tr>
<tr><td style="text-align: center"><strong><code>3V3</code></strong></td><td style="text-align: center"><code>3.3V</code></td><td style="text-align: left">Red</td></tr>
<tr><td style="text-align: center"><strong><code>GND</code></strong></td><td style="text-align: center"><code>GND</code></td><td style="text-align: left">Black</td></tr>
</tbody></table>
</div>
<p>(Pic above)</p>
<p>The <strong>I2C Pins</strong> on BL602 are defined here: <a href="https://github.com/lupyuen/incubator-nuttx/blob/rusti2c/boards/risc-v/bl602/bl602evb/include/board.h#L85-L88">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* I2C Configuration */
#define BOARD_I2C_SCL \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN4)
#define BOARD_I2C_SDA \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN3)</code></pre></div>
<p>We disabled the <strong>UART1 Port</strong> because it uses the same pins as I2C: <a href="https://github.com/lupyuen/incubator-nuttx/blob/rusti2c/boards/risc-v/bl602/bl602evb/include/board.h#L63-L68">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef TODO  /* Remember to check for duplicate pins! */
#define BOARD_UART_1_RX_PIN \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_UART | \
  GPIO_PIN3)
#define BOARD_UART_1_TX_PIN \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_UART | \
  GPIO_PIN4)
#endif  /* TODO */</code></pre></div>
<p>(UART0 is used by the Serial Console)</p>
<p><em>What if we‚Äôre connecting to ESP32?</em></p>
<p><strong>For ESP32:</strong> The GPIO Pin Numbers for the I2C Port (I2C0) are defined in <a href="https://github.com/lupyuen/incubator-nuttx/blob/rusti2c/arch/xtensa/src/esp32/Kconfig#L797-L805">Kconfig</a> and menuconfig‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>config ESP32_I2C0_SCLPIN
  int &quot;I2C0 SCL Pin&quot;
  default 22
  range 0 39

config ESP32_I2C0_SDAPIN
  int &quot;I2C0 SDA Pin&quot;
  default 23
  range 0 39</code></pre></div>
<p><em>Do we need Pull-Up Resistors?</em></p>
<p>We‚Äôre using the <a href="https://learn.sparkfun.com/tutorials/sparkfun-bme280-breakout-hookup-guide/all"><strong>SparkFun BME280 Breakout Board</strong></a>, which has <strong>Pull-Up Resistors</strong>. (So we don‚Äôt need to add our own)</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-run2a.png" alt="Run BME280 App" /></p>
<h1 id="run-bme280-app" class="section-header"><a href="#run-bme280-app">3 Run BME280 App</a></h1>
<p>We‚Äôre ready to run our Rust App on NuttX!</p>
<ol>
<li>
<p>Follow these steps to <strong>build, flash and run NuttX</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/rusti2c#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX‚Äù</strong></a></p>
</li>
<li>
<p>At the NuttX Shell, enter this command to list the <strong>NuttX Devices</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>ls /dev</code></pre></div></li>
<li>
<p>We should see our <strong>I2C Port</strong> that‚Äôs connected to BME280‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/dev:
 i2c0
 ...</code></pre></div></li>
<li>
<p>To <strong>read the BME280 Sensor</strong>, enter this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>rust_i2c</code></pre></div></li>
<li>
<p>We should see the <strong>Relative Humidity, Temperature and Air Pressure</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>read_bme280
Relative Humidity = 89.284164%
Temperature = 29.942907 deg C
Pressure = 100483.04 pascals
Done!</code></pre></div>
<p><a href="https://github.com/lupyuen/rust-i2c-nuttx#test-rust-driver-for-bme280">(See the complete log)</a></p>
</li>
</ol>
<p>The Rust Driver for BME280 runs successfully on NuttX!</p>
<h1 id="rust-driver-for-bme280" class="section-header"><a href="#rust-driver-for-bme280">4 Rust Driver for BME280</a></h1>
<p><em>We ran the Rust Driver for BME280 on NuttX‚Ä¶ Without any code changes?</em></p>
<p>Yeah amazing right? Earlier we saw this: <a href="https://github.com/lupyuen/rust-i2c-nuttx/blob/main/rust/src/bme280.rs">rust/src/bme280.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Init the BME280 Driver</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bme280</span> <span class="op">=</span> <span class="ident">bme280::BME280</span>
    <span class="ident">::new</span>( ... );</code></pre></div>
<p><strong>BME280</strong> comes from the Rust Embedded Driver for BME280‚Ä¶</p>
<ul>
<li><a href="https://crates.io/crates/bme280"><strong>crates.io/bme280</strong></a></li>
</ul>
<p>That we have added to our <a href="https://github.com/lupyuen/rust-i2c-nuttx/blob/main/rust/Cargo.toml"><strong>Cargo.toml</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code># External Rust libraries used by this module.  See crates.io.
[dependencies]

# BME280 Driver: https://crates.io/crates/bme280
bme280 = &quot;0.2.1&quot;

# NuttX Embedded HAL: https://crates.io/crates/nuttx-embedded-hal
nuttx-embedded-hal = &quot;1.0.7&quot;  

# Rust Embedded HAL: https://crates.io/crates/embedded-hal
embedded-hal = &quot;0.2.7&quot;  </code></pre></div>
<p>The Rust Driver for BME280 run OK on NuttX because we have implemented the <strong>NuttX Embedded HAL</strong>. Let‚Äôs look inside the HAL.</p>
<p><a href="https://crates.io/crates/nuttx-embedded-hal">(BTW: Always use the latest version of <strong>nuttx-embedded-hal</strong>)</a></p>
<h1 id="nuttx-embedded-hal" class="section-header"><a href="#nuttx-embedded-hal">5 NuttX Embedded HAL</a></h1>
<p>TODO</p>
<p>The Rust Embedded HAL for NuttX has been published at crates.io‚Ä¶</p>
<p>https://crates.io/crates/nuttx-embedded-hal</p>
<p>To use it in your project, add this to your <a href="rust/Cargo.toml">Cargo.toml</a>:</p>
<div class="example-wrap"><pre class="language-text"><code>[dependencies]
nuttx-embedded-hal = &quot;1.0.6&quot;  # Rust Embedded HAL for NuttX: https://crates.io/crates/nuttx-embedded-hal</code></pre></div>
<p><a href="https://crates.io/crates/nuttx-embedded-hal">(Always use the latest version of <strong>nuttx-embedded-hal</strong>)</a></p>
<h1 id="from-c-to-rust" class="section-header"><a href="#from-c-to-rust">6 From C to Rust</a></h1>
<p>TODO</p>
<p>This is how we read an I2C Register in C‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>static int bme280_reg_read(const struct device *priv,
    uint8_t start, uint8_t *buf, int size)
{
  DEBUGASSERT(priv != NULL);
  DEBUGASSERT(buf != NULL);
  struct i2c_msg_s msg[2];
  int ret;

  msg[0].frequency = priv-&gt;freq;
  msg[0].addr      = priv-&gt;addr;

#ifdef CONFIG_BL602_I2C0
  //  For BL602: Register ID must be passed as I2C Sub Address
  msg[0].flags     = I2C_M_NOSTOP;
#else
  //  Otherwise pass Register ID as I2C Data
  msg[0].flags     = 0;
#endif  //  CONFIG_BL602_I2C0

  msg[0].buffer    = &amp;start;
  msg[0].length    = 1;

  msg[1].frequency = priv-&gt;freq;
  msg[1].addr      = priv-&gt;addr;
  msg[1].flags     = I2C_M_READ;
  msg[1].buffer    = buf;
  msg[1].length    = size;

  ret = I2C_TRANSFER(priv-&gt;i2c, msg, 2);</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L155-L183">(Source)</a></p>
<p>How do we call <strong>I2C_TRANSFER</strong> from a NuttX App? Thanks to the I2C Demo App we have the answer‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>int i2ctool_get(FAR struct i2ctool_s *i2ctool, int fd, uint8_t regaddr,
                FAR uint16_t *result)
{
  struct i2c_msg_s msg[2];
  ...
  int ret = i2cdev_transfer(fd, msg, 2);</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rusti2c/system/i2c/i2c_get.c#L158-L206">(Source)</a></p>
<p><strong>i2cdev_transfer</strong> is defined as‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>int i2cdev_transfer(int fd, FAR struct i2c_msg_s *msgv, int msgc)
{
  struct i2c_transfer_s xfer;

  /* Set up the IOCTL argument */

  xfer.msgv = msgv;
  xfer.msgc = msgc;

  /* Perform the IOCTL */

  return ioctl(fd, I2CIOC_TRANSFER, (unsigned long)((uintptr_t)&amp;xfer));
}</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rusti2c/system/i2c/i2c_devif.c#L117-L129">(Source)</a></p>
<p>Let‚Äôs port this to Rust.</p>
<h1 id="c-types-and-constants" class="section-header"><a href="#c-types-and-constants">7 C Types and Constants</a></h1>
<p>TODO</p>
<p>Earlier we‚Äôve seen <strong>i2c_msg_s</strong> and <strong>i2c_transfer_s</strong>. They are defined as‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>struct i2c_msg_s
{
  uint32_t frequency;         /* I2C frequency */
  uint16_t addr;              /* Slave address (7- or 10-bit) */
  uint16_t flags;             /* See I2C_M_* definitions */
  FAR uint8_t *buffer;        /* Buffer to be transferred */
  ssize_t length;             /* Length of the buffer in bytes */
};</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/rusti2c/include/nuttx/i2c/i2c_master.h#L208-L215">(Source)</a></p>
<div class="example-wrap"><pre class="language-c"><code>struct i2c_transfer_s
{
  FAR struct i2c_msg_s *msgv; /* Array of I2C messages for the transfer */
  size_t msgc;                /* Number of messages in the array. */
};</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/rusti2c/include/nuttx/i2c/i2c_master.h#L231-L235">(Source)</a></p>
<p><strong>I2CIOC_TRANSFER</strong> is defined as‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define I2CIOC_TRANSFER      _I2CIOC(0x0001)</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/rusti2c/include/nuttx/i2c/i2c_master.h#L105-L129">(Source)</a></p>
<p>_<strong>I2CIOC</strong> is defined as‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define _I2CIOC(nr)       _IOC(_I2CBASE,nr)</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/rusti2c/include/nuttx/fs/ioctl.h#L467-L468">(Source)</a></p>
<p>_<strong>IOC</strong> and _<strong>I2CBASE</strong> are defined as‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define _IOC(type,nr)   ((type)|(nr))</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/rusti2c/include/nuttx/fs/ioctl.h#L107">(Source)</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define _I2CBASE        (0x2100) /* I2C driver commands */</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/rusti2c/include/nuttx/fs/ioctl.h#L73">(Source)</a></p>
<p>We‚Äôll port these C Types and Constants to Rust as well.</p>
<h1 id="read-i2c-register-in-rust" class="section-header"><a href="#read-i2c-register-in-rust">8 Read I2C Register in Rust</a></h1>
<p>TODO</p>
<p>Here‚Äôs how we read an I2C Register in Rust, ported from the above C code‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Test the I2C Port by reading an I2C Register</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">test_i2c</span>() {
    <span class="macro">println!</span>(<span class="string">&quot;test_i2c&quot;</span>);

    <span class="comment">//  Open I2C Port</span>
    <span class="kw">let</span> <span class="ident">i2c</span> <span class="op">=</span> <span class="kw">unsafe</span> { 
        <span class="ident">open</span>(<span class="string">b&quot;/dev/i2c0\0&quot;</span>.<span class="ident">as_ptr</span>(), <span class="ident">O_RDWR</span>) 
    };
    <span class="macro">assert!</span>(<span class="ident">i2c</span> <span class="op">&gt;</span> <span class="number">0</span>);

    <span class="comment">//  Read one I2C Register, starting at Device ID</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">start</span> <span class="op">=</span> [<span class="ident">BME280_REG_ID</span> ; <span class="number">1</span>];
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span>   <span class="op">=</span> [<span class="number">0u8</span> ; <span class="number">1</span>];

    <span class="comment">//  Compose I2C Transfer</span>
    <span class="kw">let</span> <span class="ident">msg</span>: [<span class="ident">i2c_msg_s</span> ; <span class="number">2</span>] <span class="op">=</span> [
        <span class="comment">//  First I2C Message: Send Register ID</span>
        <span class="ident">i2c_msg_s</span> {
            <span class="ident">frequency</span>: <span class="ident">BME280_FREQ</span>,   <span class="comment">//  I2C Frequency</span>
            <span class="ident">addr</span>:      <span class="ident">BME280_ADDR</span>,   <span class="comment">//  I2C Address</span>
            <span class="ident">buffer</span>:    <span class="ident">start</span>.<span class="ident">as_mut_ptr</span>(),      <span class="comment">//  Buffer to be sent</span>
            <span class="ident">length</span>:    <span class="ident">start</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">ssize_t</span>,  <span class="comment">//  Length of the buffer in bytes</span>

            <span class="comment">//  For BL602: Register ID must be passed as I2C Sub Address</span>
            <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;riscv32&quot;</span>)]</span>  <span class="comment">//  If architecture is RISC-V 32-bit...</span>
            <span class="ident">flags</span>:     <span class="ident">I2C_M_NOSTOP</span>,  <span class="comment">//  I2C Flags: Send I2C Sub Address</span>
            
            <span class="comment">//  Otherwise pass Register ID as I2C Data</span>
            <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;riscv32&quot;</span>))]</span>  <span class="comment">//  If architecture is not RISC-V 32-bit...</span>
            <span class="ident">flags</span>:     <span class="number">0</span>,  <span class="comment">//  I2C Flags: None</span>

            <span class="comment">//  TODO: Check for BL602 specifically, not just RISC-V 32-bit</span>
        },
        <span class="comment">//  Second I2C Message: Receive Register Value</span>
        <span class="ident">i2c_msg_s</span> {
            <span class="ident">frequency</span>: <span class="ident">BME280_FREQ</span>,  <span class="comment">//  I2C Frequency</span>
            <span class="ident">addr</span>:      <span class="ident">BME280_ADDR</span>,  <span class="comment">//  I2C Address</span>
            <span class="ident">buffer</span>:    <span class="ident">buf</span>.<span class="ident">as_mut_ptr</span>(),      <span class="comment">//  Buffer to be received</span>
            <span class="ident">length</span>:    <span class="ident">buf</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">ssize_t</span>,  <span class="comment">//  Length of the buffer in bytes</span>
            <span class="ident">flags</span>:     <span class="ident">I2C_M_READ</span>,   <span class="comment">//  I2C Flags: Read from I2C Device</span>
        },
    ];

    <span class="comment">//  Compose ioctl Argument</span>
    <span class="kw">let</span> <span class="ident">xfer</span> <span class="op">=</span> <span class="ident">i2c_transfer_s</span> {
        <span class="ident">msgv</span>: <span class="ident">msg</span>.<span class="ident">as_ptr</span>(),         <span class="comment">//  Array of I2C messages for the transfer</span>
        <span class="ident">msgc</span>: <span class="ident">msg</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">size_t</span>,  <span class="comment">//  Number of messages in the array</span>
    };

    <span class="comment">//  Execute I2C Transfer</span>
    <span class="kw">let</span> <span class="ident">ret</span> <span class="op">=</span> <span class="kw">unsafe</span> { 
        <span class="ident">ioctl</span>(
            <span class="ident">i2c</span>,
            <span class="ident">I2CIOC_TRANSFER</span>,
            <span class="kw-2">&amp;</span><span class="ident">xfer</span>
        )
    };
    <span class="macro">assert!</span>(<span class="ident">ret</span> <span class="op">&gt;</span><span class="op">=</span> <span class="number">0</span>);

    <span class="comment">//  Show the received Register Value</span>
    <span class="macro">println!</span>(
        <span class="string">&quot;test_i2c: Register 0x{:02x} is 0x{:02x}&quot;</span>,
        <span class="ident">BME280_REG_ID</span>,  <span class="comment">//  Register ID (0xD0)</span>
        <span class="ident">buf</span>[<span class="number">0</span>]          <span class="comment">//  Register Value (0x60)</span>
    );

    <span class="comment">//  Register Value must be BME280 Device ID (0x60)</span>
    <span class="macro">assert!</span>(<span class="ident">buf</span>[<span class="number">0</span>] <span class="op">==</span> <span class="ident">BME280_CHIP_ID</span>);
     
    <span class="comment">//  Close the I2C Port</span>
    <span class="kw">unsafe</span> { <span class="ident">close</span>(<span class="ident">i2c</span>); }

    <span class="comment">//  Sleep 5 seconds</span>
    <span class="kw">unsafe</span> { <span class="ident">sleep</span>(<span class="number">5</span>); }
}</code></pre></div>
<p><a href="rust/src/test.rs">(Source)</a></p>
<p>The NuttX Types are ported from C to Rust like so‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// I2C Message Struct: I2C transaction segment beginning with a START. A number of these can</span>
<span class="doccomment">/// be transferred together to form an arbitrary sequence of write/read</span>
<span class="doccomment">/// transfer to an I2C device.</span>
<span class="doccomment">/// TODO: Import with bindgen from https://github.com/lupyuen/incubator-nuttx/blob/rusti2c/include/nuttx/i2c/i2c_master.h#L208-L215</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">C</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">i2c_msg_s</span> {
    <span class="doccomment">/// I2C Frequency</span>
    <span class="kw">pub</span> <span class="ident">frequency</span>: <span class="ident">u32</span>,
    <span class="doccomment">/// I2C Address</span>
    <span class="kw">pub</span> <span class="ident">addr</span>: <span class="ident">u16</span>,
    <span class="doccomment">/// I2C Flags (I2C_M_*)</span>
    <span class="kw">pub</span> <span class="ident">flags</span>: <span class="ident">u16</span>,
    <span class="doccomment">/// Buffer to be transferred</span>
    <span class="kw">pub</span> <span class="ident">buffer</span>: <span class="kw-2">*mut</span> <span class="ident">u8</span>,
    <span class="doccomment">/// Length of the buffer in bytes</span>
    <span class="kw">pub</span> <span class="ident">length</span>: <span class="ident">ssize_t</span>,
}

<span class="doccomment">/// I2C Transfer Struct: This structure is used to communicate with the I2C character driver in</span>
<span class="doccomment">/// order to perform IOCTL transfers.</span>
<span class="doccomment">/// TODO: Import with bindgen from https://github.com/lupyuen/incubator-nuttx/blob/rusti2c/include/nuttx/i2c/i2c_master.h#L231-L235</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">C</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">i2c_transfer_s</span> {
    <span class="doccomment">/// Array of I2C messages for the transfer</span>
    <span class="kw">pub</span> <span class="ident">msgv</span>: <span class="kw-2">*const</span> <span class="ident">i2c_msg_s</span>,
    <span class="doccomment">/// Number of messages in the array</span>
    <span class="kw">pub</span> <span class="ident">msgc</span>: <span class="ident">size_t</span>,
}</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-embedded-hal/blob/main/src/lib.rs#L125-L153">(Source)</a></p>
<h1 id="test-i2c-port" class="section-header"><a href="#test-i2c-port">9 Test I2C Port</a></h1>
<p>TODO</p>
<p>To build the NuttX + Rust project‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cd nuttx/apps/examples/rust_i2c
./run.sh</code></pre></div>
<p>In NuttX Shell, enter this to run our Rust app‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>rust_i2c</code></pre></div>
<p>Our Rust app reads BME280 Register 0xD0 (Device ID), which should contain 0x60‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt; rust_i2c
Hello from Rust!
test_i2c
i2cdrvr_ioctl: cmd=2101 arg=4201c378
bl602_i2c_transfer: subflag=1, subaddr=0xd0, sublen=1
bl602_i2c_recvdata: count=1, temp=0x60
bl602_i2c_transfer: i2c transfer success
test_i2c: Register 0xd0 is 0x60
Done!
nsh&gt;</code></pre></div>
<p>Yep our Rust app reads the BME280 I2C Register correctly!</p>
<h1 id="rust-embedded-hal" class="section-header"><a href="#rust-embedded-hal">10 Rust Embedded HAL</a></h1>
<p>TODO</p>
<p>Rust Embedded HAL defines a standard API for I2C Operations. Let‚Äôs wrap the NuttX I2C ioctl() Commands and expose as Rust Embedded HAL interfaces‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// NuttX Implementation of I2C Read</span>
<span class="kw">impl</span> <span class="ident">i2c::Read</span> <span class="kw">for</span> <span class="ident">I2c</span> {
    ...
    <span class="doccomment">/// TODO: Read I2C data</span>
    <span class="kw">fn</span> <span class="ident">read</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">addr</span>: <span class="ident">u8</span>, <span class="ident">buf</span>: <span class="kw-2">&amp;mut</span> [<span class="ident">u8</span>]) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident"><span class="self">Self</span>::Error</span><span class="op">&gt;</span> { ... }
}

<span class="doccomment">/// NuttX Implementation of I2C Write</span>
<span class="kw">impl</span> <span class="ident">i2c::Write</span> <span class="kw">for</span> <span class="ident">I2c</span> {
    ...
    <span class="doccomment">/// TODO: Write I2C data</span>
    <span class="kw">fn</span> <span class="ident">write</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">addr</span>: <span class="ident">u8</span>, <span class="ident">buf</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident"><span class="self">Self</span>::Error</span><span class="op">&gt;</span> { ... }
}

<span class="doccomment">/// NuttX Implementation of I2C WriteRead</span>
<span class="kw">impl</span> <span class="ident">i2c::WriteRead</span> <span class="kw">for</span> <span class="ident">I2c</span> {
    ...
    <span class="doccomment">/// TODO: Write and read I2C data</span>
    <span class="kw">fn</span> <span class="ident">write_read</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">addr</span>: <span class="ident">u8</span>, <span class="ident">wbuf</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">rbuf</span>: <span class="kw-2">&amp;mut</span> [<span class="ident">u8</span>]) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident"><span class="self">Self</span>::Error</span><span class="op">&gt;</span> { ... }
}</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-embedded-hal/blob/main/src/hal.rs#L20-L160">(Source)</a></p>
<h1 id="read-i2c-register" class="section-header"><a href="#read-i2c-register">11 Read I2C Register</a></h1>
<p>TODO</p>
<p>Here‚Äôs how we implement the Rust Embedded HAL to read an I2C Register‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// NuttX Implementation of I2C WriteRead</span>
<span class="kw">impl</span> <span class="ident">i2c::WriteRead</span> <span class="kw">for</span> <span class="ident">I2c</span> {
    <span class="doccomment">/// Error Type</span>
    <span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="ident">i32</span>;

    <span class="doccomment">/// Write `wbuf` to I2C Port and read `rbuf` from I2C Port.</span>
    <span class="doccomment">/// We assume this is a Read I2C Register operation, with Register ID at `wbuf[0]`.</span>
    <span class="doccomment">/// TODO: Handle other kinds of I2C operations</span>
    <span class="kw">fn</span> <span class="ident">write_read</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">addr</span>: <span class="ident">u8</span>, <span class="ident">wbuf</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">rbuf</span>: <span class="kw-2">&amp;mut</span> [<span class="ident">u8</span>]) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident"><span class="self">Self</span>::Error</span><span class="op">&gt;</span> {
        <span class="comment">//  We assume this is a Read I2C Register operation, with Register ID at wbuf[0]</span>
        <span class="macro">assert_eq!</span>(<span class="ident">wbuf</span>.<span class="ident">len</span>(), <span class="number">1</span>);
        <span class="kw">let</span> <span class="ident">reg_id</span> <span class="op">=</span> <span class="ident">wbuf</span>[<span class="number">0</span>];

        <span class="comment">//  Read I2C Registers, starting at Register ID</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">start</span> <span class="op">=</span> [<span class="ident">reg_id</span> ; <span class="number">1</span>];

        <span class="comment">//  Compose I2C Transfer</span>
        <span class="kw">let</span> <span class="ident">msg</span> <span class="op">=</span> [
            <span class="comment">//  First I2C Message: Send Register ID</span>
            <span class="ident">i2c_msg_s</span> {
                <span class="ident">frequency</span>: <span class="self">self</span>.<span class="ident">frequency</span>,  <span class="comment">//  I2C Frequency</span>
                <span class="ident">addr</span>:      <span class="ident">addr</span> <span class="kw">as</span> <span class="ident">u16</span>,     <span class="comment">//  I2C Address</span>
                <span class="ident">buffer</span>:    <span class="ident">start</span>.<span class="ident">as_mut_ptr</span>(),      <span class="comment">//  Buffer to be sent</span>
                <span class="ident">length</span>:    <span class="ident">start</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">ssize_t</span>,  <span class="comment">//  Number of bytes to send</span>

                <span class="comment">//  For BL602: Register ID must be passed as I2C Sub Address</span>
                <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;riscv32&quot;</span>)]</span>  <span class="comment">//  If architecture is RISC-V 32-bit...</span>
                <span class="ident">flags</span>:     <span class="ident"><span class="kw">crate</span>::I2C_M_NOSTOP</span>,  <span class="comment">//  I2C Flags: Send I2C Sub Address</span>
                
                <span class="comment">//  Otherwise pass Register ID as I2C Data</span>
                <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;riscv32&quot;</span>))]</span>  <span class="comment">//  If architecture is not RISC-V 32-bit...</span>
                <span class="ident">flags</span>:     <span class="number">0</span>,  <span class="comment">//  I2C Flags: None</span>

                <span class="comment">//  TODO: Check for BL602 specifically (by target_abi?), not just RISC-V 32-bit</span>
            },
            <span class="comment">//  Second I2C Message: Receive Register Values</span>
            <span class="ident">i2c_msg_s</span> {
                <span class="ident">frequency</span>: <span class="self">self</span>.<span class="ident">frequency</span>,  <span class="comment">//  I2C Frequency</span>
                <span class="ident">addr</span>:      <span class="ident">addr</span> <span class="kw">as</span> <span class="ident">u16</span>,     <span class="comment">//  I2C Address</span>
                <span class="ident">buffer</span>:    <span class="ident">rbuf</span>.<span class="ident">as_mut_ptr</span>(),      <span class="comment">//  Buffer to be received</span>
                <span class="ident">length</span>:    <span class="ident">rbuf</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">ssize_t</span>,  <span class="comment">//  Number of bytes to receive</span>
                <span class="ident">flags</span>:     <span class="ident">I2C_M_READ</span>,  <span class="comment">//  I2C Flags: Read I2C Data</span>
            },
        ];

        <span class="comment">//  Compose ioctl Argument</span>
        <span class="kw">let</span> <span class="ident">xfer</span> <span class="op">=</span> <span class="ident">i2c_transfer_s</span> {
            <span class="ident">msgv</span>: <span class="ident">msg</span>.<span class="ident">as_ptr</span>(),         <span class="comment">//  Array of I2C messages for the transfer</span>
            <span class="ident">msgc</span>: <span class="ident">msg</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">size_t</span>,  <span class="comment">//  Number of messages in the array</span>
        };

        <span class="comment">//  Execute I2C Transfer</span>
        <span class="kw">let</span> <span class="ident">ret</span> <span class="op">=</span> <span class="kw">unsafe</span> { 
            <span class="ident">ioctl</span>(
                <span class="self">self</span>.<span class="ident">fd</span>,
                <span class="ident">I2CIOC_TRANSFER</span>,
                <span class="kw-2">&amp;</span><span class="ident">xfer</span>
            )
        };
        <span class="macro">assert!</span>(<span class="ident">ret</span> <span class="op">&gt;</span><span class="op">=</span> <span class="number">0</span>);   
        <span class="prelude-val">Ok</span>(())
    }
}</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-embedded-hal/blob/main/src/hal.rs#L98-L160">(Source)</a></p>
<p>To read an I2C Register, we call the Rust Embedded HAL like so‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Test the I2C HAL by reading an I2C Register</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">test_hal_read</span>() {

    <span class="comment">//  Open I2C Port</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">i2c</span> <span class="op">=</span> <span class="ident">nuttx_embedded_hal::I2c::new</span>(
        <span class="string">&quot;/dev/i2c0&quot;</span>,  <span class="comment">//  I2C Port</span>
        <span class="ident">BME280_FREQ</span>,  <span class="comment">//  I2C Frequency</span>
    ).<span class="ident">expect</span>(<span class="string">&quot;open failed&quot;</span>);

    <span class="comment">//  Buffer for received I2C data</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> [<span class="number">0</span> ; <span class="number">1</span>];

    <span class="comment">//  Read one I2C Register, starting at Device ID</span>
    <span class="ident">i2c</span>.<span class="ident">write_read</span>(
        <span class="ident">BME280_ADDR</span> <span class="kw">as</span> <span class="ident">u8</span>,  <span class="comment">//  I2C Address</span>
        <span class="kw-2">&amp;</span>[<span class="ident">BME280_REG_ID</span>],   <span class="comment">//  Register ID (0x60)</span>
        <span class="kw-2">&amp;mut</span> <span class="ident">buf</span>            <span class="comment">//  Buffer to be received</span>
    ).<span class="ident">expect</span>(<span class="string">&quot;read register failed&quot;</span>);

    <span class="comment">//  Show the received Register Value</span>
    <span class="macro">println!</span>(
        <span class="string">&quot;test_hal_read: Register 0x{:02x} is 0x{:02x}&quot;</span>,
        <span class="ident">BME280_REG_ID</span>,  <span class="comment">//  Register ID (0xD0)</span>
        <span class="ident">buf</span>[<span class="number">0</span>]          <span class="comment">//  Register Value (0x60)</span>
    );

    <span class="comment">//  Register Value must be BME280 Device ID (0x60)</span>
    <span class="macro">assert_eq!</span>(<span class="ident">buf</span>[<span class="number">0</span>], <span class="ident">BME280_CHIP_ID</span>);
}</code></pre></div>
<p><a href="rust/src/test.rs">(Source)</a></p>
<h1 id="test-i2c-hal" class="section-header"><a href="#test-i2c-hal">12 Test I2C HAL</a></h1>
<p>TODO</p>
<p>Rust Embedded HAL works OK for reading an I2C Register!</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell NSH NuttX-10.2.0-RC0
nsh&gt; rust_i2c
Hello from Rust!
...
test_hal_read
i2cdrvr_ioctl: cmd=2101 arg=4201c360
bl602_i2c_transfer: subflag=1, subaddr=0xd0, sublen=1
bl602_i2c_recvdata: count=1, temp=0x60
bl602_i2c_transfer: i2c transfer success
test_hal_read: Register 0xd0 is 0x60
Done!
nsh&gt;</code></pre></div><h1 id="write-i2c-register" class="section-header"><a href="#write-i2c-register">13 Write I2C Register</a></h1>
<p>TODO</p>
<p>This code calls the Rust Embedded HAL to write the value 0xA0 to the I2C Register 0xF5‚Ä¶.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Test the I2C HAL by writing an I2C Register</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">test_hal_write</span>() {

    <span class="comment">//  Open I2C Port</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">i2c</span> <span class="op">=</span> <span class="ident">nuttx_embedded_hal::I2c::new</span>(
        <span class="string">&quot;/dev/i2c0&quot;</span>,  <span class="comment">//  I2C Port</span>
        <span class="ident">BME280_FREQ</span>,  <span class="comment">//  I2C Frequency</span>
    ).<span class="ident">expect</span>(<span class="string">&quot;open failed&quot;</span>);

    <span class="comment">//  Write 0xA0 to register 0xF5</span>
    <span class="ident">i2c</span>.<span class="ident">write</span>(
        <span class="ident">BME280_ADDR</span> <span class="kw">as</span> <span class="ident">u8</span>,          <span class="comment">//  I2C Address</span>
        <span class="kw-2">&amp;</span>[<span class="ident">BME280_REG_CONFIG</span>, <span class="number">0xA0</span>]  <span class="comment">//  Register ID and value</span>
    ).<span class="ident">expect</span>(<span class="string">&quot;write register failed&quot;</span>);</code></pre></div>
<p><a href="rust/src/test.rs">(Source)</a></p>
<p>But the Logic Analyser shows that BL602 is writing to I2C the value 0x00 instead of 0xA0‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Setup Write to [0xEE] + ACK
0xF5 + ACK
0x00 + ACK</code></pre></div>
<p><img src="https://lupyuen.github.io/images/rusti2c-logic1.png" alt="BL602 is writing to I2C the value 0x00 instead of 0xA0" /></p>
<p>Let‚Äôs fix this. Here‚Äôs the log for the I2C write‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; rust_i2c
Hello from Rust!
test_hal_write
i2cdrvr_ioctl: cmd=2101 arg=4201c370
bl602_i2c_transfer: subflag=1, subaddr=0xf5, sublen=1
bl602_i2c_send_data: count=1, temp=0xa0
bl602_i2c_transfer: i2c transfer success
test_hal_write: Write 0xA0 to register</code></pre></div><h1 id="fix-i2c-write" class="section-header"><a href="#fix-i2c-write">14 Fix I2C Write</a></h1>
<p>TODO</p>
<p>BL602 has a peculiar I2C Port that uses I2C Sub Addresses ‚Ä¶ Let‚Äôs make it work with Rust Embedded HAL</p>
<p><a href="https://lupyuen.github.io/articles/bme280#appendix-quirks-in-bl602-nuttx-i2c-driver">‚ÄúQuirks in BL602 I2C Driver‚Äù</a></p>
<p>We tried all sequences of I2C Read / Write / Sub Address. Only this strange sequence works for writing to I2C Registers‚Ä¶</p>
<ol>
<li>
<p>Write I2C Register ID and I2C Data together as I2C Sub Address</p>
</li>
<li>
<p>Followed by Read I2C Data</p>
</li>
</ol>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// NuttX Implementation of I2C Write</span>
<span class="kw">impl</span> <span class="ident">i2c::Write</span> <span class="kw">for</span> <span class="ident">I2c</span> {
    <span class="doccomment">/// Error Type</span>
    <span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="ident">i32</span>;

    <span class="doccomment">/// Write `buf` to I2C Port.</span>
    <span class="doccomment">/// We assume this is a Write I2C Register operation, with Register ID at `buf[0]`.</span>
    <span class="doccomment">/// TODO: Handle other kinds of I2C operations</span>
    <span class="kw">fn</span> <span class="ident">write</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">addr</span>: <span class="ident">u8</span>, <span class="ident">buf</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident"><span class="self">Self</span>::Error</span><span class="op">&gt;</span> {
        <span class="comment">//  Copy to local buffer because we need a mutable reference</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf2</span> <span class="op">=</span> [<span class="number">0</span> ; <span class="number">64</span>];
        <span class="macro">assert!</span>(<span class="ident">buf</span>.<span class="ident">len</span>() <span class="op">&lt;</span><span class="op">=</span> <span class="ident">buf2</span>.<span class="ident">len</span>());
        <span class="ident">buf2</span>[..<span class="ident">buf</span>.<span class="ident">len</span>()].<span class="ident">copy_from_slice</span>(<span class="ident">buf</span>);

        <span class="comment">//  Buffer for received I2C data</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">rbuf</span> <span class="op">=</span> [<span class="number">0</span> ; <span class="number">1</span>];

        <span class="comment">//  Compose I2C Transfer</span>
        <span class="kw">let</span> <span class="ident">msg</span> <span class="op">=</span> [
            <span class="comment">//  First I2C Message: Send Register ID and I2C Data as I2C Sub Address</span>
            <span class="ident">i2c_msg_s</span> {
                <span class="ident">frequency</span>: <span class="self">self</span>.<span class="ident">frequency</span>,  <span class="comment">//  I2C Frequency</span>
                <span class="ident">addr</span>:      <span class="ident">addr</span> <span class="kw">as</span> <span class="ident">u16</span>,     <span class="comment">//  I2C Address</span>
                <span class="ident">buffer</span>:    <span class="ident">buf2</span>.<span class="ident">as_mut_ptr</span>(),     <span class="comment">//  Buffer to be sent</span>
                <span class="ident">length</span>:    <span class="ident">buf</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">ssize_t</span>,  <span class="comment">//  Number of bytes to send</span>

                <span class="comment">//  For BL602: Register ID must be passed as I2C Sub Address</span>
                <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;riscv32&quot;</span>)]</span>  <span class="comment">//  If architecture is RISC-V 32-bit...</span>
                <span class="ident">flags</span>:     <span class="ident"><span class="kw">crate</span>::I2C_M_NOSTOP</span>,  <span class="comment">//  I2C Flags: Send I2C Sub Address</span>
                
                <span class="comment">//  Otherwise pass Register ID as I2C Data</span>
                <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;riscv32&quot;</span>))]</span>  <span class="comment">//  If architecture is not RISC-V 32-bit...</span>
                <span class="ident">flags</span>:     <span class="number">0</span>,  <span class="comment">//  I2C Flags: None</span>

                <span class="comment">//  TODO: Check for BL602 specifically (by target_abi?), not just RISC-V 32-bit</span>
            },
            <span class="comment">//  Second I2C Message: Read I2C Data, because this forces BL602 to send the first message correctly</span>
            <span class="ident">i2c_msg_s</span> {
                <span class="ident">frequency</span>: <span class="self">self</span>.<span class="ident">frequency</span>,  <span class="comment">//  I2C Frequency</span>
                <span class="ident">addr</span>:      <span class="ident">addr</span> <span class="kw">as</span> <span class="ident">u16</span>,     <span class="comment">//  I2C Address</span>
                <span class="ident">buffer</span>:    <span class="ident">rbuf</span>.<span class="ident">as_mut_ptr</span>(),      <span class="comment">//  Buffer to be received</span>
                <span class="ident">length</span>:    <span class="ident">rbuf</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">ssize_t</span>,  <span class="comment">//  Number of bytes to receive</span>
                <span class="ident">flags</span>:     <span class="ident">I2C_M_READ</span>,  <span class="comment">//  I2C Flags: Read I2C Data</span>
            },
        ];
        
        <span class="comment">//  Compose ioctl Argument to write I2C Registers</span>
        <span class="kw">let</span> <span class="ident">xfer</span> <span class="op">=</span> <span class="ident">i2c_transfer_s</span> {
            <span class="ident">msgv</span>: <span class="ident">msg</span>.<span class="ident">as_ptr</span>(),         <span class="comment">//  Array of I2C messages for the transfer</span>
            <span class="ident">msgc</span>: <span class="ident">msg</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">size_t</span>,  <span class="comment">//  Number of messages in the array</span>
        };

        <span class="comment">//  Execute I2C Transfer to write I2C Registers</span>
        <span class="kw">let</span> <span class="ident">ret</span> <span class="op">=</span> <span class="kw">unsafe</span> { 
            <span class="ident">ioctl</span>(
                <span class="self">self</span>.<span class="ident">fd</span>,          <span class="comment">//  I2C Port</span>
                <span class="ident">I2CIOC_TRANSFER</span>,  <span class="comment">//  I2C Transfer</span>
                <span class="kw-2">&amp;</span><span class="ident">xfer</span>             <span class="comment">//  I2C Messages for the transfer</span>
            )
        };
        <span class="macro">assert!</span>(<span class="ident">ret</span> <span class="op">&gt;</span><span class="op">=</span> <span class="number">0</span>);   
        <span class="prelude-val">Ok</span>(())
    }
}</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-embedded-hal/blob/main/src/hal.rs#L33-L96">(Source)</a></p>
<p>After fixing, the Logic Analyser shows that BL602 writes correctly to the I2C Register! (With a harmless I2C Read at the end)</p>
<div class="example-wrap"><pre class="language-text"><code>Setup Write to [0xEE] + ACK
0xF5 + ACK
0xA0 + ACK
Setup Read to [0xEF] + ACK
0xA0 + NAK</code></pre></div>
<p><img src="https://lupyuen.github.io/images/rusti2c-logic3a.png" alt="BL602 writes correctly to the I2C Register! With a harmless I2C Read at the end" /></p>
<p>Here‚Äôs the log‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; rust_i2c
Hello from Rust!
test_hal_write
i2cdrvr_ioctl: cmd=2101 arg=4201c358
bl602_i2c_transfer: subflag=1, subaddr=0xa0f5, sublen=2
bl602_i2c_recvdata: count=1, temp=0xa0
bl602_i2c_transfer: i2c transfer success
test_hal_write: Write 0xA0 to register

i2cdrvr_ioctl: cmd=2101 arg=4201c370
bl602_i2c_transfer: subflag=1, subaddr=0xf5, sublen=1
bl602_i2c_recvdata: count=1, temp=0xa0
bl602_i2c_transfer: i2c transfer success
test_hal_write: Register value is 0xa0

i2cdrvr_ioctl: cmd=2101 arg=4201c358
bl602_i2c_transfer: subflag=1, subaddr=0xf5, sublen=2
bl602_i2c_recvdata: count=1, temp=0x0
bl602_i2c_transfer: i2c transfer success
test_hal_write: Write 0x00 to register

i2cdrvr_ioctl: cmd=2101 arg=4201c370
bl602_i2c_transfer: subflag=1, subaddr=0xf5, sublen=1
bl602_i2c_recvdata: count=1, temp=0x0
bl602_i2c_transfer: i2c transfer success
test_hal_write: Register value is 0x00
Done!
nsh&gt;</code></pre></div>
<p><em>What if we write to the I2C Register without reading?</em></p>
<p>The I2C Address is sent incorrectly (<code>0x02</code>) and the I2C Write gets truncated‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Setup Write to [0x02] + NAK</code></pre></div>
<p><img src="https://lupyuen.github.io/images/rusti2c-noread.png" alt="Write to I2C Register without reading" /></p>
<p><em>What if we send the Register ID and Register Value as I2C Data (flags = 0) instead of I2C Sub Address?</em></p>
<p>The Register ID and value are sent incorrectly as <code>0x00 0x00</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Setup Write to [0xEE] + ACK
0x00 + ACK
0x00 + ACK
(...600 microseconds later...)
Setup Read to [0xEF] + ACK
0x00 + NAK</code></pre></div>
<p><img src="https://lupyuen.github.io/images/rusti2c-nosubaddr.png" alt="Send the Register ID and Register Value as I2C Data instead of I2C Sub Address" /></p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">15 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/rusti2c.md"><code>lupyuen.github.io/src/rusti2c.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">16 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1502823263121989634">this Twitter Thread</a></li>
</ol>
<h1 id="appendix-build-flash-and-run-nuttx" class="section-header"><a href="#appendix-build-flash-and-run-nuttx">17 Appendix: Build, Flash and Run NuttX</a></h1>
<p><em>(For BL602, BL604 and ESP32)</em></p>
<p>Below are the steps to build, flash and run NuttX on BL602, BL604 and ESP32.</p>
<p>The instructions below will work on <strong>Linux (Ubuntu)</strong>, <strong>WSL (Ubuntu)</strong> and <strong>macOS</strong>.</p>
<p><a href="https://nuttx.apache.org/docs/latest/quickstart/install.html">(Instructions for other platforms)</a></p>
<p><a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(See this for Arch Linux)</a></p>
<h2 id="download-nuttx" class="section-header"><a href="#download-nuttx">17.1 Download NuttX</a></h2>
<p>Download the modified source code for <strong>NuttX OS and NuttX Apps</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>mkdir nuttx
cd nuttx
git clone --recursive --branch rusti2c https://github.com/lupyuen/incubator-nuttx nuttx
git clone --recursive --branch rusti2c https://github.com/lupyuen/incubator-nuttx-apps apps</code></pre></div>
<p>Or if we prefer to <strong>add the Rust Library and App</strong> to our NuttX Project, follow these instructions‚Ä¶</p>
<ol>
<li>
<p><a href="https://github.com/lupyuen/rust-nuttx"><strong>‚ÄúInstall Rust Library‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/rust-i2c-nuttx"><strong>‚ÄúInstall Rust I2C App‚Äù</strong></a></p>
</li>
</ol>
<h2 id="configure-nuttx" class="section-header"><a href="#configure-nuttx">17.2 Configure NuttX</a></h2>
<p>Now we configure our NuttX project‚Ä¶</p>
<ol>
<li>
<p>Install the build prerequisites‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Install Rust from <a href="https://rustup.rs"><strong>rustup.rs</strong></a></p>
</li>
<li>
<p>Configure the build‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cd nuttx

# For BL602 / BL604: Configure the build for BL602 / BL604
./tools/configure.sh bl602evb:nsh

# For ESP32: Configure the build for ESP32.
# TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

# Edit the Build Config
make menuconfig </code></pre></div></li>
<li>
<p>Enable our <strong>Rust Library</strong>‚Ä¶</p>
<p>Check the box for <strong>‚ÄúLibrary Routines‚Äù</strong> ‚Üí <strong>‚ÄúRust Library‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
</li>
<li>
<p>Enable our <strong>Rust I2C App</strong>‚Ä¶</p>
<p>Check the box for <strong>‚ÄúApplication Configuration‚Äù</strong> ‚Üí <strong>‚ÄúExamples‚Äù</strong> ‚Üí <strong>‚ÄúRust I2C App‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
</li>
<li>
<p>Enable <strong>I2C0 Port</strong>‚Ä¶</p>
<p><strong>For BL602 / BL604:</strong> Check the box for <strong>‚ÄúSystem Type‚Äù</strong> ‚Üí <strong>‚ÄúBL602 Peripheral Support‚Äù</strong> ‚Üí <strong>‚ÄúI2C0‚Äù</strong></p>
<p><strong>For ESP32:</strong> Check the box for <strong>‚ÄúSystem Type‚Äù</strong> ‚Üí <strong>‚ÄúESP32 Peripheral Select‚Äù</strong> ‚Üí <strong>‚ÄúI2C 0‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
<p><img src="https://lupyuen.github.io/images/bme280-config1.jpg" alt="Enable the I2C Port and I2C Character Driver" /></p>
</li>
<li>
<p>Enable <strong>I2C Character Driver</strong>‚Ä¶</p>
<p>Check the box for <strong>‚ÄúDevice Drivers‚Äù</strong> ‚Üí <strong>‚ÄúI2C Driver Support‚Äù</strong> ‚Üí <strong>‚ÄúI2C Character Driver‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
</li>
<li>
<p>Enable <strong>ls</strong> command‚Ä¶</p>
<p>Select <strong>‚ÄúApplication Configuration‚Äù</strong> ‚Üí <strong>‚ÄúNSH Library‚Äù</strong> ‚Üí <strong>‚ÄúDisable Individual commands‚Äù</strong></p>
<p>Uncheck <strong>‚ÄúDisable ls‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
</li>
<li>
<p>Enable <strong>Logging and Assertion Checks</strong>‚Ä¶</p>
<p>Select <strong>‚ÄúBuild Setup‚Äù</strong> ‚Üí <strong>‚ÄúDebug Options‚Äù</strong></p>
<p>Check the boxes for the following‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Enable Debug Features
Enable Error Output
Enable Warnings Output
Enable Informational Debug Output
Enable Debug Assertions
I2C Debug Features
I2C Error Output
I2C Warnings Output
I2C Informational Output  </code></pre></div>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
</li>
<li>
<p>Save the configuration and exit menuconfig</p>
<p><a href="https://gist.github.com/lupyuen/85550f16517202b7978e592da976c4e7">(See the .config for BL602)</a></p>
</li>
</ol>
<h2 id="configure-rust-target" class="section-header"><a href="#configure-rust-target">17.3 Configure Rust Target</a></h2>
<p><strong>For BL602 / BL604</strong>: Skip to the next section</p>
<p><strong>For ESP32-C3 (RISC-V)</strong>: </p>
<ol>
<li>
<p>Run this command to install the Rust Target‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>rustup target add riscv32imc-unknown-none-elf</code></pre></div></li>
<li>
<p>Edit <a href="https://github.com/lupyuen/rust-i2c-nuttx/blob/main/run.sh"><strong>apps/examples/rust_i2c/run.sh</strong></a></p>
</li>
<li>
<p>Set ‚Äúrust_build_target‚Äù and ‚Äúrust_build_target_folder‚Äù to‚Ä¶</p>
<p><strong>riscv32imc-unknown-none-elf</strong></p>
</li>
<li>
<p>Remove ‚Äú-Z build-std=core‚Äù from ‚Äúrust_build_options‚Äù</p>
</li>
</ol>
<p><strong>For ESP32 (Xtensa)</strong>: </p>
<ol>
<li>
<p>Install the Rust compiler fork with Xtensa support. <a href="https://github.com/jessebraham/esp-hal/tree/main/esp32-hal">(See this)</a></p>
</li>
<li>
<p>Edit <a href="https://github.com/lupyuen/rust-i2c-nuttx/blob/main/run.sh"><strong>apps/examples/rust_i2c/run.sh</strong></a></p>
</li>
<li>
<p>Set ‚Äúrust_build_target‚Äù and ‚Äúrust_build_target_folder‚Äù to‚Ä¶</p>
<p><strong>xtensa-esp32-none-elf</strong></p>
</li>
<li>
<p>Remove ‚Äú-Z build-std=core‚Äù from ‚Äúrust_build_options‚Äù</p>
</li>
</ol>
<p><a href="https://lupyuen.github.io/articles/rust2#rust-target">(More about Rust Targets)</a></p>
<h2 id="build-nuttx" class="section-header"><a href="#build-nuttx">17.4 Build NuttX</a></h2>
<p>Follow these steps to build NuttX for BL602, BL604 or ESP32‚Ä¶</p>
<ol>
<li>
<p>To build NuttX with Rust, enter this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>pushd apps/examples/rust_i2c
./run.sh
popd</code></pre></div></li>
<li>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>LD: nuttx
CP: nuttx.hex
CP: nuttx.bin</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9bfd71f7029bb66e327f89c8a58f450d">(See the complete log for BL602 / BL604)</a></p>
</li>
<li>
<p>Ignore the errors at the <strong>‚ÄúFlash NuttX‚Äù</strong> and <strong>‚ÄúRun NuttX‚Äù</strong> steps</p>
</li>
<li>
<p><strong>For WSL:</strong> Copy the <strong>NuttX Firmware</strong> to the <strong>c:\blflash</strong> directory in the Windows File System‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  /mnt/c/blflash refers to c:\blflash in Windows
mkdir /mnt/c/blflash
cp nuttx.bin /mnt/c/blflash</code></pre></div>
<p>For WSL we need to run <strong>blflash</strong> under plain old Windows CMD (not WSL) because it needs to access the COM port.</p>
</li>
<li>
<p>In case of problems, refer to the <strong>NuttX Docs</strong>‚Ä¶</p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/risc-v/bl602/index.html"><strong>‚ÄúBL602 NuttX‚Äù</strong></a></p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html"><strong>‚ÄúESP32 NuttX‚Äù</strong></a></p>
<p><a href="https://nuttx.apache.org/docs/latest/quickstart/install.html"><strong>‚ÄúInstalling NuttX‚Äù</strong></a></p>
</li>
</ol>
<blockquote>
<p><img src="https://lupyuen.github.io/images/nuttx-build2.png" alt="Building NuttX" /></p>
</blockquote>
<h2 id="flash-nuttx" class="section-header"><a href="#flash-nuttx">17.5 Flash NuttX</a></h2>
<p><strong>For ESP32:</strong> <a href="https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html#flashing"><strong>See instructions here</strong></a> <a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(Also check out this article)</a></p>
<p><strong>For BL602 / BL604:</strong> Follow these steps to install <strong>blflash</strong>‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>‚ÄúInstall rustup‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>‚ÄúDownload and build blflash‚Äù</strong></a></p>
</li>
</ol>
<p>We assume that our Firmware Binary File <strong>nuttx.bin</strong> has been copied to the <strong>blflash</strong> folder.</p>
<p>Set BL602 / BL604 to <strong>Flashing Mode</strong> and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>High</strong> <a href="https://lupyuen.github.io/images/pinedio-high.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ol>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>Enter these commands to flash <strong>nuttx.bin</strong> to BL602 / BL604 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># For Linux: Change &quot;/dev/ttyUSB0&quot; to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/ttyUSB0 

# For macOS: Change &quot;/dev/tty.usbserial-1410&quot; to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/tty.usbserial-1410 \
  --initial-baud-rate 230400 \
  --baud-rate 230400

# For Windows: Change &quot;COM5&quot; to the BL602 / BL604 Serial Port
blflash flash c:\blflash\nuttx.bin --port COM5</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9c0dbd75bb6b8e810939a36ffb5c399f">(See the Output Log)</a></p>
<p>For WSL: Do this under plain old Windows CMD (not WSL) because <strong>blflash</strong> needs to access the COM port.</p>
<p><a href="https://github.com/apache/incubator-nuttx/issues/4336">(Flashing WiFi apps to BL602 / BL604? Remember to use <strong>bl_rfbin</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">(More details on flashing firmware)</a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-flash2.png" alt="Flashing NuttX" /></p>
<h2 id="run-nuttx" class="section-header"><a href="#run-nuttx">17.6 Run NuttX</a></h2>
<p><strong>For ESP32:</strong> Use Picocom to connect to ESP32 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>picocom -b 115200 /dev/ttyUSB0</code></pre></div>
<p><a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(More about this)</a></p>
<p><strong>For BL602 / BL604:</strong> Set BL602 / BL604 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>Low</strong> <a href="https://lupyuen.github.io/images/pinedio-low.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ol>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>After restarting, connect to BL602 / BL604‚Äôs UART Port at 2 Mbps like so‚Ä¶</p>
<p><strong>For Linux:</strong></p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 2000000</code></pre></div>
<p><strong>For macOS:</strong> Use CoolTerm (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>For Windows:</strong> Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>Alternatively:</strong> Use the Web Serial Terminal (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p>Press Enter to reveal the <strong>NuttX Shell</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt;</code></pre></div>
<p>Congratulations NuttX is now running on BL602 / BL604!</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">(More details on connecting to BL602 / BL604)</a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-boot2.png" alt="Running NuttX" /></p>
<p>TODO1</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-code1.png" alt="" /></p>
<p>TODO2</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-code2a.png" alt="" /></p>
<p>TODO3</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-code3a.png" alt="" /></p>
<p>TODO4</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-code4a.png" alt="" /></p>
<p>TODO5</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-code5a.png" alt="" /></p>
<p>TODO6</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-code6a.png" alt="" /></p>
<p>TODO7</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-code7a.png" alt="" /></p>
<p>TODO8</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-code8a.png" alt="" /></p>
<p>TODO9</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-code9a.png" alt="" /></p>
<p>TODO11</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-hal.png" alt="" /></p>
<p>TODO13</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-logic1.png" alt="" /></p>
<p>TODO14</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-logic2a.png" alt="" /></p>
<p>TODO15</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-logic3a.png" alt="" /></p>
<p>TODO16</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-lottery1.png" alt="" /></p>
<p>TODO17</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-run1.png" alt="" /></p>
<p>TODO19</p>
<p><img src="https://lupyuen.github.io/images/rusti2c-title2.jpg" alt="" /></p>

    
</body>
</html>