<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>PineCone BL602 Talks LoRaWAN</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="PineCone BL602 Talks LoRaWAN" 
    data-rh="true">
<meta property="og:description" 
    content="How we connect PineCone BL602 RISC-V Board to LoRaWAN... With the Pine64 RFM90 LoRa Module"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/lorawan-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">PineCone BL602 Talks LoRaWAN</h1>
    <nav id="TOC"><ul>
<li><a href="#connect-bl602-to-lora-module">1 Connect BL602 to LoRa Module</a><ul></ul></li>
<li><a href="#lora-transceiver-driver">2 LoRa Transceiver Driver</a><ul>
<li><a href="#how-it-works">2.1 How It Works</a><ul></ul></li>
<li><a href="#configure-lora-transceiver">2.2 Configure LoRa Transceiver</a><ul></ul></li>
<li><a href="#initialise-lora-transceiver">2.3 Initialise LoRa Transceiver</a><ul></ul></li>
<li><a href="#transmit-lora-packet">2.4 Transmit LoRa Packet</a><ul></ul></li>
<li><a href="#receive-lora-packet">2.5 Receive LoRa Packet</a><ul></ul></li>
<li><a href="#multitask-with-nimble-porting-layer">2.6 Multitask with NimBLE Porting Layer</a><ul></ul></li></ul></li>
<li><a href="#lorawan-driver">3 LoRaWAN Driver</a><ul>
<li><a href="#whats-inside">3.1 What's Inside</a><ul></ul></li>
<li><a href="#join-network-request">3.2 Join Network Request</a><ul></ul></li>
<li><a href="#join-network-response">3.3 Join Network Response</a><ul></ul></li>
<li><a href="#open-lorawan-port">3.4 Open LoRaWAN Port</a><ul></ul></li>
<li><a href="#transmit-data-packet">3.5 Transmit Data Packet</a><ul></ul></li></ul></li>
<li><a href="#build-and-run-the-bl602-lorawan-firmware">4 Build and Run the BL602 LoRaWAN Firmware</a><ul>
<li><a href="#flash-the-firmware">4.1 Flash the firmware</a><ul></ul></li>
<li><a href="#run-the-firmware">4.2 Run the firmware</a><ul></ul></li>
<li><a href="#enter-lorawan-commands">4.3 Enter LoRaWAN commands</a><ul></ul></li></ul></li>
<li><a href="#troubleshoot-lorawan">5 Troubleshoot LoRaWAN</a><ul></ul></li>
<li><a href="#visualise-lorawan-with-software-defined-radio">6 Visualise LoRaWAN with Software Defined Radio</a><ul></ul></li>
<li><a href="#whats-next">7 What's Next</a><ul></ul></li>
<li><a href="#notes">8 Notes</a><ul></ul></li>
<li><a href="#appendix-lora-transmit-power">9 Appendix: LoRa Transmit Power</a><ul></ul></li>
<li><a href="#appendix-lora-sync-word">10 Appendix: LoRa Sync Word</a><ul></ul></li>
<li><a href="#appendix-lora-carrier-sensing">11 Appendix: LoRa Carrier Sensing</a><ul></ul></li>
<li><a href="#appendix-packet-buffer-and-queue">12 Appendix: Packet Buffer and Queue</a><ul></ul></li>
<li><a href="#appendix-bl602-spi-functions">13 Appendix: BL602 SPI Functions</a><ul></ul></li>
<li><a href="#appendix-bl602-gpio-interrupts">14 Appendix: BL602 GPIO Interrupts</a><ul></ul></li></ul></nav><p>üìù <em>10 May 2021</em></p>
<p>Today we shall connect <strong>PineCone BL602 RISC-V Board</strong> to <strong>LoRaWAN</strong>... With the <strong>Pine64 RFM90 LoRa Module</strong>.</p>
<p>The LoRa Firmware in this article will run on <strong>PineCone, Pinenut and Any BL602 Board</strong>.</p>
<ul>
<li><a href="https://youtu.be/BMMIIiZG6G0"><strong>Watch the demo video on YouTube</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/lorawan-title.jpg" alt="PineCone BL602 RISC-V Board with Pine64 RFM90 LoRa Module (centre), PineBook Pro (left) and RAKwireless WisGate D4H LoRaWAN Gateway (right)" /></p>
<p><em>PineCone BL602 RISC-V Board with Pine64 RFM90 LoRa Module (centre), PineBook Pro (left) and RAKwireless WisGate D4H LoRaWAN Gateway (right)</em></p>
<h1 id="connect-bl602-to-lora-module" class="section-header"><a href="#connect-bl602-to-lora-module">1 Connect BL602 to LoRa Module</a></h1>
<p>Connect BL602 to Pine64 (HopeRF) RFM90 or Semtech SX1262 as follows...</p>
<p><img src="https://lupyuen.github.io/images/lorawan-connect.jpg" alt="PineCone BL602 RISC-V Board connected to Pine64 RFM90 LoRa Module" /></p>
<table><thead><tr><th align="left">BL602 Pin</th><th align="left">RFM90 / SX1262 Pin</th><th align="left">Wire Colour</th></tr></thead><tbody>
<tr><td align="left"><strong><code>GPIO 0</code></strong></td><td align="left"><code>BUSY</code></td><td align="left">Dark Green</td></tr>
<tr><td align="left"><strong><code>GPIO 1</code></strong></td><td align="left"><code>ISO</code> <em>(MISO)</em></td><td align="left">Light Green (Top)</td></tr>
<tr><td align="left"><strong><code>GPIO 2</code></strong></td><td align="left">Do Not Connect</td><td align="left">(Unused Chip Select)</td></tr>
<tr><td align="left"><strong><code>GPIO 3</code></strong></td><td align="left"><code>SCK</code></td><td align="left">Yellow (Top)</td></tr>
<tr><td align="left"><strong><code>GPIO 4</code></strong></td><td align="left"><code>OSI</code> <em>(MOSI)</em></td><td align="left">Blue (Top)</td></tr>
<tr><td align="left"><strong><code>GPIO 11</code></strong></td><td align="left"><code>DIO1</code></td><td align="left">Yellow (Bottom)</td></tr>
<tr><td align="left"><strong><code>GPIO 14</code></strong></td><td align="left"><code>NSS</code></td><td align="left">Orange</td></tr>
<tr><td align="left"><strong><code>GPIO 17</code></strong></td><td align="left"><code>RST</code></td><td align="left">White</td></tr>
<tr><td align="left"><strong><code>3V3</code></strong></td><td align="left"><code>3.3V</code></td><td align="left">Red</td></tr>
<tr><td align="left"><strong><code>GND</code></strong></td><td align="left"><code>GND</code></td><td align="left">Black</td></tr>
</tbody></table>
<p><a href="https://electronics.stackexchange.com/questions/335912/can-i-break-a-radio-tranceiving-device-by-operating-it-with-no-antenna-connected"><strong>CAUTION: Always connect the Antenna before Powering On... Or the LoRa Module may get damaged! See this</strong></a></p>
<p>Here's a closer look at the pins connected on BL602...</p>
<p><img src="https://lupyuen.github.io/images/lorawan-connect2.jpg" alt="PineCone BL602 RISC-V Board connected to Pine64 RFM90 LoRa Module" /></p>
<p><em>Why is BL602 Pin 2 unused?</em></p>
<p><strong><code>GPIO 2</code></strong> is the <strong>Unused SPI Chip Select</strong> on BL602.</p>
<p>We won't use this pin because we'll control Chip Select ourselves on <code>GPIO 14</code>. <a href="https://lupyuen.github.io/articles/spi#control-our-own-chip-select-pin">(See this)</a></p>
<p>Here are the pins connected on our LoRa Module: RFM90 or SX1262...</p>
<p><img src="https://lupyuen.github.io/images/lorawan-connect3.jpg" alt="PineCone BL602 RISC-V Board connected to Pine64 RFM90 LoRa Module" /></p>
<p><em>What's Pin <code>DIO1</code>?</em></p>
<p>Our LoRa Module shifts <strong>Pin <code>DIO1</code></strong> from Low to High to signal that a <strong>LoRa Packet has been transmitted or received</strong>.</p>
<p>We shall configure BL602 to trigger a <strong>GPIO Interrupt</strong> when Pin <code>DIO1</code> shifts from Low to High.</p>
<ul>
<li>
<p><a href="https://semtech.my.salesforce.com/sfc/p/#E0000000JelG/a/2R000000HT76/7Nka9W5WgugoZe.xwIHJy6ebj1hW8UJ.USO_Pt2CLLo"><strong>Semtech SX1262 Datasheet</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/releases/tag/v9.0.0"><strong>HopeRF RFM90 Datasheet (Chinese)</strong></a></p>
</li>
</ul>
<h1 id="lora-transceiver-driver" class="section-header"><a href="#lora-transceiver-driver">2 LoRa Transceiver Driver</a></h1>
<p>The <strong>BL602 Driver for RFM90 / SX1262</strong> is located here...</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/tree/lorawan/components/3rdparty/lora-sx1262"><code>components/3rdparty/lora-sx1262</code></a></li>
</ul>
<p>Let's study the source code and learn how the driver is called by our Demo Firmware to <strong>transmit and receive LoRa Packets</strong>...</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/tree/lorawan/customer_app/sdk_app_lorawan"><code>customer_app/sdk_app_lorawan</code></a></li>
</ul>
<h2 id="how-it-works" class="section-header"><a href="#how-it-works">2.1 How It Works</a></h2>
<p>Our LoRa Driver has 3 layers: <strong>Radio Interface, Transceiver Interface and Board Interface</strong>...</p>
<p><img src="https://lupyuen.github.io/images/lorawan-transceiver.png" alt="BL602 Driver for RFM90 / SX1262" /></p>
<ol>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/radio.c"><strong>Radio Interface: <code>radio.c</code></strong></a></p>
<p>Exposes the LoRa Radio Functions that will initialise the transceiver (<code>RadioInit</code>), send a LoRa Packet (<code>RadioSend</code>) and receive a LoRa Packet (<code>RadioRx</code>).</p>
<p>Our Demo Firmware calls the Radio Interface to send and receive LoRa Packets. (Our LoRaWAN Driver calls the Radio Interface too)</p>
<p>The Radio Interface is generic and works for various LoRa Transceivers (like SX1276).</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/sx126x.c"><strong>Transceiver Interface: <code>sx126x.c</code></strong></a></p>
<p>Provides the functions specific to the SX1262 Transceiver: <code>SX126xInit</code>, <code>SX126xSendPayload</code>, <code>SX126xSetRx</code>, ...</p>
<p>Called by the Radio Interface.</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/sx126x-board.c"><strong>Board Interface: <code>sx126x-board.c</code></strong></a></p>
<p>Exposes the functions specific to our BL602 Board: <strong>SPI, GPIO, Events and Timers.</strong></p>
<p>SPI and GPIO Functions are implemented with the <strong>SPI and GPIO Hardware Abstraction Layers</strong> (HALs) from the BL602 IoT SDK.</p>
<p>Events and Timers are implemented with the <strong>NimBLE Porting Layer</strong>, a library that simplifies the FreeRTOS multitasking functions from the BL602 IoT SDK.</p>
<p>Called by the Transceiver Interface.</p>
</li>
</ol>
<p>The LoRa Driver was ported to BL602 from <strong>Semtech's Reference Implementation of the SX1262 Driver</strong>. <a href="https://github.com/Lora-net/LoRaMac-node/tree/master/src/radio/sx126x">(See this)</a></p>
<h2 id="configure-lora-transceiver" class="section-header"><a href="#configure-lora-transceiver">2.2 Configure LoRa Transceiver</a></h2>
<p>(<strong>Note on LoRa vs LoRaWAN:</strong> We configure LoRaWAN via <code>Makefile</code>, not <code>#define</code>. Skip this section if we're using LoRaWAN.)</p>
<p>We set the <strong>LoRa Frequency</strong> in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L44-L80"><code>demo.c</code></a> like so...</p>
<pre><code class="language-c">/// TODO: We are using LoRa Frequency 923 MHz 
/// for Singapore. Change this for your region.
#define USE_BAND_923
</code></pre>
<p>Change <code>USE_BAND_923</code> to <code>USE_BAND_433</code>, <code>780</code>, <code>868</code> or <code>915</code>. Here's the complete list...</p>
<pre><code class="language-c">#if defined(USE_BAND_433)
    #define RF_FREQUENCY               434000000 /* Hz */
#elif defined(USE_BAND_780)
    #define RF_FREQUENCY               780000000 /* Hz */
#elif defined(USE_BAND_868)
    #define RF_FREQUENCY               868000000 /* Hz */
#elif defined(USE_BAND_915)
    #define RF_FREQUENCY               915000000 /* Hz */
#elif defined(USE_BAND_923)
    #define RF_FREQUENCY               923000000 /* Hz */
#else
    #error &quot;Please define a frequency band in the compiler options.&quot;
#endif
</code></pre>
<p>The <strong>LoRa Parameters</strong> are also defined in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L44-L80"><code>demo.c</code></a></p>
<pre><code class="language-c">/// LoRa Parameters
#define LORAPING_TX_OUTPUT_POWER            14        /* dBm */

#define LORAPING_BANDWIDTH                  0         /* [0: 125 kHz, */
                                                      /*  1: 250 kHz, */
                                                      /*  2: 500 kHz, */
                                                      /*  3: Reserved] */
#define LORAPING_SPREADING_FACTOR           7         /* [SF7..SF12] */
#define LORAPING_CODINGRATE                 1         /* [1: 4/5, */
                                                      /*  2: 4/6, */
                                                      /*  3: 4/7, */
                                                      /*  4: 4/8] */
#define LORAPING_PREAMBLE_LENGTH            8         /* Same for Tx and Rx */
#define LORAPING_SYMBOL_TIMEOUT             5         /* Symbols */
#define LORAPING_FIX_LENGTH_PAYLOAD_ON      false
#define LORAPING_IQ_INVERSION_ON            false

#define LORAPING_TX_TIMEOUT_MS              3000    /* ms */
#define LORAPING_RX_TIMEOUT_MS              5000    /* ms */
#define LORAPING_BUFFER_SIZE                64      /* LoRa message size */
</code></pre>
<p>These should match the LoRa Parameters used by the LoRa Receiver.</p>
<p>I used this LoRa Receiver (based on RAKwireless WisBlock) for testing our LoRa Driver...</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/wisblock"><strong>&quot;RAKwireless WisBlock talks LoRa with PineCone BL602 RISC-V Board&quot;</strong></a></li>
</ul>
<h2 id="initialise-lora-transceiver" class="section-header"><a href="#initialise-lora-transceiver">2.3 Initialise LoRa Transceiver</a></h2>
<p>(<strong>Note on LoRa vs LoRaWAN:</strong> Our LoRaWAN Driver initialises the LoRa Transceiver for us, when we run the <code>init_lorawan</code> command. Skip this section if we're using LoRaWAN.)</p>
<p>The <code>init_driver</code> command in our Demo Firmware initialises the LoRa Transceiver like so: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L159-L212"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Command to initialise the LoRa Driver.
/// Assume that create_task has been called to init the Event Queue.
static void init_driver(char *buf, int len, int argc, char **argv) {
    //  Set the LoRa Callback Functions
    RadioEvents_t radio_events;
    memset(&amp;radio_events, 0, sizeof(radio_events));  //  Must init radio_events to null, because radio_events lives on stack!
    radio_events.TxDone    = on_tx_done;     //  Packet has been transmitted
    radio_events.RxDone    = on_rx_done;     //  Packet has been received
    radio_events.TxTimeout = on_tx_timeout;  //  Transmit Timeout
    radio_events.RxTimeout = on_rx_timeout;  //  Receive Timeout
    radio_events.RxError   = on_rx_error;    //  Receive Error
</code></pre>
<p>Here we set the <strong>Callback Functions</strong> that will be called when a LoRa Packet has been transmitted or received, also when we encounter a transmit / receive timeout or error.</p>
<p>(We'll see the Callback Functions in a while)</p>
<p>Next we initialise the LoRa Transceiver and set the <strong>LoRa Frequency</strong>...</p>
<pre><code class="language-c">    //  Init the SPI Port and the LoRa Transceiver
    Radio.Init(&amp;radio_events);

    //  Set the LoRa Frequency
    Radio.SetChannel(RF_FREQUENCY);
</code></pre>
<p>We set the <strong>LoRa Transmit Parameters</strong>...</p>
<pre><code class="language-c">    //  Configure the LoRa Transceiver for transmitting messages
    Radio.SetTxConfig(
        MODEM_LORA,
        LORAPING_TX_OUTPUT_POWER,
        0,        //  Frequency deviation: Unused with LoRa
        LORAPING_BANDWIDTH,
        LORAPING_SPREADING_FACTOR,
        LORAPING_CODINGRATE,
        LORAPING_PREAMBLE_LENGTH,
        LORAPING_FIX_LENGTH_PAYLOAD_ON,
        true,     //  CRC enabled
        0,        //  Frequency hopping disabled
        0,        //  Hop period: N/A
        LORAPING_IQ_INVERSION_ON,
        LORAPING_TX_TIMEOUT_MS
    );
</code></pre>
<p>Finally we set the <strong>LoRa Receive Parameters</strong>...</p>
<pre><code class="language-c">    //  Configure the LoRa Transceiver for receiving messages
    Radio.SetRxConfig(
        MODEM_LORA,
        LORAPING_BANDWIDTH,
        LORAPING_SPREADING_FACTOR,
        LORAPING_CODINGRATE,
        0,        //  AFC bandwidth: Unused with LoRa
        LORAPING_PREAMBLE_LENGTH,
        LORAPING_SYMBOL_TIMEOUT,
        LORAPING_FIX_LENGTH_PAYLOAD_ON,
        0,        //  Fixed payload length: N/A
        true,     //  CRC enabled
        0,        //  Frequency hopping disabled
        0,        //  Hop period: N/A
        LORAPING_IQ_INVERSION_ON,
        true      //  Continuous receive mode
    );    
}
</code></pre>
<p>The &quot;<code>Radio</code>&quot; functions are defined in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/radio.c"><code>radio.c</code></a> ...</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/radio.c#L523-L559"><strong><code>RadioInit</code></strong> - Init LoRa Transceiver</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/radio.c#L600-L604"><strong><code>RadioSetChannel</code></strong> - Set LoRa Frequency</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/radio.c#L788-L908"><strong><code>RadioSetTxConfig</code></strong> - Set LoRa Transmit Configuration</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/radio.c#L661-L786"><strong><code>RadioSetRxConfig</code></strong> - Set LoRa Receive Configuration</a></p>
</li>
</ul>
<h2 id="transmit-lora-packet" class="section-header"><a href="#transmit-lora-packet">2.4 Transmit LoRa Packet</a></h2>
<p>(<strong>Note on LoRa vs LoRaWAN:</strong> Our LoRaWAN Driver calls the LoRa Driver to transmit LoRa Packets, when we run the <code>las_join</code> and <code>las_app_tx</code> commands. Skip this section if we're using LoRaWAN to transmit data.)</p>
<p>To transmit a LoRa Packet, the <code>send_message</code> command in our Demo Firmware calls <code>send_once</code> in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L214-L219"><code>demo.c</code></a> ... </p>
<pre><code class="language-c">/// Command to send a LoRa message. Assume that the LoRa Transceiver driver has been initialised.
static void send_message(char *buf, int len, int argc, char **argv) {
    //  Send the &quot;PING&quot; message
    send_once(1);
}
</code></pre>
<p><strong><code>send_once</code></strong> prepares a LoRa Packet containing the string &quot;<code>PING</code>&quot;...</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L221-L244"><code>demo.c</code></a> :</p>
<pre><code class="language-c">/// We send a &quot;PING&quot; message and expect a &quot;PONG&quot; response
const uint8_t loraping_ping_msg[] = &quot;PING&quot;;
const uint8_t loraping_pong_msg[] = &quot;PONG&quot;;

/// 64-byte buffer for our LoRa message
static uint8_t loraping_buffer[LORAPING_BUFFER_SIZE];

/// Send a LoRa message. If is_ping is 0, send &quot;PONG&quot;. Otherwise send &quot;PING&quot;.
static void send_once(int is_ping) {
    //  Copy the &quot;PING&quot; or &quot;PONG&quot; message 
    //  to the transmit buffer
    if (is_ping) {
        memcpy(loraping_buffer, loraping_ping_msg, 4);
    } else {
        memcpy(loraping_buffer, loraping_pong_msg, 4);
    }
</code></pre>
<p>Then pads the packet with values 0, 1, 2, ...</p>
<pre><code class="language-c">    //  Fill up the remaining space in the 
    //  transmit buffer (64 bytes) with values 
    //  0, 1, 2, ...
    for (int i = 4; i &lt; sizeof loraping_buffer; i++) {
        loraping_buffer[i] = i - 4;
    }
</code></pre>
<p>And transmits the LoRa Packet...</p>
<pre><code class="language-c">    //  Send the transmit buffer (64 bytes)
    Radio.Send(loraping_buffer, sizeof loraping_buffer);
}
</code></pre>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/radio.c#L1069-L1098">(<code>RadioSend</code> is defined here)</a></p>
<p>When the LoRa Packet is transmitted, the LoRa Driver calls our Callback Function <strong><code>on_tx_done</code></strong> ...</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L399-L412"><code>demo.c</code></a> :</p>
<pre><code class="language-c">/// Callback Function that is called when our LoRa message has been transmitted
static void on_tx_done(void) {
    //  Log the success status
    loraping_stats.tx_success++;

    //  Switch the LoRa Transceiver to 
    //  low power, sleep mode
    Radio.Sleep();
}
</code></pre>
<p>Here we log the number of packets transmitted, and put the LoRa Transceiver to low power, sleep mode.</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/radio.c#L1100-L1109">(<code>RadioSleep</code> is defined here)</a></p>
<h2 id="receive-lora-packet" class="section-header"><a href="#receive-lora-packet">2.5 Receive LoRa Packet</a></h2>
<p>(<strong>Note on LoRa vs LoRaWAN:</strong> Our LoRaWAN Driver calls the LoRa Driver to receive LoRa Packets, when we run the <code>las_join</code> and <code>las_app_tx</code> commands. Skip this section if we're using LoRaWAN to receive data.)</p>
<p>Here's how the <code>receive_message</code> command in our Demo Firmware receives a LoRa Packet: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L246-L252"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Command to receive a LoRa message. Assume that LoRa Transceiver driver has been initialised.
/// Assume that create_task has been called to init the Event Queue.
static void receive_message(char *buf, int len, int argc, char **argv) {
    //  Receive a LoRa message within the timeout period
    Radio.Rx(LORAPING_RX_TIMEOUT_MS);  //  Timeout in 5 seconds
}
</code></pre>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/radio.c#L1117-L1138">(<code>RadioRx</code> is defined here)</a></p>
<p>When the LoRa Driver receives a LoRa Packet, it calls our Callback Function <code>on_rx_done</code> ...</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L414-L444"><code>demo.c</code></a> :</p>
<pre><code class="language-c">/// Callback Function that is called when a LoRa message has been received
static void on_rx_done(
    uint8_t *payload,  //  Buffer containing received LoRa message
    uint16_t size,     //  Size of the LoRa message
    int16_t rssi,      //  Signal strength
    int8_t snr) {      //  Signal To Noise ratio

    //  Switch the LoRa Transceiver to low power, sleep mode
    Radio.Sleep();

    //  Log the signal strength, signal to noise ratio
    loraping_rxinfo_rxed(rssi, snr);
</code></pre>
<p><strong><code>on_rx_done</code></strong> switches the LoRa Transceiver to low power, sleep mode and logs the received packet.</p>
<p>Next it <strong>copies the received packet</strong> into a buffer...</p>
<pre><code class="language-c">    //  Copy the received packet
    if (size &gt; sizeof loraping_buffer) {
        size = sizeof loraping_buffer;
    }
    loraping_rx_size = size;
    memcpy(loraping_buffer, payload, size);
</code></pre>
<p>Finally it <strong>dumps the buffer</strong> containing the received packet...</p>
<pre><code class="language-c">    //  Dump the contents of the received packet
    for (int i = 0; i &lt; loraping_rx_size; i++) {
        printf(&quot;%02x &quot;, loraping_buffer[i]);
    }
    printf(&quot;\r\n&quot;);
}
</code></pre>
<p><em>What happens when we don't receive a packet in 5 seconds?</em></p>
<p>The LoRa Driver calls our Callback Function <code>on_rx_timeout</code> ...</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/customer_app/sdk_app_lorawan/sdk_app_lorawan/demo.c#L461-L475"><code>demo.c</code></a> :</p>
<pre><code class="language-c">/// Callback Function that is called when no LoRa messages could be received due to timeout
static void on_rx_timeout(void) {
    //  Switch the LoRa Transceiver to low power, sleep mode
    Radio.Sleep();

    //  Log the timeout
    loraping_stats.rx_timeout++;
    loraping_rxinfo_timeout();
}
</code></pre>
<p>We switch the LoRa Transceiver into sleep mode and log the timeout.</p>
<h2 id="multitask-with-nimble-porting-layer" class="section-header"><a href="#multitask-with-nimble-porting-layer">2.6 Multitask with NimBLE Porting Layer</a></h2>
<p>TODO</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lora2#multitask-with-nimble-porting-layer"><strong>&quot;Multitask with NimBLE Porting Layer&quot;</strong></a></li>
</ul>
<h1 id="lorawan-driver" class="section-header"><a href="#lorawan-driver">3 LoRaWAN Driver</a></h1>
<p>We've seen the LoRa Transceiver Driver (for RFM90 / SX1262)... Now let's watch how the LoRaWAN Driver wraps around the LoRa Transceiver Driver to do <strong>secure, managed LoRaWAN Networking</strong>.</p>
<p>The <strong>BL602 Driver for LoRaWAN</strong> is located here...</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/tree/lorawan/components/3rdparty/lorawan"><code>components/3rdparty/lorawan</code></a></li>
</ul>
<p>We shall study the source code and learn how the LoRaWAN Driver is called by our demo firmware to <strong>join the LoRaWAN Network and transmit data packets</strong>...</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/tree/lorawan/customer_app/sdk_app_lorawan"><code>customer_app/sdk_app_lorawan</code></a></li>
</ul>
<h2 id="whats-inside" class="section-header"><a href="#whats-inside">3.1 What's Inside</a></h2>
<p>Our BL602 Driver for LoRaWAN has layers (like Onions, Shrek and Kueh Lapis): <strong>Application Layer, Node Layer and Medium Access Control Layer</strong>...</p>
<p><img src="https://lupyuen.github.io/images/lorawan-driver.png" alt="BL602 LoRaWAN Driver" /></p>
<ol>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/lora_app.c"><strong>Application Layer: <code>lora_app.c</code></strong></a></p>
<p>The <strong>Application Layer</strong> exposes functions for our Demo Firmware to...</p>
<ul>
<li>
<p>Join the LoRaWAN Network: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/lora_app.c#L408-L437"><strong><code>lora_app_join</code></strong></a></p>
</li>
<li>
<p>Open a LoRaWAN Application Port: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/lora_app.c#L148-L205"><strong><code>lora_app_port_open</code></strong></a></p>
</li>
<li>
<p>Transmit a LoRaWAN Data Packet: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/lora_app.c#L262-L304"><strong><code>lora_app_port_send</code></strong></a></p>
</li>
</ul>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/lora_node.c"><strong>Node Layer: <code>lora_node.c</code></strong></a></p>
<p>The <strong>Node Layer</strong> is called by the Application Layer to handle LoRaWAN Networking requests.</p>
<p>The Node Layer channels the networking requests to the Medium Access Control Layer via an <strong>Event Queue</strong> (provided by the NimBLE Porting Layer).</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/mac/LoRaMac.c"><strong>Medium Access Control Layer: <code>LoRaMac.c</code></strong></a></p>
<p>The <strong>Medium Access Control Layer</strong> implements the LoRaWAN Networking functions by calling the LoRa Transceiver Driver (for RFM90 / SX1262).</p>
<p>(Yep the Medium Access Control Layer calls the &quot;<code>Radio</code>&quot; functions we've seen in the previous chapter)</p>
<p>This layer is fully aware of the <strong>LoRa Frequencies</strong> and the Encoding Schemes that should be used in each world region. And it enforces <strong>LoRaWAN Security</strong> (like encryption and authentication of messages).</p>
<p>The Medium Access Control Layer runs as a <strong>Background Task</strong>, communicating with the Node Layer in a queued, asynchronous way via an Event Queue.</p>
</li>
<li>
<p>We're not using the <strong>Command-Line Interface</strong> <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/lora_cli.c"><code>lora_cli.c</code></a> that's bundled with our LoRaWAN Driver.</p>
<p>Instead we're using the Command-Line Interface that's coded inside our Demo Firmware.</p>
</li>
</ol>
<p>The LoRaWAN Driver was ported to BL602 from <strong>Apache Mynewt OS</strong>. <a href="https://github.com/apache/mynewt-core/tree/master/net/lora/node">(See this)</a></p>
<p>(This implementation of the LoRaWAN Driver seems outdated. There is a newer reference implementation by Semtech. <a href="https://github.com/Lora-net/LoRaMac-node/tree/master/src/mac">See this</a>)</p>
<h2 id="join-network-request" class="section-header"><a href="#join-network-request">3.2 Join Network Request</a></h2>
<p>Before transmitting a LoRaWAN Data Packet, our BL602 gadget needs to <strong>join the LoRaWAN Network</strong>.</p>
<p>(It's like connecting to a WiFi Network, authenticated by a security key)</p>
<p>Let's study what happens when we enter the <strong><code>las_join</code></strong> command in our Demo Firmware to join a LoRaWAN Network...</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/customer_app/sdk_app_lorawan/sdk_app_lorawan/lorawan.c#L901-L935"><code>lorawan.c</code></a> :</p>
<pre><code class="language-c">/// `las_join` command will send a Join Network Request
void las_cmd_join(char *buf0, int len0, int argc, char **argv) {
    ...
    //  Send a Join Network Request
    int rc = lora_app_join(
        g_lora_dev_eui,  //  Device EUI
        g_lora_app_eui,  //  Application EUI
        g_lora_app_key,  //  Application Key
        attempts         //  Number of join attempts
    );
</code></pre>
<p>To join a LoRaWAN Network we need to have 3 things in our BL602 firmware...</p>
<ol>
<li>
<p><strong>Device EUI</strong>: A 64-bit number that uniquely identifies our LoRaWAN Device (BL602)</p>
</li>
<li>
<p><strong>Application EUI</strong>: A 64-bit number that uniquely identifies the LoRaWAN Server Application that will receive our LoRaWAN Data Packets</p>
</li>
<li>
<p><strong>Application Key</strong>: A 128-bit secret key that will authenticate our LoRaWAN Device for that LoRaWAN Server Application</p>
</li>
</ol>
<p>(EUI sounds like a Pungent Durian... But it actually means <a href="https://lora-developers.semtech.com/library/tech-papers-and-guides/the-book/deveui/"><strong>Extended Unique Identifier</strong></a>)</p>
<p>How do we get the Device EUI, Application EUI and Application Key? We'll find out in a while.</p>
<p><strong><code>lora_app_join</code></strong> is defined in the <strong>Application Layer</strong> of our LoRaWAN Driver: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/a7ea4403ab39003bd7c1c71280e7ffb78426c3e0/components/3rdparty/lorawan/src/lora_app.c#L408-L437"><code>lora_app.c</code></a></p>
<pre><code class="language-c">/// Send a Join Network Request
int lora_app_join(uint8_t *dev_eui, uint8_t *app_eui, uint8_t *app_key, uint8_t trials) {
    //  Omitted: Validate the parameters
    ...

    //  Tell device to start join procedure
    int rc = lora_node_join(dev_eui, app_eui, app_key, trials);
</code></pre>
<p>Here we validate the parameters and call <code>lora_node_join</code>.</p>
<p>Now we hop over from the Application Layer to the <strong>Node Layer</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/b2e1635091fd539c11d56b125e36f8987c4c38e3/components/3rdparty/lorawan/src/lora_node.c#L473-L503"><code>lora_node.c</code></a></p>
<pre><code class="language-c">/// Perform the join process
int lora_node_join(uint8_t *dev_eui, uint8_t *app_eui, uint8_t *app_key, uint8_t trials) {
    //  Omitted: Check if we have joined the network
    ...

    //  Set the Event parameters
    g_lm_join_ev_arg.dev_eui = dev_eui;
    g_lm_join_ev_arg.app_eui = app_eui;
    g_lm_join_ev_arg.app_key = app_key;
    g_lm_join_ev_arg.trials  = trials;

    //  Send Event to Medium Access Control Layer via Event Queue
    ble_npl_eventq_put(
        g_lora_mac_data.lm_evq,      //  Event Queue
        &amp;g_lora_mac_data.lm_join_ev  //  Event
    );
</code></pre>
<p>Here we're passing a Join Event to the <strong>Event Queue</strong> that's provided by the NimBLE Porting Layer.</p>
<p>Again we hop, from the Node Layer to the <strong>Medium Access Control Layer</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/mac/LoRaMac.c#L3086-L3139"><code>LoRaMac.c</code></a></p>
<pre><code class="language-c">/// Background Task that handles the Event Queue
LoRaMacStatus_t LoRaMacMlmeRequest(MlmeReq_t *mlmeRequest) {
    ...
    //  Check the request type
    switch (mlmeRequest-&gt;Type) {
        //  If this is a join request...
        case MLME_JOIN:
            //  Compose and send the join request
            status = Send(&amp;macHdr, 0, NULL);
</code></pre>
<p><strong><code>LoRaMacMlmeRequest</code></strong> runs as a <strong>FreeRTOS Background Task</strong>, processing the Events that have been enqueued in the Event Queue.</p>
<p>(That's how the Node Layer and the Medium Access Control Layer collaborate asynchronously)</p>
<p><code>LoRaMacMlmeRequest</code> calls <strong><code>Send</code></strong> to compose and transmit the Join Request as a LoRa Packet: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/mac/LoRaMac.c#L1932-L1954"><code>LoRaMac.c</code></a></p>
<pre><code class="language-c">//  Compose and send a packet
LoRaMacStatus_t Send(LoRaMacHeader_t *macHdr, uint8_t fPort, struct pbuf *om) {
    ...
    //  Prepare the LoRa Packet
    status = PrepareFrame(macHdr, &amp;fCtrl, fPort, om);

    //  Send the LoRa Packet
    status = ScheduleTx();
</code></pre>
<p>The call chain goes...</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/mac/LoRaMac.c#L1932-L1954"><code>Send</code></a> ‚Üí <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/mac/LoRaMac.c#L1956-L2062"><code>ScheduleTx</code></a> ‚Üí <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/mac/LoRaMac.c#L2379-L2426"><code>SendFrameOnChannel</code></a> ‚Üí <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/radio.c#L1069-L1098"><code>RadioSend</code></a></p>
<p>Eventually the Medium Access Control Layer calls <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/radio.c#L1069-L1098"><strong><code>RadioSend</code></strong></a> (from our LoRa Transceiver Driver) to transmit the Join Request.</p>
<p><a href="https://lupyuen.github.io/articles/wisgate#join-network-request">(What's inside the Join Request? Check this out)</a></p>
<p>And that's how our LoRaWAN Driver sends a <strong>Join Network Request</strong>...</p>
<p>LoRaWAN Firmware ‚Üí Application Layer ‚Üí Node Layer ‚Üí Medium Access Control Layer ‚Üí LoRa Transceiver Driver!</p>
<p><img src="https://lupyuen.github.io/images/lorawan-driver5.png" alt="Medium Access Control Layer" /></p>
<h2 id="join-network-response" class="section-header"><a href="#join-network-response">3.3 Join Network Response</a></h2>
<p>But wait... We're not done yet!</p>
<p>TODO</p>
<pre><code class="language-text">RadioRx
RadioOnDioIrq
RadioIrqProcess
SX126xReadCommand
IRQ_PREAMBLE_DETECTED
RadioOnDioIrq
RadioIrqProcess
SX126xReadCommand
IRQ_HEADER_VALID
RadioOnDioIrq
RadioIrqProcess
SX126xReadCommand
IRQ_RX_DONE
SX126xReadCommand
SX126xReadCommand
OnRadioRxDone
lora_mac_process_radio_rx
RadioSleep
lora_mac_rx_win2_stop
</code></pre>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/mac/LoRaMac.c#L906-L988"><code>LoRaMac.c</code></a> :</p>
<pre><code class="language-c">/**
 * Process the radio receive event.
 *
 * Context: MAC task
 *
 * @param ev
 */
static void
lora_mac_process_radio_rx(struct ble_npl_event *ev)
{
    printf(&quot;lora_mac_process_radio_rx\r\n&quot;);
    LoRaMacHeader_t macHdr;
    LoRaMacFrameCtrl_t fCtrl;
    LoRaMacRxSlot_t entry_rx_slot;
    struct lora_pkt_info *rxi;
    bool skipIndication = false;
    bool send_indicate = false;
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    uint8_t *payload;
    uint16_t size;
    int8_t snr;
    uint8_t hdrlen;
    uint32_t address = 0;
    uint8_t appPayloadStartIndex = 0;
    uint8_t port = 0xFF;
    uint8_t frameLen;
    uint32_t mic = 0;
    uint32_t micRx;

    uint16_t sequenceCounter = 0;
    uint16_t sequenceCounterPrev = 0;
    uint16_t sequenceCounterDiff = 0;
    uint32_t downLinkCounter = 0;

    MulticastParams_t *curMulticastParams = NULL;
    uint8_t *nwkSKey = LoRaMacNwkSKey;
    uint8_t *appSKey = LoRaMacAppSKey;

    uint8_t multicast = 0;

    /*
     * XXX: what if window 2 timeout event already enqueued? If we
     * receive a frame with a valid MIC we are supposed to not receive
     * on window 2. We stop the timer below but what if event has been
     * processed?
     */

    /* Put radio to sleep if not class C */
    if (LoRaMacDeviceClass != CLASS_C) {
        Radio.Sleep( );
    }

    STATS_INC(lora_mac_stats, rx_frames);

    /* Payload, size and snr are filled in by radio rx ISR */
    payload = g_lora_mac_data.rxbuf;
    size = g_lora_mac_data.rxbufsize;

    rxi = &amp;g_lora_mac_data.rxpkt;
    snr = rxi-&gt;rxdinfo.snr;

    /* Reset rest of global indication element */
    rxi-&gt;port = 0;
    entry_rx_slot = g_lora_mac_data.rx_slot;
    rxi-&gt;rxdinfo.rxslot = entry_rx_slot;
    rxi-&gt;rxdinfo.multicast = 0;
    rxi-&gt;rxdinfo.frame_pending = 0;
    rxi-&gt;rxdinfo.rxdata = false;
    rxi-&gt;rxdinfo.ack_rxd = false;
    rxi-&gt;rxdinfo.downlink_cntr = 0;

    /* Get the MHDR from the received frame */
    macHdr.Value = payload[0];
    hdrlen = 1;

    lora_node_log(LORA_NODE_LOG_RX_DONE, g_lora_mac_data.cur_chan, size,
                  (entry_rx_slot &lt;&lt; 8) | macHdr.Value);

    switch (macHdr.Bits.MType) {
        case FRAME_TYPE_JOIN_ACCEPT:
            lora_mac_join_accept_rxd(payload, size);
            break;
</code></pre>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/mac/LoRaMac.c#L574-L667"><code>LoRaMac.c</code></a> :</p>
<pre><code class="language-c">static void
lora_mac_join_accept_rxd(uint8_t *payload, uint16_t size)
{
    uint32_t temp;
    uint32_t mic;
    uint32_t micRx;
    ApplyCFListParams_t apply_cf_list;

    STATS_INC(lora_mac_stats, join_accept_rx);

    if (LM_F_IS_JOINED()) {
        STATS_INC(lora_mac_stats, already_joined);
        return;
    }

    /*
     * XXX: This is odd, but if we receive a join accept and we are not
     * joined but have not started the join process not sure what to
     * do. Guess we will just ignore this packet.
     */
    if (!LM_F_IS_JOINING()) {
        return;
    }

    /* XXX: check for too small frame! */

    LoRaMacJoinDecrypt(payload + 1, size - 1, LoRaMacAppKey,
                       LoRaMacRxPayload + 1);

    LoRaMacRxPayload[0] = payload[0];

    LoRaMacJoinComputeMic(LoRaMacRxPayload, size - LORAMAC_MFR_LEN,
                          LoRaMacAppKey, &amp;mic);

    micRx = ( uint32_t )LoRaMacRxPayload[size - LORAMAC_MFR_LEN];
    micRx |= ( ( uint32_t )LoRaMacRxPayload[size - LORAMAC_MFR_LEN + 1] &lt;&lt; 8 );
    micRx |= ( ( uint32_t )LoRaMacRxPayload[size - LORAMAC_MFR_LEN + 2] &lt;&lt; 16 );
    micRx |= ( ( uint32_t )LoRaMacRxPayload[size - LORAMAC_MFR_LEN + 3] &lt;&lt; 24 );

    if (micRx == mic) {
        LoRaMacJoinComputeSKeys(LoRaMacAppKey, LoRaMacRxPayload + 1,
                                g_lora_mac_data.dev_nonce, LoRaMacNwkSKey,
                                LoRaMacAppSKey);

        temp = ( uint32_t )LoRaMacRxPayload[4];
        temp |= ( ( uint32_t )LoRaMacRxPayload[5] &lt;&lt; 8 );
        temp |= ( ( uint32_t )LoRaMacRxPayload[6] &lt;&lt; 16 );
        g_lora_mac_data.netid = temp;

        temp = ( uint32_t )LoRaMacRxPayload[7];
        temp |= ( ( uint32_t )LoRaMacRxPayload[8] &lt;&lt; 8 );
        temp |= ( ( uint32_t )LoRaMacRxPayload[9] &lt;&lt; 16 );
        temp |= ( ( uint32_t )LoRaMacRxPayload[10] &lt;&lt; 24 );
        g_lora_mac_data.dev_addr = temp;

        // DLSettings
        LoRaMacParams.Rx1DrOffset = ( LoRaMacRxPayload[11] &gt;&gt; 4 ) &amp; 0x07;
        LoRaMacParams.Rx2Channel.Datarate = LoRaMacRxPayload[11] &amp; 0x0F;

        // RxDelay
        LoRaMacParams.ReceiveDelay1 = ( LoRaMacRxPayload[12] &amp; 0x0F );
        if (LoRaMacParams.ReceiveDelay1 == 0) {
            LoRaMacParams.ReceiveDelay1 = 1;
        }
        LoRaMacParams.ReceiveDelay1 *= 1000;
        LoRaMacParams.ReceiveDelay2 = LoRaMacParams.ReceiveDelay1 + 1000;

        // Apply CF list
        apply_cf_list.Payload = &amp;LoRaMacRxPayload[13];

        // Size of the regular payload is 12. Plus 1 byte MHDR and 4 bytes MIC
        apply_cf_list.Size = size - 17;

        RegionApplyCFList(LoRaMacRegion, &amp;apply_cf_list);

        /* We are now joined */
        STATS_INC(lora_mac_stats, joins);

        /* Stop window 2 if class A device */
        lora_mac_rx_win2_stop();

        LM_F_IS_JOINED() = 1;
        g_lora_mac_data.uplink_cntr = 0;
        g_lora_mac_data.nb_rep_cntr = 0;

        /* XXX: why not increment this when sending it? Now
           it is done on both success and fail */
        ++g_lora_mac_data.cur_join_attempt;
        lora_mac_send_join_confirm(LORAMAC_EVENT_INFO_STATUS_OK,
                                   g_lora_mac_data.cur_join_attempt);
    } else {
        STATS_INC(lora_mac_stats, rx_mic_failures);
    }
}
</code></pre>
<p>TODO</p>
<p><em>What's <code>lora_mac_rx_win2_stop</code>?</em></p>
<p>TODO</p>
<h2 id="open-lorawan-port" class="section-header"><a href="#open-lorawan-port">3.4 Open LoRaWAN Port</a></h2>
<p>TODO</p>
<h2 id="transmit-data-packet" class="section-header"><a href="#transmit-data-packet">3.5 Transmit Data Packet</a></h2>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-driver3.png" alt="Application Layer" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-driver4.png" alt="Node Layer" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-driver2.png" alt="LoRaWAN Driver Layers" /></p>
<p>TODO</p>
<h1 id="build-and-run-the-bl602-lorawan-firmware" class="section-header"><a href="#build-and-run-the-bl602-lorawan-firmware">4 Build and Run the BL602 LoRaWAN Firmware</a></h1>
<p>TODO</p>
<p>Let's run the LoRa Demo Firmware for BL602 to receive the LoRa Packets transmitted by RAKwireless WisBlock.</p>
<p>Find out which <strong>LoRa Frequency</strong> we should use for your region...</p>
<ul>
<li><a href="https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html"><strong>LoRa Frequencies by Country</strong></a></li>
</ul>
<p>Build the Firmware Binary File <code>sdk_app_lorawan.bin</code> from the <a href="https://github.com/lupyuen/bl_iot_sdk/tree/lorawan/customer_app/sdk_app_lorawan">source code</a>...</p>
<pre><code class="language-bash"># Download the lorawan branch of lupyuen's bl_iot_sdk
git clone --recursive --branch lorawan https://github.com/lupyuen/bl_iot_sdk
cd bl_iot_sdk/customer_app/sdk_app_lorawan

# TODO: Set the LoRa Frequency in sdk_app_lorawan/demo.c. 
# Edit the file and look for the line...
#   #define USE_BAND_923
# Change 923 to the LoRa Frequency for your region: 
#   434, 780, 868, 915 or 923 MHz
# See https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html

# TODO: Change this to the full path of bl_iot_sdk
export BL60X_SDK_PATH=$HOME/bl_iot_sdk
export CONFIG_CHIP_NAME=BL602
make

# TODO: Change ~/blflash to the full path of blflash
cp build_out/sdk_app_lorawan.bin ~/blflash
</code></pre>
<p><a href="https://lupyuen.github.io/articles/pinecone#building-firmware">More details on building bl_iot_sdk</a></p>
<p>(Remember to use the <strong><code>lorawan</code></strong> branch, not the default <strong><code>master</code></strong> branch)</p>
<h2 id="flash-the-firmware" class="section-header"><a href="#flash-the-firmware">4.1 Flash the firmware</a></h2>
<p>TODO</p>
<p>Follow these steps to install <code>blflash</code>...</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>&quot;Install rustup&quot;</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>&quot;Download and build blflash&quot;</strong></a></p>
</li>
</ol>
<p>We assume that our Firmware Binary File <code>sdk_app_lorawan.bin</code> has been copied to the <code>blflash</code> folder.</p>
<p>Set BL602 to <strong>Flashing Mode</strong> and restart the board...</p>
<p><strong>For PineCone:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ol>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>Enter these commands to flash <code>sdk_app_lorawan.bin</code> to BL602 over UART...</p>
<pre><code class="language-bash"># TODO: Change ~/blflash to the full path of blflash
cd ~/blflash

# For Linux:
sudo cargo run flash sdk_app_lorawan.bin \
    --port /dev/ttyUSB0

# For macOS:
cargo run flash sdk_app_lorawan.bin \
    --port /dev/tty.usbserial-1420 \
    --initial-baud-rate 230400 \
    --baud-rate 230400

# For Windows: Change COM5 to the BL602 Serial Port
cargo run flash sdk_app_lorawan.bin --port COM5
</code></pre>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">More details on flashing firmware</a></p>
<h2 id="run-the-firmware" class="section-header"><a href="#run-the-firmware">4.2 Run the firmware</a></h2>
<p>TODO</p>
<p>Set BL602 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board...</p>
<p><strong>For PineCone:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ol>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>After restarting, connect to BL602's UART Port at 2 Mbps like so...</p>
<p><strong>For Linux:</strong></p>
<pre><code class="language-bash">sudo screen /dev/ttyUSB0 2000000
</code></pre>
<p><strong>For macOS:</strong> Use CoolTerm (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>For Windows:</strong> Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">More details on connecting to BL602</a></p>
<h2 id="enter-lorawan-commands" class="section-header"><a href="#enter-lorawan-commands">4.3 Enter LoRaWAN commands</a></h2>
<p>TODO</p>
<p>Let's enter some commands to join the LoRaWAN Network and transmit a LoRaWAN Data Packet!</p>
<ol>
<li>
<p>Press Enter to reveal the command prompt.</p>
</li>
<li>
<p>Enter <code>help</code> to see the available commands...</p>
<pre><code class="language-text"># help
====User Commands====
create_task              : Create a task
put_event                : Add an event
init_driver              : Init LoRa driver
send_message             : Send LoRa message
receive_message          : Receive LoRa message
read_registers           : Read registers
spi_result               : Show SPI counters
blogset                  : blog pri set level
blogdump                 : blog info dump
bl_sys_time_now          : sys time now
</code></pre>
</li>
<li>
<p>First we <strong>create the Background Task</strong> that will process received LoRa Packets.</p>
<p>Enter this command...</p>
<pre><code class="language-text"># create_task
</code></pre>
<p>This command calls the function <code>create_task</code>, which we have seen earlier.</p>
</li>
<li>
<p>Then we <strong>initialise our LoRa Transceiver</strong>. </p>
<p>Enter this command...</p>
<pre><code class="language-text"># init_driver
</code></pre>
<p>This command calls the function <code>init_driver</code>, which we have seen earlier.</p>
</li>
<li>
<p>We should see this...</p>
<pre><code class="language-text"># init_driver
SX1276 init
SX1276 interrupt init
SX1276 register handler: GPIO 11
SX1276 register handler: GPIO 0
SX1276 register handler: GPIO 5
SX1276 register handler: GPIO 12
</code></pre>
<p>This says that <code>register_gpio_handler</code> has <strong>registered the GPIO Handler Functions</strong> for <code>DIO0</code> to <code>DIO3</code>. (<code>DIO4</code> and <code>DIO5</code> are unused)</p>
<p>Our SX1276 Driver is now <strong>listening for GPIO Interrupts</strong> and handling them.</p>
</li>
<li>
<p>Then the <strong>GPIO Interrupt for <code>DIO3</code></strong> gets triggered automatically...</p>
<pre><code class="language-text">SX1276 DIO3: Channel activity detection    
</code></pre>
<p>(We're not sure why this always happens when we initialise the driver... But it's harmless)</p>
</li>
<li>
<p>Next we <strong>receive a LoRa Packet</strong>...</p>
<pre><code class="language-text"># receive_message
</code></pre>
<p>This command calls the function <code>receive_message</code>, which we have seen earlier.</p>
</li>
<li>
<p>We should see this...</p>
<pre><code class="language-text"># receive_message
...
SX1276 DIO0: Packet received
Rx done: RadioEvents.RxDone
</code></pre>
<p>This says that the SX1276 Driver has <strong>received a LoRa Packet.</strong></p>
<p>And the packet contains <code>&quot;Hello&quot;</code>...</p>
<pre><code class="language-text">Rx done: 48 65 6c 6c 6f 
</code></pre>
<p>(That's the ASCII code for <code>&quot;Hello&quot;</code>)</p>
<p><a href="https://youtu.be/BMMIIiZG6G0"><strong>Watch the demo video on YouTube</strong></a></p>
<p><a href="https://gist.github.com/lupyuen/9bd7e7daa2497e8352d2cffec4be444d"><strong>Check out the receive log</strong></a></p>
</li>
</ol>
<h1 id="troubleshoot-lorawan" class="section-header"><a href="#troubleshoot-lorawan">5 Troubleshoot LoRaWAN</a></h1>
<p>TODO</p>
<h1 id="visualise-lorawan-with-software-defined-radio" class="section-header"><a href="#visualise-lorawan-with-software-defined-radio">6 Visualise LoRaWAN with Software Defined Radio</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-sdr1.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-sdr2.png" alt="" /></p>
<p>TODO</p>
<p><a href="https://youtu.be/BMMIIiZG6G0"><strong>Watch the demo video on YouTube</strong></a></p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">7 What's Next</a></h1>
<p>TODO</p>
<p>We have completed <strong>Level One</strong> of our epic quest for the <a href="https://lupyuen.github.io/articles/lora#lora-vs-lorawan"><strong>Three Levels of LoRa</strong></a>!</p>
<p>Let's move on to <strong>LoRa Levels Two and Three</strong>...</p>
<ol>
<li>
<p>We shall install a <strong>LoRaWAN Gateway</strong> and join BL602 to <strong>The Things Network</strong></p>
<ul>
<li><a href="https://lupyuen.github.io/articles/wisgate"><strong>&quot;Build a LoRaWAN Network with RAKwireless WisGate Developer Gateway&quot;</strong></a></li>
</ul>
</li>
<li>
<p>But before that, we shall port the <strong>LoRaWAN Driver from Apache Mynewt OS to BL602</strong></p>
<p><a href="https://github.com/apache/mynewt-core/tree/master/net/lora/node">(Mynewt Driver for LoRaWAN)</a></p>
</li>
<li>
<p>And before that, we shall clean up and reorganise the <strong>library files for NimBLE and SX1276</strong></p>
<p><a href="https://lupyuen.github.io/articles/lora2#appendix-how-to-create-bl602-libraries">(See this)</a></p>
</li>
</ol>
<p>So eventually we shall build <strong>LoRaWAN Sensor Devices with BL602</strong>!</p>
<p>We have come a loooong way since I first <a href="https://github.com/lupyuen/LoRaArduino"><strong>experimented with LoRa in 2016</strong></a>...</p>
<ul>
<li>
<p><strong>Cheaper Transceivers</strong>: Shipped overnight from Thailand!</p>
</li>
<li>
<p><strong>Mature Networks</strong>: LoRaWAN, The Things Network</p>
</li>
<li>
<p><strong>Better Drivers</strong>: Thanks to Apache Mynewt OS!</p>
</li>
<li>
<p><strong>Powerful Microcontrollers</strong>: Arduino Uno vs RISC-V BL602</p>
</li>
<li>
<p><strong>Awesome Tools</strong>: RAKwireless WisBlock, Airspy SDR, RF Explorer</p>
</li>
</ul>
<p>Now is the <strong>right time to build LoRa gadgets.</strong> Stay tuned for more LoRa and LoRaWAN Adventures!</p>
<p>Meanwhile there's plenty more code in the <a href="https://github.com/bouffalolab/bl_iot_sdk"><strong>BL602 IoT SDK</strong></a> to be deciphered and documented: <strong>ADC, DAC, WiFi, Bluetooth LE,</strong> ...</p>
<p><a href="https://wiki.pine64.org/wiki/Nutcracker"><strong>Come Join Us... Make BL602 Better!</strong></a></p>
<p>üôè üëç üòÄ</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read &quot;The RISC-V BL602 Book&quot;</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here...</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/lorawan.md"><code>lupyuen.github.io/src/lorawan.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">8 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1379926160377851910">this Twitter Thread</a></p>
<p><a href="https://twitter.com/MisterTechBlog/status/1370224529222500352?s=20">(And this Twitter Thread on LoRaWAN Specifications)</a></p>
</li>
</ol>
<h1 id="appendix-lora-transmit-power" class="section-header"><a href="#appendix-lora-transmit-power">9 Appendix: LoRa Transmit Power</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-sdr3.jpg" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-sdr4.jpg" alt="" /></p>
<p>TODO</p>
<ul>
<li><a href="https://semtech.my.salesforce.com/sfc/p/#E0000000JelG/a/2R000000HT76/7Nka9W5WgugoZe.xwIHJy6ebj1hW8UJ.USO_Pt2CLLo"><strong>Semtech SX1262 Datasheet</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/lorawan-ldo.png" alt="" /></p>
<p>TODO</p>
<ul>
<li><a href="https://semtech.my.salesforce.com/sfc/p/#E0000000JelG/a/2R000000HSSf/GT2IXjK2nH8bw6JdEXfFBd.HmFATeLOpL402mZwpSho"><strong>Application Note: Reference Design Explanation</strong></a></li>
</ul>
<p>TODO</p>
<h1 id="appendix-lora-sync-word" class="section-header"><a href="#appendix-lora-sync-word">10 Appendix: LoRa Sync Word</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-syncword.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-syncword2.jpg" alt="" /></p>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lorawan/src/mac/LoRaMac.c#L2581-L2587"><code>LoRaMac.c</code></a></p>
<pre><code class="language-c">LoRaMacStatus_t
LoRaMacInitialization(LoRaMacCallback_t *callbacks, LoRaMacRegion_t region) {
    ...
#if (LORA_NODE_PUBLIC_NWK)
    LM_F_IS_PUBLIC_NWK() = 1;
    Radio.SetPublicNetwork(true);
#else
    LM_F_IS_PUBLIC_NWK() = 0;
    Radio.SetPublicNetwork(false);
#endif
</code></pre>
<h1 id="appendix-lora-carrier-sensing" class="section-header"><a href="#appendix-lora-carrier-sensing">11 Appendix: LoRa Carrier Sensing</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-carrier.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-carrier2.png" alt="" /></p>
<p>TODO</p>
<h1 id="appendix-packet-buffer-and-queue" class="section-header"><a href="#appendix-packet-buffer-and-queue">12 Appendix: Packet Buffer and Queue</a></h1>
<p>TODO</p>
<h1 id="appendix-bl602-spi-functions" class="section-header"><a href="#appendix-bl602-spi-functions">13 Appendix: BL602 SPI Functions</a></h1>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/sx126x-board.c#L120-L164"><code>sx126x-board.c</code></a></p>
<pre><code class="language-c">///////////////////////////////////////////////////////////////////////////////
//  SPI Functions

/// SPI Device Instance
spi_dev_t spi_device;

/// SPI Transmit Buffer (1 byte)
static uint8_t spi_tx_buf[1];

/// SPI Receive Buffer (1 byte)
static uint8_t spi_rx_buf[1];

/// Blocking call to send a value on the SPI. Returns the value received from the SPI Peripheral.
/// Assume that we are sending and receiving 8-bit values on SPI.
/// Assume Chip Select Pin has already been set to Low by caller.
/// TODO: We should combine multiple SPI DMA Requests, instead of handling one byte at a time
uint16_t SpiInOut(int spi_num, uint16_t val) {
    //  Populate the transmit buffer
    spi_tx_buf[0] = val;

    //  Clear the receive buffer
    memset(&amp;spi_rx_buf, 0, sizeof(spi_rx_buf));

    //  Prepare SPI Transfer
    static spi_ioc_transfer_t transfer;
    memset(&amp;transfer, 0, sizeof(transfer));    
    transfer.tx_buf = (uint32_t) spi_tx_buf;  //  Transmit Buffer
    transfer.rx_buf = (uint32_t) spi_rx_buf;  //  Receive Buffer
    transfer.len    = 1;                      //  How many bytes

    //  Assume Chip Select Pin has already been set to Low by caller

    //  Execute the SPI Transfer with the DMA Controller
    int rc = hal_spi_transfer(
        &amp;spi_device,  //  SPI Device
        &amp;transfer,    //  SPI Transfers
        1             //  How many transfers (Number of requests, not bytes)
    );
    assert(rc == 0);

    //  Assume Chip Select Pin will be set to High by caller

    //  Return the received byte
    return spi_rx_buf[0];
}
</code></pre>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/sx126x-board.c#L166-L197"><code>sx126x-board.c</code></a></p>
<pre><code class="language-c">///////////////////////////////////////////////////////////////////////////////

/// Initialise GPIO Pins and SPI Port. Called by SX126xIoIrqInit.
/// Note: This is different from the Reference Implementation,
/// which initialises the GPIO Pins and SPI Port at startup.
void SX126xIoInit( void )
{
    GpioInitOutput( SX126X_SPI_CS_PIN, 1 );
    GpioInitInput( SX126X_BUSY_PIN, 0, 0 );
    GpioInitInput( SX126X_DIO1, 0, 0 );

    //  Configure the SPI Port
    int rc = spi_init(
        &amp;spi_device,     //  SPI Device
        SX126X_SPI_IDX,  //  SPI Port
        0,               //  SPI Mode: 0 for Controller
        //  TODO: Due to a quirk in BL602 SPI, we must set
        //  SPI Polarity-Phase to 1 (CPOL=0, CPHA=1).
        //  But actually Polarity-Phase for SX126X should be 0 (CPOL=0, CPHA=0). 
        1,                    //  SPI Polarity-Phase
        SX126X_SPI_BAUDRATE,  //  SPI Frequency
        2,                    //  Transmit DMA Channel
        3,                    //  Receive DMA Channel
        SX126X_SPI_CLK_PIN,   //  SPI Clock Pin 
        SX126X_SPI_CS_OLD,    //  Unused SPI Chip Select Pin
        SX126X_SPI_SDI_PIN,   //  SPI Serial Data In Pin  (formerly MISO)
        SX126X_SPI_SDO_PIN    //  SPI Serial Data Out Pin (formerly MOSI)
    );
    assert(rc == 0);
}
</code></pre>
<h1 id="appendix-bl602-gpio-interrupts" class="section-header"><a href="#appendix-bl602-gpio-interrupts">14 Appendix: BL602 GPIO Interrupts</a></h1>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorawan/components/3rdparty/lora-sx1262/src/sx126x-board.c#L199-L232"><code>sx126x-board.c</code></a></p>
<pre><code class="language-c">/// Initialise GPIO Pins and SPI Port. Register GPIO Interrupt Handler for DIO1.
/// Based on hal_button_register_handler_with_dts in https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_button.c
/// Note: This is different from the Reference Implementation,
/// which initialises the GPIO Pins and SPI Port at startup.
void SX126xIoIrqInit( DioIrqHandler dioIrq ) {
    //  Initialise GPIO Pins and SPI Port.
    //  Note: This is different from the Reference Implementation,
    //  which initialises the GPIO Pins and SPI Port at startup.
    SX126xIoInit();

    assert(SX126X_DIO1 &gt;= 0);
    assert(dioIrq != NULL);
    int rc = register_gpio_handler(   //  Register GPIO Handler...
        SX126X_DIO1,                  //  GPIO Pin Number
        dioIrq,                       //  GPIO Handler Function
        GLB_GPIO_INT_CONTROL_ASYNC,   //  Async Control Mode
        GLB_GPIO_INT_TRIG_POS_PULSE,  //  Trigger when GPIO level shifts from Low to High 
        0,                            //  No pullup
        0                             //  No pulldown
    );
    assert(rc == 0);

    //  Register Common Interrupt Handler for GPIO Interrupt
    bl_irq_register_with_ctx(
        GPIO_INT0_IRQn,         //  GPIO Interrupt
        handle_gpio_interrupt,  //  Interrupt Handler
        NULL                    //  Argument for Interrupt Handler
    );

    //  Enable GPIO Interrupt
    bl_irq_enable(GPIO_INT0_IRQn);
}
</code></pre>
<p><img src="https://lupyuen.github.io/images/lorawan-commands.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-gpio.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-hal.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-join.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-joinfail.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-joinsend.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-nullpointer.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-para.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-receive.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-regions.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-send.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-spi.jpg" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-stack.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lorawan-transmit.png" alt="" /></p>
<p>TODO</p>

    
</body>
</html>