<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Apache NuttX Driver for BME280 Sensor: Ported from Zephyr OS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Apache NuttX Driver for BME280 Sensor: Ported from Zephyr OS" 
    data-rh="true">
<meta property="og:description" 
    content="Apache NuttX OS talks I2C with Bosch BME280 Sensor on BL602 RISC-V SoC... Thanks to the BME280 Driver ported from Zephyr OS"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/bme280-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Apache NuttX Driver for BME280 Sensor: Ported from Zephyr OS</h1>
    <nav id="TOC"><ul>
<li><a href="#test-and-connect-bme280">1 Test and Connect BME280</a><ul></ul></li>
<li><a href="#start-with-bmp280-driver">2 Start with BMP280 Driver</a><ul>
<li><a href="#configure-nuttx">2.1 Configure NuttX</a><ul></ul></li>
<li><a href="#change-i2c-address-and-device-id">2.2 Change I2C Address and Device ID</a><ul></ul></li>
<li><a href="#register-bmp280-driver">2.3 Register BMP280 Driver</a><ul></ul></li>
<li><a href="#invalid-device-id">2.4 Invalid Device ID</a><ul></ul></li>
<li><a href="#invalid-register-id">2.5 Invalid Register ID</a><ul></ul></li>
<li><a href="#log-i2c-transfers">2.6 Log I2C Transfers</a><ul></ul></li>
<li><a href="#set-i2c-sub-address">2.7 Set I2C Sub Address</a><ul></ul></li>
<li><a href="#bmp280-driver-loads-ok">2.8 BMP280 Driver Loads OK</a><ul></ul></li>
<li><a href="#run-sensor-test-app">2.9 Run Sensor Test App</a><ul></ul></li></ul></li>
<li><a href="#port-bme280-driver-from-zephyr-os">3 Port BME280 Driver from Zephyr OS</a><ul>
<li><a href="#wrap-zephyr-driver-as-nuttx-driver">3.1 Wrap Zephyr Driver as NuttX Driver</a><ul></ul></li>
<li><a href="#read-sensor-data-from-zephyr-driver">3.2 Read Sensor Data from Zephyr Driver</a><ul></ul></li>
<li><a href="#power-management">3.3 Power Management</a><ul></ul></li>
<li><a href="#standby-duration">3.4 Standby Duration</a><ul></ul></li>
<li><a href="#zephyr-driver-modified-for-nuttx">3.5 Zephyr Driver Modified For NuttX</a><ul></ul></li>
<li><a href="#output-log">3.6 Output Log</a><ul></ul></li></ul></li>
<li><a href="#combined-barometer-and-humidity-sensor">4 Combined Barometer and Humidity Sensor</a><ul></ul></li>
<li><a href="#run-bme280-driver">5 Run BME280 Driver</a><ul></ul></li>
<li><a href="#pending-issues">6 Pending Issues</a><ul></ul></li>
<li><a href="#whats-next">7 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">8 Notes</a><ul></ul></li></ul></nav><p>üìù <em>3 Mar 2022</em></p>
<p><img src="https://lupyuen.github.io/images/bme280-title.jpg" alt="Bosch BME280 Sensor connected to Pine64 PineCone BL602 RISC-V Board" /></p>
<p><em>‚ÄúWill <a href="https://lupyuen.github.io/articles/nuttx"><strong>Apache NuttX OS</strong></a> talk I2C with <a href="https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/"><strong>Bosch BME280 Sensor</strong></a>‚Ä¶ On the <a href="https://lupyuen.github.io/articles/pinecone"><strong>BL602 RISC-V SoC</strong></a>?‚Äù</em></p>
<p>‚Ä¶A friend and I pondered (8,000 miles apart) while working on the <a href="https://learn.sparkfun.com/tutorials/sparkfun-bme280-breakout-hookup-guide"><strong>Temperature + Humidity + Air Pressure</strong></a> combo sensor.</p>
<p>Sounds like a fun challenge‚Ä¶</p>
<ul>
<li>
<p>NuttX <strong>doesn‚Äôt have a driver</strong> for the BME280 Sensor</p>
<p>(Though it supports BMP280)</p>
</li>
<li>
<p>Can we port the BME280 Driver from <strong>Zephyr OS</strong> with a few tweaks?</p>
<p>(Spoiler: Yes we can!)</p>
</li>
<li>
<p>What‚Äôs inside a <strong>NuttX Sensor Driver</strong> anyway?</p>
<p>(How to build our own driver)</p>
</li>
<li>
<p>NuttX on BL602 is <strong>kinda new-ish</strong></p>
<p>(Some features might not work the way we expect)</p>
</li>
<li>
<p>BL602‚Äôs I2C Port has <strong>interesting quirks</strong>. Will it work?</p>
<p>(Specifically: I2C Sub Address)</p>
</li>
</ul>
<p>Read on to find out how we solved the challenge and created this driver‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bme280-nuttx"><strong>lupyuen/bme280-nuttx</strong></a></li>
</ul>
<p>(This BME280 Driver should work OK on other NuttX platforms, like ESP32)</p>
<p><img src="https://lupyuen.github.io/images/i2c-buspirate.jpg" alt="Bus Pirate connected to BME280" /></p>
<h1 id="test-and-connect-bme280" class="section-header"><a href="#test-and-connect-bme280">1 Test and Connect BME280</a></h1>
<p>Before we begin our exploration, verify that our BME280 Sensor works OK.</p>
<p>(Because we‚Äôll see some unexpected behaviour in a while)</p>
<p>We used <a href="http://dangerousprototypes.com/docs/Bus_Pirate"><strong>Bus Pirate</strong></a> (pic above) for testing our BME280 Sensor.</p>
<p><a href="https://lupyuen.github.io/articles/i2c#appendix-test-bme280-with-bus-pirate">(Here‚Äôs how)</a></p>
<p>Next we connect BME280 to Pine64‚Äôs <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 Board</strong></a>‚Ä¶</p>
<div><table><thead><tr><th align="center">BL602 Pin</th><th align="center">BME280 Pin</th><th align="left">Wire Colour</th></tr></thead><tbody>
<tr><td align="center"><strong><code>GPIO 3</code></strong></td><td align="center"><code>SDA</code></td><td align="left">Green</td></tr>
<tr><td align="center"><strong><code>GPIO 4</code></strong></td><td align="center"><code>SCL</code></td><td align="left">Blue</td></tr>
<tr><td align="center"><strong><code>3V3</code></strong></td><td align="center"><code>3.3V</code></td><td align="left">Red</td></tr>
<tr><td align="center"><strong><code>GND</code></strong></td><td align="center"><code>GND</code></td><td align="left">Black</td></tr>
</tbody></table>
</div>
<p><img src="https://lupyuen.github.io/images/bme280-title.jpg" alt="Bosch BME280 Sensor connected to Pine64 PineCone BL602 RISC-V Board" /></p>
<p>The <strong>I2C Pins</strong> on BL602 are defined here: <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/include/board.h#L85-L88">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* I2C Configuration */
#define BOARD_I2C_SCL \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN4)
#define BOARD_I2C_SDA \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN3)</code></pre></div>
<p>We disabled the <strong>UART1 Port</strong> because it uses the same pins as I2C: <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/include/board.h#L63-L68">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef TODO  /* Remember to check for duplicate pins! */
#define BOARD_UART_1_RX_PIN \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_UART | \
  GPIO_PIN3)
#define BOARD_UART_1_TX_PIN \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_UART | \
  GPIO_PIN4)
#endif  /* TODO */</code></pre></div>
<p>(UART0 is used by the Serial Console, we‚Äôll leave it as-is)</p>
<p><em>Do we need Pull-Up Resistors?</em></p>
<p>We‚Äôre using the <a href="https://learn.sparkfun.com/tutorials/sparkfun-bme280-breakout-hookup-guide/all"><strong>SparkFun BME280 Breakout Board</strong></a>, which has <strong>Pull-Up Resistors</strong>. (So we don‚Äôt need to add our own)</p>
<h1 id="start-with-bmp280-driver" class="section-header"><a href="#start-with-bmp280-driver">2 Start with BMP280 Driver</a></h1>
<p>TODO</p>
<h2 id="configure-nuttx" class="section-header"><a href="#configure-nuttx">2.1 Configure NuttX</a></h2>
<p>TODO</p>
<p>NuttX has a driver for BMP280 (Air Pressure only), let‚Äôs test it with BME280.</p>
<p>Configure NuttX to enable the I2C Character Driver, BMP280 Driver and Sensor Test App‚Ä¶</p>
<ul>
<li>System Type ‚Üí BL602 Peripheral Support ‚Üí I2C0</li>
<li>Device Drivers ‚Üí I2C Driver Support</li>
<li>Device Drivers ‚Üí I2C Driver Support ‚Üí  I2C character driver</li>
<li>Device Drivers ‚Üí Sensor Device Support</li>
<li>Device Drivers ‚Üí Sensor Device Support ‚Üí  Bosch BMP280 Barometic Pressure Sensor</li>
<li>Application Configuration ‚Üí Testing ‚Üí Sensor driver test</li>
<li>Build Setup ‚Üí Debug Options
<ul>
<li>‚Üí Enable Informational Debug Output </li>
<li>‚Üí I2C Debug Features</li>
<li>‚Üí I2C Debug Features ‚Üí  I2C Error Output</li>
<li>‚Üí I2C Debug Features ‚Üí  I2C Warnings Output</li>
<li>‚Üí I2C Debug Features ‚Üí  I2C Informational Output</li>
<li>‚Üí Sensor Debug Features</li>
<li>‚Üí Sensor Debug Features ‚Üí Sensor Error Output</li>
<li>‚Üí Sensor Debug Features ‚Üí Sensor Warnings Output</li>
<li>‚Üí Sensor Debug Features ‚Üí Sensor Informational Output </li>
</ul>
</li>
</ul>
<p><a href="https://gist.github.com/lupyuen/9d84889f5e2415ecb0f28cea2c2a657f">(See the .config for BL602)</a></p>
<p>Enable the I2C Port and I2C Character Driver on Apache #NuttX OS ‚Ä¶ So it will talk with BME280</p>
<p>TODO19</p>
<p><img src="https://lupyuen.github.io/images/bme280-config1.png" alt="" /></p>
<p>Apache #NuttX OS doesn‚Äôt have a BME280 Driver ‚Ä¶ Let‚Äôs test the BMP280 Driver instead (Air Pressure only)</p>
<p>TODO21</p>
<p><img src="https://lupyuen.github.io/images/bme280-config3.png" alt="" /></p>
<h2 id="change-i2c-address-and-device-id" class="section-header"><a href="#change-i2c-address-and-device-id">2.2 Change I2C Address and Device ID</a></h2>
<p>TODO</p>
<p>For testing, we change the I2C Address and Device ID for BME280: <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L45-L57">bmp280.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>////  Previously: I2C Address of BMP280
////  #define BMP280_ADDR         0x76

#warning Testing: I2C Address of BME280
#define BMP280_ADDR         0x77 //// BME280

////  Previously: Device ID of BMP280
////  #define DEVID               0x58

#warning Testing: Device ID of BME280
#define DEVID               0x60 //// BME280</code></pre></div>
<p>TODO1</p>
<p><img src="https://lupyuen.github.io/images/bme280-code1.png" alt="" /></p>
<h2 id="register-bmp280-driver" class="section-header"><a href="#register-bmp280-driver">2.3 Register BMP280 Driver</a></h2>
<p>TODO</p>
<p>Register BMP280 Driver at startup: <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L623-L640">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_SENSORS_BMP280
#include &lt;nuttx/sensors/bmp280.h&gt;
#endif /* CONFIG_SENSORS_BMP280 */
...
int bl602_bringup(void)
{
...
#ifdef CONFIG_SENSORS_BMP280

  /* Init I2C bus for BMP280 */

  struct i2c_master_s *bmp280_i2c_bus = bl602_i2cbus_initialize(0);
  if (!bmp280_i2c_bus)
    {
      _err(&quot;ERROR: Failed to get I2C%d interface\n&quot;, 0);
    }

  /* Register the BMP280 driver */

  ret = bmp280_register(0, bmp280_i2c_bus);
  if (ret &lt; 0)
    {
      _err(&quot;ERROR: Failed to register BMP280\n&quot;);
    }
#endif /* CONFIG_SENSORS_BMP280 */</code></pre></div>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/bme280-code2a.png" alt="" /></p>
<h2 id="invalid-device-id" class="section-header"><a href="#invalid-device-id">2.4 Invalid Device ID</a></h2>
<p>TODO</p>
<p>BMP280 Driver fails because the detected Device ID is 0 ‚Ä¶ Let‚Äôs find out why ü§î</p>
<div class="example-wrap"><pre class="language-text"><code>gpio_pin_register: Registering /dev/gpio0
gpio_pin_register: Registering /dev/gpio1
gpint_enable: Disable the interrupt
gpio_pin_register: Registering /dev/gpio2
bl602_gpio_set_intmod: ****gpio_pin=115, int_ctlmod=1, int_trgmod=0
bl602_spi_setfrequency: frequency=400000, actual=0
bl602_spi_setbits: nbits=8
bl602_spi_setmode: mode=0
spi_test_driver_register: devpath=/dev/spitest0, spidev=0
bl602_spi_select: devid: 0, CS: free
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
bmp280_checkid: devid: 0x00
bmp280_checkid: Wrong Device ID! 00
bmp280_register: Failed to register driver: -19
bl602_bringup: ERROR: Failed to register BMP280

NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt;</code></pre></div>
<p><img src="https://lupyuen.github.io/images/bme280-run1.png" alt="" /></p>
<h2 id="invalid-register-id" class="section-header"><a href="#invalid-register-id">2.5 Invalid Register ID</a></h2>
<p>TODO</p>
<p>Logic Analyser shows that BL602 sent the wrong Register ID to BME280.</p>
<p>To read the Device ID, the Register ID should be <code>0xD0</code>, not <code>0x00</code>.  Let‚Äôs fix this ü§î</p>
<div class="example-wrap"><pre class="language-text"><code>Write [0xEE]
0x00 + ACK (Register ID is 0x00)
Read [0xEF]
0x00 + NAK (No Acknowledgement, because Register ID is incorrect)</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/i2c#appendix-test-bme280-with-bus-pirate">(Here‚Äôs why Register ID should be <code>0xD0</code>)</a></p>
<p>TODO23</p>
<p><img src="https://lupyuen.github.io/images/bme280-logic1.png" alt="" /></p>
<p>Here‚Äôs how we connected our Logic Analyser to PineCone #BL602 ‚Ä¶ For testing the #NuttX BMP280 Driver</p>
<p>TODO50</p>
<p><img src="https://lupyuen.github.io/images/bme280-logic2.jpg" alt="" /></p>
<h2 id="log-i2c-transfers" class="section-header"><a href="#log-i2c-transfers">2.6 Log I2C Transfers</a></h2>
<p>TODO</p>
<p>BL602 NuttX I2C Driver doesn‚Äôt log the data transferred ‚Ä¶ Let‚Äôs log ourselves: <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/arch/risc-v/src/bl602/bl602_i2c.c#L194-L197">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static void bl602_i2c_send_data(struct bl602_i2c_priv_s *priv)
{
  ...
  putreg32(temp, BL602_I2C_FIFO_WDATA);
  priv-&gt;bytes += count;
  i2cinfo(&quot;count=%d, temp=0x%x\n&quot;, count, temp); ////
}</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/arch/risc-v/src/bl602/bl602_i2c.c#L207-L216">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static void bl602_i2c_recvdata(struct bl602_i2c_priv_s *priv)
{
  ...
  count = msg-&gt;length - priv-&gt;bytes;
  temp  = getreg32(BL602_I2C_FIFO_RDATA);
  i2cinfo(&quot;count=%d, temp=0x%x\n&quot;, count, temp); ////</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/arch/risc-v/src/bl602/bl602_i2c.c#L740-L742">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int bl602_i2c_transfer(struct i2c_master_s *dev,
                              struct i2c_msg_s *   msgs,
                              int                      count)
{
  ...
  for (i = 0; i &lt; count; i++)
    {
      ...
      priv-&gt;msgid = i;
      i2cinfo(&quot;subflag=%d, subaddr=0x%x, sublen=%d\n&quot;, priv-&gt;subflag, priv-&gt;subaddr, priv-&gt;sublen); ////
      bl602_i2c_start_transfer(priv);</code></pre></div>
<p>TODO3</p>
<p><img src="https://lupyuen.github.io/images/bme280-code3a.png" alt="" /></p>
<h2 id="set-i2c-sub-address" class="section-header"><a href="#set-i2c-sub-address">2.7 Set I2C Sub Address</a></h2>
<p>TODO</p>
<p>BL602 has a peculiar I2C Port ‚Ä¶ We need to send the I2C Sub Address (Register ID) separately from the I2C Data ‚Ä¶ This might cause the BMP280 Driver to fail</p>
<p>TODO34</p>
<p><img src="https://lupyuen.github.io/images/bme280-subaddress.png" alt="" /></p>
<p><a href="https://lupyuen.github.io/articles/i2c#set-i2c-device-address-and-register-address">(Source)</a></p>
<p>BL602 NuttX I2C Driver needs us to provide the I2C Sub Address (Register ID): <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/arch/risc-v/src/bl602/bl602_i2c.c#L719-L738">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>      /* if msgs[i].flag I2C_M_NOSTOP,means start i2c with subddr */

      if (msgs[i].flags &amp; I2C_M_NOSTOP)
        {
          priv-&gt;subflag = 1;
          priv-&gt;subaddr = 0;
          for (j = 0; j &lt; msgs[i].length; j++)
            {
              priv-&gt;subaddr += msgs[i].buffer[j] &lt;&lt; (j * 8);
            }

          priv-&gt;sublen = msgs[i].length;
          i++;
        }
      else
        {
          priv-&gt;subflag = 0;
          priv-&gt;subaddr = 0;
          priv-&gt;sublen  = 0;
        }</code></pre></div>
<p>TODO4</p>
<p><img src="https://lupyuen.github.io/images/bme280-code4a.png" alt="" /></p>
<p>Here‚Äôs how we patch the NuttX BMP280 Driver to send the Register ID as I2C Sub Address (instead of I2C Data): <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L202-L217">bmp280.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static uint8_t bmp280_getreg8(FAR struct bmp280_dev_s *priv, uint8_t regaddr)
{
  ...
  //// Previously:
  //// msg[0].flags     = 0;

  #warning Testing: I2C_M_NOSTOP for I2C Sub Address
  msg[0].flags     = I2C_M_NOSTOP;  ////  Testing I2C Sub Address

  msg[0].buffer    = &amp;regaddr;
  msg[0].length    = 1;</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L244-L257">bmp280.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int bmp280_getregs(FAR struct bmp280_dev_s *priv, uint8_t regaddr,
                          uint8_t *rxbuffer, uint8_t length)
{
  ...
  msg[0].frequency = priv-&gt;freq;
  msg[0].addr      = priv-&gt;addr;

  //// Previously:
  //// msg[0].flags     = 0;

  #warning Testing: I2C_M_NOSTOP for I2C Sub Address
  msg[0].flags     = I2C_M_NOSTOP;  ////  Testing I2C Sub Address

  msg[0].buffer    = &amp;regaddr;
  msg[0].length    = 1;</code></pre></div>
<p>TODO5</p>
<p><img src="https://lupyuen.github.io/images/bme280-code5a.png" alt="" /></p>
<p>We don‚Äôt need to set the I2C Sub Address when writing registers‚Ä¶</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L286-L300">bmp280.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int bmp280_putreg8(FAR struct bmp280_dev_s *priv, uint8_t regaddr,
                          uint8_t regval)
{
  ...
  txbuffer[0] = regaddr;
  txbuffer[1] = regval;

  msg[0].frequency = priv-&gt;freq;
  msg[0].addr      = priv-&gt;addr;
  msg[0].flags     = 0;
  msg[0].buffer    = txbuffer;
  msg[0].length    = 2;</code></pre></div><h2 id="bmp280-driver-loads-ok" class="section-header"><a href="#bmp280-driver-loads-ok">2.8 BMP280 Driver Loads OK</a></h2>
<p>TODO</p>
<p>NuttX BMP280 Driver loads OK on BL602 ‚Ä¶ After setting the Register ID as I2C Sub Address! üéâ</p>
<p>NuttX BMP280 Driver appears as ‚Äú/dev/sensor/baro0‚Äù</p>
<div class="example-wrap"><pre class="language-text"><code>gpio_pin_register: Registering /dev/gpio0
gpio_pin_register: Registering /dev/gpio1
gpint_enable: Disable the interrupt
gpio_pin_register: Registering /dev/gpio2
bl602_gpio_set_intmod: ****gpio_pin=115, int_ctlmod=1, int_trgmod=0
bl602_spi_setfrequency: frequency=400000, actual=0
bl602_spi_setbits: nbits=8
bl602_spi_setmode: mode=0
spi_test_driver_register: devpath=/dev/spitest0, spidev=0
bl602_spi_select: devid: 0, CS: free

bmp280_getreg8: regaddr=0xd0
bl602_i2c_transfer: subflag=1, subaddr=0xd0, sublen=1
bl602_i2c_recvdata: count=1, temp=0x60
bl602_i2c_transfer: i2c transfer success
bmp280_getreg8: regaddr=0xd0, regval=0x60
bmp280_checkid: devid: 0x60

bmp280_getregs: regaddr=0x88, length=24
bl602_i2c_transfer: subflag=1, subaddr=0x88, sublen=1
bl602_i2c_recvdata: count=24, temp=0x65e66e97
bl602_i2c_recvdata: count=20, temp=0x8f990032
bl602_i2c_recvdata: count=16, temp=0xbd0d581
bl602_i2c_recvdata: count=12, temp=0xffdb1e71
bl602_i2c_recvdata: count=8, temp=0x26acfff9
bl602_i2c_transfer: i2c transfer success

bmp280_initialize: T1 = 28311
bmp280_initialize: T2 = 26086
bmp280_initialize: T3 = 50
bmp280_initialize: P1 = 36761
bmp280_initialize: P2 = -10879
bmp280_initialize: P3 = 3024
bmp280_initialize: P4 = 7793
bmp280_initialize: P5 = -37
bmp280_initialize: P6 = -7
bmp280_initialize: P7 = 9900
bmp280_initialize: P8 = 15288
bmp280_initialize: P9 = 8964

bmp280_putreg8: regaddr=0xf4, regval=0x00
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0xf4
bl602_i2c_transfer: i2c transfer success

bmp280_getreg8: regaddr=0xf5
bl602_i2c_transfer: subflag=1, subaddr=0xf5, sublen=1
bl602_i2c_recvdata: count=1, temp=0x10bdd800
bl602_i2c_transfer: i2c transfer success
bmp280_getreg8: regaddr=0xf5, regval=0x00

bmp280_putreg8: regaddr=0xf5, regval=0x00
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0xf5
bl602_i2c_transfer: i2c transfer success

bmp280_getreg8: regaddr=0xf5
bl602_i2c_transfer: subflag=1, subaddr=0xf5, sublen=1
bl602_i2c_recvdata: count=1, temp=0x10bdd800
bl602_i2c_transfer: i2c transfer success
bmp280_getreg8: regaddr=0xf5, regval=0x00

sensor_custom_register: Registering /dev/sensor/baro0
bmp280_register: BMP280 driver loaded successfully!

NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt;
nsh&gt; ls /dev
/dev:
 console
 gpio0
 gpio1
 gpio2
 i2c0
 null
 sensor/
 spi0
 spitest0
 timer0
 urandom
 zero
nsh&gt; ls /dev/sensor
/dev/sensor:
 baro0
nsh&gt;</code></pre></div>
<p>TODO27</p>
<p><img src="https://lupyuen.github.io/images/bme280-run2a.png" alt="" /></p>
<p>#NuttX BMP280 Driver appears as ‚Äú/dev/sensor/baro0‚Äù ‚Ä¶ Let‚Äôs read the device</p>
<p>TODO29</p>
<p><img src="https://lupyuen.github.io/images/bme280-run4a.png" alt="" /></p>
<h2 id="run-sensor-test-app" class="section-header"><a href="#run-sensor-test-app">2.9 Run Sensor Test App</a></h2>
<p>TODO</p>
<p>Let‚Äôs run the NuttX Sensor Test App to read the sensor values from ‚Äú/dev/sensor/baro0‚Äù‚Ä¶</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/bme280/testing/sensortest/sensortest.c">testing/sensortest/sensortest.c</a></p>
<p>Configure NuttX to enable the Sensor Test App‚Ä¶</p>
<ul>
<li>Application Configuration ‚Üí Testing ‚Üí Sensor driver test</li>
</ul>
<p><a href="https://gist.github.com/lupyuen/9d84889f5e2415ecb0f28cea2c2a657f">(See the .config for BL602)</a></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/bme280-config4a.png" alt="" /></p>
<p>Read 10 sensor values from ‚Äú/dev/sensor/baro0‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; sensortest -n 10 baro0
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:1006.21 value2:30.78
baro0: timestamp:30690000 value1:1006.21 value2:30.78
SensorTest: Received message: baro0, number:10/10
bl602_i2c_transfer: i2c transfer error, event = 4

nsh&gt; sensortest -n 10 baro0
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
baro0: timestamp:61290000 value1:1006.27 value2:30.80
baro0: timestamp:61300000 value1:1006.27 value2:30.80
baro0: timestamp:61300000 value1:1006.27 value2:30.80
baro0: timestamp:61300000 value1:1006.27 value2:30.80
baro0: timestamp:61300000 value1:1006.27 value2:30.80
baro0: timestamp:61300000 value1:1006.27 value2:30.80
baro0: timestamp:61300000 value1:1006.27 value2:30.80
baro0: timestamp:61300000 value1:1006.27 value2:30.80
baro0: timestamp:61310000 value1:1006.27 value2:30.80
baro0: timestamp:61310000 value1:1006.27 value2:30.80
SensorTest: Received message: baro0, number:10/10
bl602_i2c_transfer: i2c transfer error, event = 4

nsh&gt; sensortest -n 10 baro0
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
baro0: timestamp:79360000 value1:1006.22 value2:30.80
baro0: timestamp:79360000 value1:1006.22 value2:30.80
baro0: timestamp:79360000 value1:1006.22 value2:30.80
baro0: timestamp:79370000 value1:1006.22 value2:30.80
baro0: timestamp:79370000 value1:1006.22 value2:30.80
baro0: timestamp:79370000 value1:1006.22 value2:30.80
baro0: timestamp:79370000 value1:1006.22 value2:30.80
baro0: timestamp:79370000 value1:1006.22 value2:30.80
baro0: timestamp:79370000 value1:1006.22 value2:30.80
baro0: timestamp:79370000 value1:1006.22 value2:30.80
SensorTest: Received message: baro0, number:10/10

nsh&gt; sensortest -n 10 baro0
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
baro0: timestamp:82370000 value1:1006.30 value2:30.81
baro0: timestamp:82370000 value1:1006.30 value2:30.81
baro0: timestamp:82380000 value1:1006.30 value2:30.81
baro0: timestamp:82380000 value1:1006.30 value2:30.81
baro0: timestamp:82380000 value1:1006.30 value2:30.81
baro0: timestamp:82380000 value1:1006.30 value2:30.81
baro0: timestamp:82380000 value1:1006.30 value2:30.81
baro0: timestamp:82380000 value1:1006.30 value2:30.81
baro0: timestamp:82380000 value1:1006.30 value2:30.81
baro0: timestamp:82380000 value1:1006.30 value2:30.81
SensorTest: Received message: baro0, number:10/10

nsh&gt; sensortest -n 10 baro0
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
baro0: timestamp:83950000 value1:1006.30 value2:30.79
baro0: timestamp:83950000 value1:1006.30 value2:30.79
baro0: timestamp:83950000 value1:1006.30 value2:30.79
baro0: timestamp:83960000 value1:1006.30 value2:30.79
baro0: timestamp:83960000 value1:1006.30 value2:30.79
baro0: timestamp:83960000 value1:1006.30 value2:30.79
baro0: timestamp:83960000 value1:1006.30 value2:30.79
baro0: timestamp:83960000 value1:1006.30 value2:30.79
baro0: timestamp:83960000 value1:1006.30 value2:30.79
baro0: timestamp:83960000 value1:1006.30 value2:30.79
SensorTest: Received message: baro0, number:10/10

nsh&gt; sensortest -n 10 baro0
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
baro0: timestamp:85310000 value1:1006.24 value2:30.80
baro0: timestamp:85310000 value1:1006.24 value2:30.80
baro0: timestamp:85320000 value1:1006.24 value2:30.80
baro0: timestamp:85320000 value1:1006.24 value2:30.80
baro0: timestamp:85320000 value1:1006.24 value2:30.80
baro0: timestamp:85320000 value1:1006.24 value2:30.80
baro0: timestamp:85320000 value1:1006.24 value2:30.80
baro0: timestamp:85320000 value1:1006.24 value2:30.80
baro0: timestamp:85320000 value1:1006.24 value2:30.80
baro0: timestamp:85320000 value1:1006.24 value2:30.80
SensorTest: Received message: baro0, number:10/10
nsh&gt;</code></pre></div>
<p>That‚Äôs 1006.24 millibar and 30.8 ¬∞C. Yep that looks reasonable for Sunny Singapore by the Seaside üëç</p>
<p>(Air Pressue at Sea Level is 1013.25 millibar)</p>
<p>TODO30</p>
<p><img src="https://lupyuen.github.io/images/bme280-run5a.png" alt="" /></p>
<p>Detailed log‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; sensortest -n 10 baro0

sensor_ioctl: cmd=a81 arg=4201c384
bmp280_getreg8: regaddr=0xf5
bl602_i2c_transfer: subflag=1, subaddr=0xf5, sublen=1
bl602_i2c_recvdata: count=1, temp=0x10bdd800
bl602_i2c_transfer: i2c transfer success
bmp280_getreg8: regaddr=0xf5, regval=0x00

bmp280_putreg8: regaddr=0xf5, regval=0xa0
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0xa0f5
bl602_i2c_transfer: i2c transfer success

bmp280_getreg8: regaddr=0xf5
bl602_i2c_transfer: subflag=1, subaddr=0xf5, sublen=1
bl602_i2c_recvdata: count=1, temp=0x10bdd8a0
bl602_i2c_transfer: i2c transfer success
bmp280_getreg8: regaddr=0xf5, regval=0xa0

sensor_ioctl: cmd=a82 arg=4201c388
sensor_ioctl: cmd=a80 arg=00000001
bmp280_putreg8: regaddr=0xf4, regval=0x2f
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0x2ff4
bl602_i2c_transfer: i2c transfer success

SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bmp280_getregs: regaddr=0xf7, length=6
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=6, temp=0x80000080
bl602_i2c_recvdata: count=2, temp=0x80000000
bl602_i2c_transfer: i2c transfer success
bmp280_fetch: press = 524288, temp = 524288
baro0: timestamp:20540000 value1:714.07 value2:22.18

sensor_pollnotify: Report events: 01
bmp280_getregs: regaddr=0xf7, length=6
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=6, temp=0x80000080
bl602_i2c_recvdata: count=2, temp=0x80000000
bl602_i2c_transfer: i2c transfer success
bmp280_fetch: press = 524288, temp = 524288
baro0: timestamp:20550000 value1:714.07 value2:22.18

sensor_pollnotify: Report events: 01
bmp280_getregs: regaddr=0xf7, length=6
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=6, temp=0x80000080
bl602_i2c_recvdata: count=2, temp=0x80000000
bl602_i2c_transfer: i2c transfer success
bmp280_fetch: press = 524288, temp = 524288
baro0: timestamp:20550000 value1:714.07 value2:22.18

sensor_pollnotify: Report events: 01
bmp280_getregs: regaddr=0xf7, length=6
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=6, temp=0x80000080
bl602_i2c_recvdata: count=2, temp=0x80000000
bl602_i2c_transfer: i2c transfer success
bmp280_fetch: press = 524288, temp = 524288
baro0: timestamp:20550000 value1:714.07 value2:22.18

sensor_pollnotify: Report events: 01
bmp280_getregs: regaddr=0xf7, length=6
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=6, temp=0x86401752
bl602_i2c_recvdata: count=2, temp=0x86400035
bl602_i2c_transfer: i2c transfer success
bmp280_fetch: press = 336244, temp = 549712
baro0: timestamp:20550000 value1:1069.51 value2:30.09

sensor_pollnotify: Report events: 01
bmp280_getregs: regaddr=0xf7, length=6
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=6, temp=0x86401752
bl602_i2c_recvdata: count=2, temp=0x86400035
bl602_i2c_transfer: i2c transfer success
bmp280_fetch: press = 336244, temp = 549712
baro0: timestamp:20560000 value1:1069.51 value2:30.09

sensor_pollnotify: Report events: 01
bmp280_getregs: regaddr=0xf7, length=6
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=6, temp=0x86401752
bl602_i2c_recvdata: count=2, temp=0x86400035
bl602_i2c_transfer: i2c transfer success
bmp280_fetch: press = 336244, temp = 549712
baro0: timestamp:20560000 value1:1069.51 value2:30.09

sensor_pollnotify: Report events: 01
bmp280_getregs: regaddr=0xf7, length=6
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=6, temp=0x86401752
bl602_i2c_recvdata: count=2, temp=0x86400035
bl602_i2c_transfer: i2c transfer success
bmp280_fetch: press = 336244, temp = 549712
baro0: timestamp:20560000 value1:1069.51 value2:30.09

sensor_pollnotify: Report events: 01
bmp280_getregs: regaddr=0xf7, length=6
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=6, temp=0x86401752
bl602_i2c_recvdata: count=2, temp=0x86400035
bl602_i2c_transfer: i2c transfer success
bmp280_fetch: press = 336244, temp = 549712
baro0: timestamp:20560000 value1:1069.51 value2:30.09

sensor_pollnotify: Report events: 01
bmp280_getregs: regaddr=0xf7, length=6
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=6, temp=0x86401752
bl602_i2c_recvdata: count=2, temp=0x86400035
bl602_i2c_transfer: i2c transfer success
bmp280_fetch: press = 336244, temp = 549712
baro0: timestamp:20570000 value1:1069.51 value2:30.09

SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bmp280_putreg8: regaddr=0xf4, regval=0x00
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0xf4
bl602_i2c_transfer: i2c transfer success
nsh&gt;</code></pre></div>
<p>This shows that writing to I2C Registers works OK‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code># Register F5 has value 00
bmp280_getreg8: regaddr=0xf5, regval=0x00
...
# Set Register F5 to value A0
bmp280_putreg8: regaddr=0xf5, regval=0xa0
...
# Register F5 now has value A0
bmp280_getreg8: regaddr=0xf5, regval=0xa0</code></pre></div>
<p>Yep the NuttX BMP280 Driver works OK! Now let‚Äôs port the BME280 Driver from Zephyr OS to NuttX, so we can get the humidity.</p>
<h1 id="port-bme280-driver-from-zephyr-os" class="section-header"><a href="#port-bme280-driver-from-zephyr-os">3 Port BME280 Driver from Zephyr OS</a></h1>
<p>TODO</p>
<p>NuttX BMP280 Driver works OK with our BME280 Sensor ‚Ä¶ But we‚Äôre missing one thing: Humidity ‚Ä¶ Can we port the BME280 Driver from Zephyr OS? ü§î</p>
<p><a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/sensor/bme280/bme280.c">zephyr/drivers/sensor/bme280/bme280.c</a></p>
<p>Zephyr BME280 Driver looks similar to <a href="https://github.com/apache/incubator-nuttx/blob/master/drivers/sensors/bmp280.c">NuttX BMP280 Driver</a> ‚Ä¶ So porting Zephyr BME280 Driver to NuttX might not be so hard ü§î</p>
<p><code>bme280_sample_fetch</code> and <code>bme280_channel_get</code> are explained in the Zephyr Sensor API:</p>
<p><a href="https://docs.zephyrproject.org/latest/reference/peripherals/sensor.html">Zephyr Sensor API</a></p>
<p>TODO35</p>
<p><img src="https://lupyuen.github.io/images/bme280-zephyr1.png" alt="" /></p>
<p>Zephyr BME280 Driver looks similar to #NuttX BMP280 Driver ‚Ä¶ So porting Zephyr BME280 Driver to NuttX might not be so hard ü§î</p>
<p>TODO6</p>
<p><img src="https://lupyuen.github.io/images/bme280-code6a.png" alt="" /></p>
<h2 id="wrap-zephyr-driver-as-nuttx-driver" class="section-header"><a href="#wrap-zephyr-driver-as-nuttx-driver">3.1 Wrap Zephyr Driver as NuttX Driver</a></h2>
<p>TODO</p>
<p>Zephyr BME280 Driver builds OK on #NuttX (with a few tweaks) üéâ </p>
<p>TODO7</p>
<p><img src="https://lupyuen.github.io/images/bme280-code7a.png" alt="" /></p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c">(Source)</a></p>
<p>Now we wrap the Zephyr Driver as a NuttX Driver‚Ä¶</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c">(Source)</a></p>
<p>Our NuttX Driver Wrapper wraps around the Zephyr BME280 Driver ‚Ä¶ So it works like a NuttX Driver: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L349-L424">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int bme280_fetch(FAR struct sensor_lowerhalf_s *lower,
                        FAR char *buffer, size_t buflen)
{
  sninfo(&quot;buflen=%d\n&quot;, buflen);
  FAR struct device *priv = container_of(lower,
                                               FAR struct device,
                                               sensor_lower);

  int ret;
  struct timespec ts;
  struct sensor_event_baro baro_data;
  struct sensor_value val;

  if (buflen != sizeof(baro_data))
    {
      return -EINVAL;
    }

  /* Zephyr BME280 Driver assumes that sensor is not in sleep mode */
  if (!priv-&gt;activated)
    {
      snerr(&quot;Device must be active before fetch\n&quot;);
      return -EIO;
    }

  /* Fetch the sensor data (from Zephyr BME280 Driver) */

  ret = bme280_sample_fetch(priv, SENSOR_CHAN_ALL);
  if (ret &lt; 0)
    {
      return ret;
    }

  /* Get the temperature (from Zephyr BME280 Driver) */

  ret = bme280_channel_get(priv, SENSOR_CHAN_AMBIENT_TEMP, &amp;val);
  if (ret &lt; 0)
    {
      return ret;
    }
  baro_data.temperature = get_sensor_value(&amp;val);

  /* Get the pressure (from Zephyr BME280 Driver) */

  ret = bme280_channel_get(priv, SENSOR_CHAN_PRESS, &amp;val);
  if (ret &lt; 0)
    {
      return ret;
    }
  baro_data.pressure = get_sensor_value(&amp;val) * 10;

  /* Get the humidity (from Zephyr BME280 Driver) */

  ret = bme280_channel_get(priv, SENSOR_CHAN_HUMIDITY, &amp;val);
  if (ret &lt; 0)
    {
      return ret;
    }
  float humidity = get_sensor_value(&amp;val);

  /* Get the timestamp */
  
#ifdef CONFIG_CLOCK_MONOTONIC
  clock_gettime(CLOCK_MONOTONIC, &amp;ts);
#else
  clock_gettime(CLOCK_REALTIME, &amp;ts);
#endif
  baro_data.timestamp = 1000000ull * ts.tv_sec + ts.tv_nsec / 1000;

  /* Return the sensor data */

  memcpy(buffer, &amp;baro_data, sizeof(baro_data));
  sninfo(&quot;temperature=%f ¬∞C, pressure=%f mbar, humidity=%f %%\n&quot;, baro_data.temperature, baro_data.pressure, humidity);

  return buflen;
}</code></pre></div>
<p>TODO8</p>
<p><img src="https://lupyuen.github.io/images/bme280-code8a.png" alt="" /></p>
<h2 id="read-sensor-data-from-zephyr-driver" class="section-header"><a href="#read-sensor-data-from-zephyr-driver">3.2 Read Sensor Data from Zephyr Driver</a></h2>
<p>TODO</p>
<p>Our NuttX BME280 Driver reads the Sensor Data from Zephyr Driver in two steps: 1Ô∏è‚É£ Fetch the sensor sample 2Ô∏è‚É£ Get the channel data</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L374-L421">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>  /* Fetch the sensor data (from Zephyr BME280 Driver) */

  ret = bme280_sample_fetch(priv, SENSOR_CHAN_ALL);
  if (ret &lt; 0)
    {
      return ret;
    }

  /* Get the temperature (from Zephyr BME280 Driver) */

  ret = bme280_channel_get(priv, SENSOR_CHAN_AMBIENT_TEMP, &amp;val);
  if (ret &lt; 0)
    {
      return ret;
    }
  baro_data.temperature = get_sensor_value(&amp;val);

  /* Get the pressure (from Zephyr BME280 Driver) */

  ret = bme280_channel_get(priv, SENSOR_CHAN_PRESS, &amp;val);
  if (ret &lt; 0)
    {
      return ret;
    }
  baro_data.pressure = get_sensor_value(&amp;val) * 10;

  /* Get the humidity (from Zephyr BME280 Driver) */

  ret = bme280_channel_get(priv, SENSOR_CHAN_HUMIDITY, &amp;val);
  if (ret &lt; 0)
    {
      return ret;
    }
  float humidity = get_sensor_value(&amp;val);

  /* Get the timestamp */
  
#ifdef CONFIG_CLOCK_MONOTONIC
  clock_gettime(CLOCK_MONOTONIC, &amp;ts);
#else
  clock_gettime(CLOCK_REALTIME, &amp;ts);
#endif
  baro_data.timestamp = 1000000ull * ts.tv_sec + ts.tv_nsec / 1000;

  /* Return the sensor data */

  memcpy(buffer, &amp;baro_data, sizeof(baro_data));
  sninfo(&quot;temperature=%f ¬∞C, pressure=%f mbar, humidity=%f %%\n&quot;, baro_data.temperature, baro_data.pressure, humidity);</code></pre></div>
<p>TODO9</p>
<p><img src="https://lupyuen.github.io/images/bme280-code9a.png" alt="" /></p>
<h2 id="power-management" class="section-header"><a href="#power-management">3.3 Power Management</a></h2>
<p>TODO</p>
<p>Power Management works a little differently in NuttX vs Zephyr ‚Ä¶ Here‚Äôs how our NuttX BME280 Driver calls the Zephyr Driver to do Power Management: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L315-L343">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int bme280_activate(FAR struct sensor_lowerhalf_s *lower,
                           bool enable)
{
  sninfo(&quot;enable=%d\n&quot;, enable);
  int ret = 0;

  FAR struct device *priv = container_of(lower,
                                               FAR struct device,
                                               sensor_lower);
  if (enable)
    {
      /* Set power mode to normal */

      ret = bme280_pm_action(priv, PM_DEVICE_ACTION_RESUME);
    }
  else
    {
      /* Set to sleep mode */

      ret = bme280_pm_action(priv, PM_DEVICE_ACTION_SUSPEND);
    }

  if (ret &gt;= 0)
    {
      priv-&gt;activated = enable;
    }

  return ret;
}</code></pre></div>
<p>TODO10</p>
<p><img src="https://lupyuen.github.io/images/bme280-code10.png" alt="" /></p>
<h2 id="standby-duration" class="section-header"><a href="#standby-duration">3.4 Standby Duration</a></h2>
<p>TODO</p>
<p>BME280 Standby Duration is static in Zephyr but configured at runtime in NuttX ‚Ä¶ So we set it in our NuttX BME280 Driver: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L217-L255">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int bme280_set_standby(FAR struct device *priv, uint8_t value)
{
  sninfo(&quot;value=%d\n&quot;, value);
  
  uint8_t v_data_u8;
  uint8_t v_sb_u8;
  int ret;

  /* Set the standby duration value */

  ret = bme280_reg_read(priv, BME280_REG_CONFIG, &amp;v_data_u8, 1);
  if (ret &lt; 0)
    {
      return ret;
    }
  v_data_u8 = (v_data_u8 &amp; ~(0x07 &lt;&lt; 5)) | (value &lt;&lt; 5);
  ret = bme280_reg_write(priv, BME280_REG_CONFIG, v_data_u8);
  if (ret &lt; 0)
    {
      return ret;
    }

  /* Check the standby duration value */

  ret = bme280_reg_read(priv, BME280_REG_CONFIG, &amp;v_data_u8, 1);
  if (ret &lt; 0)
    {
      return ret;
    }
  v_sb_u8 = (v_data_u8 &gt;&gt; 5) &amp; 0x07;

  if (v_sb_u8 != value)
    {
      snerr(&quot;Failed to set value for standby time.&quot;);
      return ERROR;
    }

  return OK;
}</code></pre></div>
<p>TODO11</p>
<p><img src="https://lupyuen.github.io/images/bme280-code11.png" alt="" /></p>
<h2 id="zephyr-driver-modified-for-nuttx" class="section-header"><a href="#zephyr-driver-modified-for-nuttx">3.5 Zephyr Driver Modified For NuttX</a></h2>
<p>TODO</p>
<p>Here are the minor modifications we made to the Zephyr BME280 Driver while porting to NuttX‚Ä¶</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/pull/1/files#diff-80464162211b7180f107757b7aee91398cdc088e5775ffadf7e6e1f0bbb4ad65">bme280.c</a></p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/pull/1/files#diff-e13ff0ab44de7ead31a3dd6cbbbbf2a6fbfb2f04889300993b87ff5a31ffc233">bme280.h</a></p>
<p>The above files are wrapped by <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c">bundle.c</a> and <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.h">bundle.h</a> to become a NuttX Driver.</p>
<p>TODO12</p>
<p><img src="https://lupyuen.github.io/images/bme280-code12.png" alt="" /></p>
<h2 id="output-log" class="section-header"><a href="#output-log">3.6 Output Log</a></h2>
<p>TODO</p>
<p>Zephyr BME280 Driver ported to Apache #NuttX OS ‚Ä¶ Works great on NuttX! üéâ</p>
<div class="example-wrap"><pre class="language-text"><code>spi_test_driver_register: devpath=/dev/spitest0, spidev=0
bme280_register: devno=0
bme280_reg_read: start=0xd0, size=1
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: &quot;BME280&quot; OK
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
sensor_custom_register: Registering /dev/sensor/baro0
bme280_register: BME280 driver loaded successfully!

NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt; sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: period_us=1107411860
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: enable=1
bme280_reg_read: start=0xd0, size=1
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: &quot;BME280&quot; OK
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21140000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21160000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21180000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21200000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21220000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21240000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21260000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21280000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21300000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21320000 value1:1010.60 value2:29.62
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: enable=0
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4

nsh&gt; sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: period_us=1107411860
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: enable=1
bme280_reg_read: start=0xd0, size=1
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: &quot;BME280&quot; OK
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25440000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25460000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25480000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25500000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25520000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25540000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25560000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25580000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25600000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25620000 value1:1010.60 value2:29.65
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: enable=0
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: 2c transfer error, event = 4

nsh&gt; sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: period_us=1107411860
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: enable=1
bme280_reg_read: start=0xd0, size=1
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: &quot;BME280&quot; OK
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27510000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27530000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27550000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27570000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27590000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27610000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27630000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27650000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27670000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27690000 value1:1010.58 value2:29.66
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: enable=0
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
nsh&gt;</code></pre></div>
<p>Detailed Log:</p>
<div class="example-wrap"><pre class="language-text"><code>gpio_pin_register: Registering /dev/gpio0
gpio_pin_register: Registering /dev/gpio1
gpint_enable: Disable the interrupt
gpio_pin_register: Registering /dev/gpio2
bl602_gpio_set_intmod: ****gpio_pin=115, int_ctlmod=1, int_trgmod=0
bl602_spi_setfrequency: frequency=400000, actual=0
bl602_spi_setbits: nbits=8
bl602_spi_setmode: mode=0
spi_test_driver_register: devpath=/dev/spitest0, spidev=0
bl602_spi_select: devid: 0, CS: free
bme280_reg_read: start=0xd0, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xd0, sublen=1
bl602_i2c_recvdata: count=1, temp=0x60
bl602_i2c_transfer: i2c transfer success
bme280_chip_init: ID OKbme280_reg_write: reg=0xe0, val=0xb6
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0xb6e0
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x0
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0x88, size=24
bl602_i2c_transfer: subflag=1, subaddr=0x88, sublen=1
bl602_i2c_recvdata: count=24, temp=0x65e66e97
bl602_i2c_recvdata: count=20, temp=0x8f990032
bl602_i2c_recvdata: count=16, temp=0xbd0d581
bl602_i2c_recvdata: count=12, temp=0xffdb1e71
bl602_i2c_recvdata: count=8, temp=0x26acfff9
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xa1, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xa1, sublen=1
bl602_i2c_recvdata: count=1, temp=0x10bdd84b
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xe1, size=7
bl602_i2c_transfer: subflag=1, subaddr=0xe1, sublen=1
bl602_i2c_recvdata: count=7, temp=0x14000165
bl602_i2c_recvdata: count=3, temp=0x141e000b
bl602_i2c_transfer: i2c transfer success
bme280_reg_write: reg=0xf2, val=0x05
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0x5f2
bl602_i2c_transfer: i2c transfer success
bme280_reg_write: reg=0xf4, val=0x57
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0x57f4
bl602_i2c_transfer: i2c transfer success
bme280_reg_write: reg=0xf5, val=0xa8
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0xa8f5
bl602_i2c_transfer: i2c transfer success
bme280_chip_init: &quot;BME280&quot; OKsensor_custom_register: Registering /dev/sensor/baro0
bme280_register: BME280 driver loaded successfully!

NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt; sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: TODO period_us=1107411860
bme280_set_standby: TODO value=5
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: TODO enable=1
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x141e0000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38390000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38410000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38430000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38450000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38470000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38490000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38510000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38530000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38550000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38570000 value1:106.94 value2:30.11
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: TODO enable=0

nsh&gt; sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: TODO period_us=1107411860
bme280_set_standby: TODO value=5
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: TODO enable=1
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47120000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_trasfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47140000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47160000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47180000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47200000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47220000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47240000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2crecvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47260000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47280000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, ublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47300000 value1:106.94 value2:30.12
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: TODO enable=0
nsh&gt;</code></pre></div>
<p>TODO32</p>
<p><img src="https://lupyuen.github.io/images/bme280-run6a.png" alt="" /></p>
<h1 id="combined-barometer-and-humidity-sensor" class="section-header"><a href="#combined-barometer-and-humidity-sensor">4 Combined Barometer and Humidity Sensor</a></h1>
<p>TODO</p>
<p>NuttX doesn‚Äôt have a Sensor Type that supports BME280 Temperature + Humidity + Pressure ‚Ä¶ So our NuttX BME280 Driver combines 2 Sensor Types: 1Ô∏è‚É£ Barometer Sensor (Pressure + Temperature) 2Ô∏è‚É£ Humidity Sensor</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/device.h#L36-L49">device.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* NuttX Device for BME280 */

struct device
{
  FAR struct sensor_lowerhalf_s sensor_baro;  /* Barometer and Temperature Sensor */
  FAR struct sensor_lowerhalf_s sensor_humi;  /* Humidity Sensor */
  FAR struct i2c_master_s *i2c; /* I2C interface */
  uint8_t addr;                 /* BME280 I2C address */
  int freq;                     /* BME280 Frequency &lt;= 3.4MHz */
  bool activated;               /* True if device is not in sleep mode */

  char *name;                   /* Name of the device */
  struct bme280_data *data;     /* Compensation parameters (bme280.c) */
};</code></pre></div>
<p>TODO14</p>
<p><img src="https://lupyuen.github.io/images/bme280-combine1.png" alt="" /></p>
<p>Each NuttX Sensor defines its operations for 1Ô∏è‚É£ Activating the sensor 2Ô∏è‚É£ Fetching sensor data 3Ô∏è‚É£ Setting the standby interval</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L71-L87">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Operations for Barometer and Temperature Sensor */

static const struct sensor_ops_s g_baro_ops =
{
  .activate      = bme280_activate_baro,
  .fetch         = bme280_fetch_baro,
  .set_interval  = bme280_set_interval_baro,
};

/* Operations for Humidity Sensor */

static const struct sensor_ops_s g_humi_ops =
{
  .activate      = bme280_activate_humi,
  .fetch         = bme280_fetch_humi,
  .set_interval  = bme280_set_interval_humi,
};</code></pre></div>
<p><img src="https://lupyuen.github.io/images/bme280-combine2a.png" alt="" /></p>
<p>At NuttX Startup we register both BME280 sensors: Barometer Sensor and Humidity Sensor: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L755-L773">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>int bme280_register(int devno, FAR struct i2c_master_s *i2c)
{
  ...
  /* Register the Barometer Sensor */

  ret = sensor_register(&amp;priv-&gt;sensor_baro, devno);
  if (ret &lt; 0)
    {
      snerr(&quot;Failed to register barometer sensor: %d\n&quot;, ret);
      kmm_free(data);
      kmm_free(priv);
    }

  /* Register the Humidity Sensor */

  ret = sensor_register(&amp;priv-&gt;sensor_humi, devno);
  if (ret &lt; 0)
    {
      snerr(&quot;Failed to register humidity sensor: %d\n&quot;, ret);
      kmm_free(data);
      kmm_free(priv);
    }</code></pre></div>
<p>TODO17</p>
<p><img src="https://lupyuen.github.io/images/bme280-combine3.png" alt="" /></p>
<p>Our NuttX BME280 Driver appears as 2 sensors: 1Ô∏è‚É£ ‚Äú/dev/sensor/baro0‚Äù (Barometer Sensor) 2Ô∏è‚É£ ‚Äú/dev/sensor/humi0‚Äù (Humidity Sensor)</p>
<h1 id="run-bme280-driver" class="section-header"><a href="#run-bme280-driver">5 Run BME280 Driver</a></h1>
<p>TODO</p>
<p>This is how we read each sensor:</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; sensortest -n 1 baro0
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
baro0: timestamp:16730000 value1:1007.48 value2:28.93
SensorTest: Received message: baro0, number:1/1
bl602_i2c_transfer: i2c transfer error, event = 4

nsh&gt; sensortest -n 1 humi0
SensorTest: Test /dev/sensor/humi0 with interval(1000000us), latency(0us)
humi0: timestamp:23780000 value:87.72
SensorTest: Received message: humi0, number:1/1
bl602_i2c_transfer: i2c transfer error, event = 4</code></pre></div>
<p>Detailed Log:</p>
<div class="example-wrap"><pre class="language-text"><code>spi_test_driver_register: devpath=/dev/spitest0, spidev=0
bme280_register: devno=0
bme280_register: priv=4201b770, sensor_baro=4201b770, sensor_humi=4201b78c
bme280_reg_read: start=0xd0, size=1, buf[0]=0x60
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1, buf[0]=0x00
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1, buf[0]=0x4b
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: &quot;BME280&quot; OK
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
sensor_custom_register: Registering /dev/sensor/baro0
sensor_custom_register: Registering /dev/sensor/humi0
bme280_register: BME280 driver loaded successfully!

NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt; sensortest -n 1 baro0
sensor_ioctl: cmd=a81 arg=4201c424
bme280_set_interval_baro: period_us=1107412004
bme280_set_interval_baro: priv=4201b770, sensor_baro=4201b770
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1, buf[0]=0xa8
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1, buf[0]=0xa8
sensor_ioctl: cmd=a82 arg=4201c428
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate_baro: enable=1
bme280_activate_baro: priv=4201b770, sensor_baro=4201b770
bme280_reg_read: start=0xd0, size=1, buf[0]=0x60
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1, buf[0]=0x00
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1, buf[0]=0x4b
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: &quot;BME280&quot; OK
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch_baro: buflen=16
bme280_fetch_baro: priv=4201b770, sensor_baro=4201b770
bme280_reg_read: start=0xf3, size=1, buf[0]=0x0c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x0c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x04
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=30.820000 ¬∞C, pressure=1006.847229 mbar, humidity=75.403320 %
baro0: timestamp:45090000 value1:1006.85 value2:30.82
SensorTest: Received message: baro0, number:1/1
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate_baro: enable=0
bme280_activate_baro: priv=4201b770, sensor_baro=4201b770
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
nsh&gt;
nsh&gt;
nsh&gt; sensortest -n 1 humi0
sensor_ioctl: cmd=a81 arg=4201c424
bme280_set_interval_humi: period_us=1107412004
bme280_set_interval_humi: priv=4201b770, sensor_humi=4201b78c
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1, buf[0]=0xa8
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1, buf[0]=0xa8
sensor_ioctl: cmd=a82 arg=4201c428
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate_humi: enable=1
bme280_activate_humi: priv=4201b770, sensor_humi=4201b78c
bme280_reg_read: start=0xd0, size=1, buf[0]=0x60
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1, buf[0]=0x00
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1, buf[0]=0x4b
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: &quot;BME280&quot; OK
SensorTest: Test /dev/sensor/humi0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch_humi: buflen=16
bme280_fetch_humi: priv=4201b770, sensor_humi=4201b78c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x0c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x0c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x04
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=30.820000 ¬∞C, pressure=1006.873535 mbar, humidity=75.338867 %
humi0: timestamp:57950000 value:75.34
SensorTest: Received message: humi0, number:1/1
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate_humi: enable=0
bme280_activate_humi: priv=4201b770, sensor_humi=4201b78c
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
nsh&gt;</code></pre></div><h1 id="pending-issues" class="section-header"><a href="#pending-issues">6 Pending Issues</a></h1>
<p>TODO</p>
<p>Why does this fail? Perhaps because BME280 is in low power mode?</p>
<div class="example-wrap"><pre class="language-text"><code># Resume BME280: This is OK
bme280_reg_write: reg=0xf4, val=0x57
...
# Suspend BME280: This fails
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4</code></pre></div>
<p>The BME280 Driver writes a different value to Register F4 and doesn‚Äôt fail‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code># Resume BMP280: This is OK
bmp280_putreg8: regaddr=0xf4, regval=0x2f
...
# Suspend BMP280: This is OK
bmp280_putreg8: regaddr=0xf4, regval=0x00</code></pre></div><h1 id="whats-next" class="section-header"><a href="#whats-next">7 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/bme280.md"><code>lupyuen.github.io/src/bme280.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">8 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1494301654186823683">this Twitter Thread</a></li>
</ol>
<p>Connect BME280 to #RISCV PineCone #BL602 @PINE64 ‚Ä¶ Preferably not on a cooking pot üòÇ</p>
<p>TODO24</p>
<p><img src="https://lupyuen.github.io/images/bme280-pot.jpg" alt="" /></p>

    
</body>
</html>