<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Apache NuttX Driver for BME280 Sensor: Ported from Zephyr OS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Apache NuttX Driver for BME280 Sensor: Ported from Zephyr OS" 
    data-rh="true">
<meta property="og:description" 
    content="Apache NuttX OS talks I2C with Bosch BME280 Sensor on BL602 RISC-V SoC... Thanks to the BME280 Driver ported from Zephyr OS"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/bme280-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Apache NuttX Driver for BME280 Sensor: Ported from Zephyr OS</h1>
    <nav id="TOC"><ul>
<li><a href="#test-and-connect-bme280">1 Test and Connect BME280</a><ul></ul></li>
<li><a href="#start-with-bmp280-driver">2 Start with BMP280 Driver</a><ul>
<li><a href="#change-i2c-address-and-device-id">2.1 Change I2C Address and Device ID</a><ul></ul></li>
<li><a href="#register-bmp280-driver">2.2 Register BMP280 Driver</a><ul></ul></li>
<li><a href="#invalid-device-id">2.3 Invalid Device ID</a><ul></ul></li>
<li><a href="#incorrect-register-id">2.4 Incorrect Register ID</a><ul></ul></li>
<li><a href="#set-i2c-sub-address">2.5 Set I2C Sub Address</a><ul></ul></li>
<li><a href="#bmp280-driver-loads-ok">2.6 BMP280 Driver Loads OK</a><ul></ul></li>
<li><a href="#run-sensor-test-app">2.7 Run Sensor Test App</a><ul></ul></li></ul></li>
<li><a href="#port-bme280-driver-from-zephyr-os">3 Port BME280 Driver from Zephyr OS</a><ul>
<li><a href="#zephyr-to-nuttx">3.1 Zephyr to NuttX</a><ul></ul></li>
<li><a href="#read-sensor-data-from-zephyr-driver">3.2 Read Sensor Data from Zephyr Driver</a><ul></ul></li>
<li><a href="#power-management">3.3 Power Management</a><ul></ul></li>
<li><a href="#standby-duration">3.4 Standby Duration</a><ul></ul></li>
<li><a href="#wrap-zephyr-driver-as-nuttx-driver">3.5 Wrap Zephyr Driver as NuttX Driver</a><ul></ul></li>
<li><a href="#zephyr-driver-modified-for-nuttx">3.6 Zephyr Driver Modified For NuttX</a><ul></ul></li>
<li><a href="#output-log">3.7 Output Log</a><ul></ul></li></ul></li>
<li><a href="#combined-barometer-and-humidity-sensor">4 Combined Barometer and Humidity Sensor</a><ul></ul></li>
<li><a href="#run-bme280-driver">5 Run BME280 Driver</a><ul></ul></li>
<li><a href="#pending-issues">6 Pending Issues</a><ul></ul></li>
<li><a href="#whats-next">7 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">8 Notes</a><ul></ul></li>
<li><a href="#appendix-log-i2c-transfers">9 Appendix: Log I2C Transfers</a><ul></ul></li>
<li><a href="#appendix-build-flash-and-run-nuttx">10 Appendix: Build, Flash and Run NuttX</a><ul>
<li><a href="#download-nuttx">10.1 Download NuttX</a><ul></ul></li>
<li><a href="#configure-nuttx">10.2 Configure NuttX</a><ul></ul></li>
<li><a href="#build-nuttx">10.3 Build NuttX</a><ul></ul></li>
<li><a href="#flash-nuttx">10.4 Flash NuttX</a><ul></ul></li>
<li><a href="#run-nuttx">10.5 Run NuttX</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>7 Mar 2022</em></p>
<p><img src="https://lupyuen.github.io/images/bme280-title.jpg" alt="Bosch BME280 Sensor connected to Pine64 PineCone BL602 RISC-V Board" /></p>
<p><em>‚ÄúWill <a href="https://lupyuen.github.io/articles/nuttx"><strong>Apache NuttX OS</strong></a> talk I2C with <a href="https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/"><strong>Bosch BME280 Sensor</strong></a>‚Ä¶ On the <a href="https://lupyuen.github.io/articles/pinecone"><strong>BL602 RISC-V SoC</strong></a>?‚Äù</em></p>
<p>‚Ä¶A friend and I pondered (8,000 miles apart) while working on the <a href="https://learn.sparkfun.com/tutorials/sparkfun-bme280-breakout-hookup-guide"><strong>Temperature + Humidity + Air Pressure</strong></a> combo sensor.</p>
<p>Sounds like a fun challenge‚Ä¶</p>
<ul>
<li>
<p>NuttX <strong>doesn‚Äôt have a driver</strong> for the BME280 Sensor</p>
<p>(Though it supports BMP280)</p>
</li>
<li>
<p>Can we port the BME280 Driver from <strong>Zephyr OS</strong> with a few tweaks?</p>
<p>(Spoiler: Yes we can!)</p>
</li>
<li>
<p>What‚Äôs inside a <strong>NuttX Sensor Driver</strong> anyway?</p>
<p>(How to build our own driver)</p>
</li>
<li>
<p>NuttX on BL602 is <strong>kinda new-ish</strong></p>
<p>(Some features might not work the way we expect)</p>
</li>
<li>
<p>BL602‚Äôs I2C Port has <strong>interesting quirks</strong>. Will it work?</p>
<p>(Specifically: I2C Sub Address)</p>
</li>
</ul>
<p>Read on to find out how we solved the challenge and created this driver‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bme280-nuttx"><strong>lupyuen/bme280-nuttx</strong></a></li>
</ul>
<p>(This BME280 Driver should work OK on other NuttX platforms, like ESP32)</p>
<p><img src="https://lupyuen.github.io/images/i2c-buspirate.jpg" alt="Bus Pirate connected to BME280" /></p>
<h1 id="test-and-connect-bme280" class="section-header"><a href="#test-and-connect-bme280">1 Test and Connect BME280</a></h1>
<p>Before we begin our exploration, verify that our BME280 Sensor works OK.</p>
<p>(Because we‚Äôll see some unexpected behaviour in a while)</p>
<p>We used <a href="http://dangerousprototypes.com/docs/Bus_Pirate"><strong>Bus Pirate</strong></a> (pic above) for testing our BME280 Sensor.</p>
<p><a href="https://lupyuen.github.io/articles/i2c#appendix-test-bme280-with-bus-pirate">(Here‚Äôs how)</a></p>
<p>Next we connect BME280 to Pine64‚Äôs <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 Board</strong></a>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">BL602 Pin</th><th style="text-align: center">BME280 Pin</th><th style="text-align: left">Wire Colour</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>GPIO 3</code></strong></td><td style="text-align: center"><code>SDA</code></td><td style="text-align: left">Green</td></tr>
<tr><td style="text-align: center"><strong><code>GPIO 4</code></strong></td><td style="text-align: center"><code>SCL</code></td><td style="text-align: left">Blue</td></tr>
<tr><td style="text-align: center"><strong><code>3V3</code></strong></td><td style="text-align: center"><code>3.3V</code></td><td style="text-align: left">Red</td></tr>
<tr><td style="text-align: center"><strong><code>GND</code></strong></td><td style="text-align: center"><code>GND</code></td><td style="text-align: left">Black</td></tr>
</tbody></table>
</div>
<p><img src="https://lupyuen.github.io/images/bme280-connect.jpg" alt="Bosch BME280 Sensor connected to Pine64 PineCone BL602 RISC-V Board" /></p>
<p>The <strong>I2C Pins</strong> on BL602 are defined here: <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/include/board.h#L85-L88">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* I2C Configuration */
#define BOARD_I2C_SCL \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN4)
#define BOARD_I2C_SDA \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN3)</code></pre></div>
<p>We disabled the <strong>UART1 Port</strong> because it uses the same pins as I2C: <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/include/board.h#L63-L68">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef TODO  /* Remember to check for duplicate pins! */
#define BOARD_UART_1_RX_PIN \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_UART | \
  GPIO_PIN3)
#define BOARD_UART_1_TX_PIN \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_UART | \
  GPIO_PIN4)
#endif  /* TODO */</code></pre></div>
<p>(UART0 is used by the Serial Console)</p>
<p><em>What if we‚Äôre connecting to ESP32?</em></p>
<p><strong>For ESP32:</strong> The GPIO Pin Numbers for the I2C Port (I2C0) are defined in <a href="https://github.com/lupyuen/incubator-nuttx/blob/bme280/arch/xtensa/src/esp32/Kconfig#L797-L805">Kconfig</a> and menuconfig‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>config ESP32_I2C0_SCLPIN
  int &quot;I2C0 SCL Pin&quot;
  default 22
  range 0 39

config ESP32_I2C0_SDAPIN
  int &quot;I2C0 SDA Pin&quot;
  default 23
  range 0 39</code></pre></div>
<p><em>Do we need Pull-Up Resistors?</em></p>
<p>We‚Äôre using the <a href="https://learn.sparkfun.com/tutorials/sparkfun-bme280-breakout-hookup-guide/all"><strong>SparkFun BME280 Breakout Board</strong></a>, which has <strong>Pull-Up Resistors</strong>. (So we don‚Äôt need to add our own)</p>
<p><em>What happens now?</em></p>
<p>Coming up we have a lengthy exploration of BME280 on BL602.</p>
<p>If we‚Äôre only interesting in <strong>running the NuttX BME280 Driver</strong> (on BL602, ESP32 and other platforms), jump to this section for the instructions‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/bme280#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX with BME280‚Äù</strong></a></li>
</ul>
<p>But if we‚Äôre keen to go deep inside the BME280 driver‚Ä¶ Read on!</p>
<h1 id="start-with-bmp280-driver" class="section-header"><a href="#start-with-bmp280-driver">2 Start with BMP280 Driver</a></h1>
<p>NuttX doesn‚Äôt have a BME280 Driver, but there‚Äôs a <strong>NuttX Driver for BMP280</strong>, the downsized (rightsized?) sibling of BME280.</p>
<p>(BMP280 works like BME280 for sensing Air Pressure and Temperature, but <strong>without Humidity</strong>)</p>
<p>Let‚Äôs test the <strong>BMP280 Driver on BL602</strong> and fix any I2C quirks.</p>
<ol>
<li>
<p>Follow these steps to <strong>download and configure</strong> NuttX‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/bme280#download-nuttx"><strong>‚ÄúDownload NuttX‚Äù</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>‚ÄúConfigure NuttX‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/bme280-config1.png" alt="Enable the I2C Port and I2C Character Driver" /></p>
</li>
<li>
<p>Enable the <strong>BMP280 Driver</strong> in menuconfig‚Ä¶</p>
<p>Check the box for <strong>‚ÄúDevice Drivers‚Äù</strong> ‚Üí <strong>‚ÄúSensor Device Support‚Äù</strong></p>
<p>Select <strong>‚ÄúSensor Device Support‚Äù</strong></p>
<p>Check the box for <strong>‚ÄúBosch BMP280 Barometic Pressure Sensor‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/bme280-config3.png" alt="BMP280 Driver" /></p>
</li>
</ol>
<h2 id="change-i2c-address-and-device-id" class="section-header"><a href="#change-i2c-address-and-device-id">2.1 Change I2C Address and Device ID</a></h2>
<p><em>Will NuttX‚Äôs BMP280 Driver really work with our BME280?</em></p>
<p>Yep the BMP280 Driver ought to read the <strong>Air Pressure</strong> and <strong>Temperature</strong> from our BME280 Sensor. (But not Humidity)</p>
<p>Just that we need to we change the <strong>I2C Address</strong> and <strong>Device ID</strong> in the BMP280 Driver: <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L45-L57">bmp280.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Previously: I2C Address of BMP280
//  #define BMP280_ADDR     0x76

//  Testing: I2C Address of BME280
#define BMP280_ADDR         0x77

//  Previously: Device ID of BMP280
//  #define DEVID           0x58

//  Testing: Device ID of BME280
#define DEVID               0x60</code></pre></div>
<p><a href="https://github.com/zephyrproject-rtos/zephyr/issues/1709">(FYI: Zephyr uses the same driver for BMP280 and BME280)</a></p>
<p><img src="https://lupyuen.github.io/images/bme280-code1.png" alt="Change I2C Address and Device ID" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L45-L57">(Source)</a></p>
<h2 id="register-bmp280-driver" class="section-header"><a href="#register-bmp280-driver">2.2 Register BMP280 Driver</a></h2>
<p>Next we <strong>load the BMP280 Driver</strong> at startup: <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L623-L640">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_SENSORS_BMP280
#include &lt;nuttx/sensors/bmp280.h&gt;
#endif  //  CONFIG_SENSORS_BMP280
...
int bl602_bringup(void) {
...
#ifdef CONFIG_SENSORS_BMP280
  //  Init I2C bus for BMP280
  struct i2c_master_s *bmp280_i2c_bus = 
    bl602_i2cbus_initialize(0);
  if (!bmp280_i2c_bus) {
    _err(&quot;ERROR: Failed to get I2C%d interface\n&quot;, 0);
  }

  //  Register the BMP280 driver
  ret = bmp280_register(0, bmp280_i2c_bus);
  if (ret &lt; 0) {
    _err(&quot;ERROR: Failed to register BMP280\n&quot;);
  }
#endif  //  CONFIG_SENSORS_BMP280</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L691-L760">(<strong>bmp280_register</strong> is defined here)</a></p>
<p><strong>For ESP32:</strong> Edit the function <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L134-L497">esp32_bringup</a> in <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L134-L497">esp32_bringup.c</a> so that it calls <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L691-L760">bmp280_register</a></p>
<p><img src="https://lupyuen.github.io/images/bme280-code2a.png" alt="Register BMP280 Driver" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L623-L640">(Source)</a></p>
<h2 id="invalid-device-id" class="section-header"><a href="#invalid-device-id">2.3 Invalid Device ID</a></h2>
<p>We‚Äôre ready to test the BMP280 Driver! <strong>Build, flash and run</strong> NuttX with these steps‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#build-nuttx"><strong>‚ÄúBuild NuttX‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#flash-nuttx"><strong>‚ÄúFlash NuttX‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#run-nuttx"><strong>‚ÄúRun NuttX‚Äù</strong></a></p>
</li>
</ol>
<p>Something unexpected happens when we boot NuttX on BL602‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_i2c_transfer: i2c transfer success
bmp280_checkid:  devid: 0x00
bmp280_checkid:  Wrong Device ID! 00
bmp280_register: Failed to register driver: -19
bl602_bringup:   ERROR: Failed to register BMP280</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx#invalid-device-id">(See the complete log)</a></p>
<p>This says that the BMP280 Driver was expecting <strong>Device ID <code>0x60</code></strong>‚Ä¶ But it got <strong><code>0x00</code></strong> instead!</p>
<p>Let‚Äôs find out why ü§î</p>
<p><img src="https://lupyuen.github.io/images/bme280-run1.png" alt="Invalid Device ID" /></p>
<p><a href="https://github.com/lupyuen/bme280-nuttx#invalid-device-id">(Source)</a></p>
<h2 id="incorrect-register-id" class="section-header"><a href="#incorrect-register-id">2.4 Incorrect Register ID</a></h2>
<p>To track down why we‚Äôre not reading the right Device ID, let‚Äôs connect a <strong>Logic Analyser</strong> and inspect the bits on the I2C Bus‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/bme280-logic2.jpg" alt="Logic Analyser connected between BL602 and BME280" /></p>
<p>The I2C Data captured by our Logic Analyser looks surprising‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/bme280-logic1.png" alt="I2C Data captured by Logic Analyser" /></p>
<p>The pic above shows that BL602 sent the <strong>wrong Register ID</strong> to BME280‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Write  [0xEE]
0x00 + ACK (Register ID is 0x00, which is incorrect!)
Read   [0xEF]
0x00 + NAK (No Acknowledgement, because Register ID is incorrect!)</code></pre></div>
<p>To read the Device ID, the Register ID should be <strong><code>0xD0</code></strong>, not <strong><code>0x00</code></strong>!</p>
<p>Let‚Äôs fix this ü§î</p>
<p><a href="https://lupyuen.github.io/articles/i2c#appendix-test-bme280-with-bus-pirate">(Here‚Äôs why Register ID should be <code>0xD0</code>)</a></p>
<h2 id="set-i2c-sub-address" class="section-header"><a href="#set-i2c-sub-address">2.5 Set I2C Sub Address</a></h2>
<p><em>Is there something special about BL602‚Äôs I2C Port?</em></p>
<p>BL602 has a peculiar I2C Port‚Ä¶</p>
<p>We need to send the <strong>I2C Sub Address</strong> (Register ID) separately from the I2C Data! </p>
<p>(Which might have caused the BMP280 Driver to fail)</p>
<p><img src="https://lupyuen.github.io/images/bme280-subaddress2.png" alt="I2C Sub Address" /></p>
<p><a href="https://github.com/bouffalolab/bl_docs/tree/main/BL602_RM/en">(From BL602 Reference Manual)</a></p>
<p>When we browse the NuttX code for BL602‚Äôs I2C Driver, we realise that it <strong>supports I2C Sub Addresses</strong>: <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/arch/risc-v/src/bl602/bl602_i2c.c#L719-L738">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int bl602_i2c_transfer(struct i2c_master_s *dev, struct i2c_msg_s *msgs, int count) {
  ...
  //  if msgs[i].flag I2C_M_NOSTOP,means start i2c with subddr
  if (msgs[i].flags &amp; I2C_M_NOSTOP) {
    priv-&gt;subflag = 1;
    priv-&gt;subaddr = 0;
    for (j = 0; j &lt; msgs[i].length; j++) {
      priv-&gt;subaddr += msgs[i].buffer[j] &lt;&lt; (j * 8);
    }
    priv-&gt;sublen = msgs[i].length;
    i++;</code></pre></div>
<p>But it needs the flag <strong>I2C_M_NOSTOP</strong> to be set!</p>
<p>Let‚Äôs patch the NuttX BMP280 Driver to send the <strong>Register ID as I2C Sub Address</strong> (instead of I2C Data) when we‚Äôre reading a BMP280 Register: <a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L209-L219">bmp280.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Read a single BME280 Register
static uint8_t bmp280_getreg8(FAR struct bmp280_dev_s *priv, uint8_t regaddr) {
  ...
  msg[0].frequency = priv-&gt;freq;
  msg[0].addr      = priv-&gt;addr;

#ifdef CONFIG_BL602_I2C0
  //  For BL602: Register ID must be passed as I2C Sub Address
  msg[0].flags     = I2C_M_NOSTOP;
#else
  //  Otherwise pass Register ID as I2C Data
  msg[0].flags     = 0;
#endif  //  CONFIG_BL602_I2C0

  msg[0].buffer    = &amp;regaddr;
  msg[0].length    = 1;</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L253-L263">(We patch <strong>bmp280_getregs</strong> too)</a></p>
<p><em>What about writing to BMP280 Registers? Do we need to set the I2C Sub Address?</em></p>
<p>We don‚Äôt need to set the I2C Sub Address when writing to BMP280 registers.</p>
<p>In a while we‚Äôll see the log which says that the BMP280 Driver works fine for writing to BMP280 registers.</p>
<p><a href="https://mcuxpresso.nxp.com/api_doc/dev/116/group__i2c.html">(Besides BL602, NXP Microcontrollers are probably the only ones that support I2C Sub Addresses)</a></p>
<p><img src="https://lupyuen.github.io/images/bme280-code5a.png" alt="Send the Register ID as I2C Sub Address (instead of I2C Data) when we‚Äôre reading a BMP280 Register" /></p>
<h2 id="bmp280-driver-loads-ok" class="section-header"><a href="#bmp280-driver-loads-ok">2.6 BMP280 Driver Loads OK</a></h2>
<p>We‚Äôve patched the BMP280 Driver to send the Register ID as I2C Sub Address. Let‚Äôs run it!</p>
<div class="example-wrap"><pre class="language-text"><code>sensor_custom_register: Registering /dev/sensor/baro0
bmp280_register: BMP280 driver loaded successfully!
NuttShell (NSH) NuttX-10.2.0-RC0</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx#bmp280-driver-loads-ok">(See the complete log)</a></p>
<p>Yep our patched BMP280 Driver <strong>loads successfully</strong>!</p>
<p>(Because it receives the correct Device ID from BMP280)</p>
<p>BMP280 appears on NuttX as <strong>/dev/sensor/baro0</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nsh&gt; ls /dev/sensor
/dev/sensor:
 baro0</code></pre></div>
<p>Let‚Äôs read the <strong>baro0</strong> device.</p>
<p><a href="https://lupyuen.github.io/articles/bme280#appendix-log-i2c-transfers">(How we enable logging for BL602 I2C Driver)</a></p>
<p><img src="https://lupyuen.github.io/images/bme280-run2a.png" alt="Our patched BMP280 Driver loads successfully" /></p>
<h2 id="run-sensor-test-app" class="section-header"><a href="#run-sensor-test-app">2.7 Run Sensor Test App</a></h2>
<p>NuttX provides a <strong>Sensor Test App</strong> that will read our BMP280 Device at <strong>/dev/sensor/baro0</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/bme280/testing/sensortest/sensortest.c"><strong>testing/sensortest/sensortest.c</strong></a></li>
</ul>
<p>(We‚Äôll study the code later)</p>
<p>We configure NuttX to enable the <strong>Sensor Test App</strong>‚Ä¶</p>
<ul>
<li>‚ÄúApplication Configuration‚Äù ‚Üí ‚ÄúTesting‚Äù ‚Üí ‚ÄúSensor Driver Test‚Äù</li>
</ul>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx">(Details here)</a></p>
<p><img src="https://lupyuen.github.io/images/bme280-config4a.png" alt="Enable the Sensor Test App" /></p>
<p>Build, flash and run NuttX. To read 10 sensor values from <strong>/dev/sensor/baro0</strong>, enter this at the NuttX Shell‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; sensortest -n 10 baro0
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:1006.21 value2:30.78
baro0: timestamp:30690000 value1:1006.21 value2:30.78
SensorTest: Received message: baro0, number:10/10
bl602_i2c_transfer: i2c transfer error, event = 4</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx#run-sensor-test-app">(See the complete log)</a></p>
<p>We see the Air Pressure and Temperature: <strong>1,006.21 millibars</strong> at <strong>30.78 ¬∞C</strong>.</p>
<p>(Air Pressure at Sea Level is 1,013.25 millibars)</p>
<p>Yep this looks reasonable for Sunny Singapore by the Seaside!</p>
<p><img src="https://lupyuen.github.io/images/bme280-run5a.png" alt="Read sensor values from BMP280" /></p>
<p><em>Are we sure that BL602 is writing correctly to I2C Registers?</em></p>
<p>This log shows that writing to I2C Registers works OK‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code># Register F5 has value 00
bmp280_getreg8: regaddr=0xf5, regval=0x00
...
# Set Register F5 to value A0
bmp280_putreg8: regaddr=0xf5, regval=0xa0
...
# Register F5 now has value A0
bmp280_getreg8: regaddr=0xf5, regval=0xa0</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx#run-sensor-test-app">(See the complete log)</a></p>
<p>Yep the NuttX BMP280 Driver works OK! Now let‚Äôs port the BME280 Driver from Zephyr OS to NuttX, so we can get the Humidity.</p>
<p><img src="https://lupyuen.github.io/images/bme280-code6a.png" alt="NuttX BMP280 Driver vs Zephyr BME280 Driver" /></p>
<p><em><a href="https://github.com/apache/incubator-nuttx/blob/master/drivers/sensors/bmp280.c">NuttX BMP280 Driver</a> vs <a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/sensor/bme280/bme280.c">Zephyr BME280 Driver</a></em></p>
<h1 id="port-bme280-driver-from-zephyr-os" class="section-header"><a href="#port-bme280-driver-from-zephyr-os">3 Port BME280 Driver from Zephyr OS</a></h1>
<p>NuttX‚Äôs BMP280 Driver works OK with our BME280 Sensor. But we‚Äôre missing one thing: <strong>Humidity</strong>.</p>
<p>Let‚Äôs port the BME280 Driver from <strong>Zephyr OS</strong> to NuttX‚Ä¶</p>
<ul>
<li><a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/sensor/bme280/bme280.c"><strong>Zephyr BME280 Driver</strong></a></li>
</ul>
<p><em>Why not code the BME280 Driver based on the datasheet?</em></p>
<p>Well yes we could‚Ä¶ But then the rest of this article would become an academic exercise üòâ</p>
<p><em>Why port from Zephyr OS?</em></p>
<p>Zephyr has an <a href="https://github.com/zephyrproject-rtos/zephyr/tree/main/drivers"><strong>extensive collection</strong></a> of drivers. </p>
<p>The NuttX porting steps that we establish today might work for other Zephyr drivers, with minimal changes!</p>
<p><em>Porting a driver from Zephyr to NuttX sounds hard!</em></p>
<p>Zephyr‚Äôs BME280 Driver looks <strong>highly similar</strong> to NuttX‚Äôs BMP280 Driver. (Pic above)</p>
<p>Thus porting Zephyr‚Äôs BME280 Driver to NuttX might not be so hard!</p>
<h2 id="zephyr-to-nuttx" class="section-header"><a href="#zephyr-to-nuttx">3.1 Zephyr to NuttX</a></h2>
<p><strong>Zephyr‚Äôs BME280 Driver</strong> exposes these functions: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c">bme280-nuttx/bme280.c</a></p>
<p><img src="https://lupyuen.github.io/images/bme280-port2.jpg" alt="Zephyr BME280 Driver" /></p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L348-L417"><strong>bme280_chip_init</strong></a>: Initialise the BME280 Sensor</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L419-L446"><strong>bme280_pm_action</strong></a>: Suspend the BME280 Sensor (Low Power Mode) or resume to Normal Power Mode</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L194-L245"><strong>bme280_sample_fetch</strong></a>: Fetch a sample from the BME280 Sensor</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L247-L286"><strong>bme280_channel_get</strong></a>: Get the Temperature / Humidity / Pressure from the fetched sample</p>
</li>
</ul>
<p><a href="https://docs.zephyrproject.org/latest/reference/peripherals/sensor.html">(<strong>bme280_sample_fetch</strong> and <strong>bme280_channel_get</strong> are explained in the Zephyr Sensor Docs)</a></p>
<p>But NuttX expects a different interface for <strong>Sensor Drivers</strong>: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c">bme280-nuttx/driver.c</a></p>
<p><img src="https://lupyuen.github.io/images/bme280-port3.jpg" alt="NuttX Driver" /></p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L668-L773"><strong>bme280_register</strong></a>: Register the sensor at startup and suspend the sensor</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L397-L431"><strong>bme280_activate</strong></a>: Suspend the sensor (Low Power Mode) or resume to Normal Power Mode</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L487-L572"><strong>bme280_fetch</strong></a>: Fetch the sensor values (Temperature / Humidity / Pressure)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L287-L341"><strong>bme280_set_interval</strong></a>: Set the Standby Interval for the sensor</p>
</li>
</ul>
<p>Our job is to <strong>map the Zephyr BME280 Driver</strong> to the Sensor Driver Interface expected by NuttX‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/bme280-port4.jpg" alt="Zephyr BME280 Driver mapped to NuttX Driver" /></p>
<div><table><thead><tr><th>Zephyr Driver</th><th>NuttX Driver</th></tr></thead><tbody>
<tr><td>bme280_chip_init,<br>bme280_pm_action</td><td><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L668-L773"><strong>bme280_register</strong></a></td></tr>
<tr><td>bme280_pm_action</td><td><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L397-L431"><strong>bme280_activate</strong></a></td></tr>
<tr><td>bme280_sample_fetch,<br>bme280_channel_get</td><td><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L487-L572"><strong>bme280_fetch</strong></a></td></tr>
<tr><td><em>(Static Interval)</em></td><td><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L287-L341"><strong>bme280_set_interval</strong></a></td></tr>
</tbody></table>
</div>
<p>We‚Äôll cover the details in the next section.</p>
<p><em>What about bme280_set_interval?</em></p>
<p>Zephyr assumes that the <strong>Standby Interval is Static</strong>. (Defined at compile time)</p>
<p>Whereas NuttX expects the Standby Interval to be <strong>set at runtime</strong>.</p>
<p>To handle this, we code the <strong>bme280_set_interval</strong> function ourselves in NuttX.</p>
<h2 id="read-sensor-data-from-zephyr-driver" class="section-header"><a href="#read-sensor-data-from-zephyr-driver">3.2 Read Sensor Data from Zephyr Driver</a></h2>
<p>Our NuttX BME280 Driver reads the <strong>Sensor Data</strong> from the Zephyr Driver in two steps‚Ä¶</p>
<ol>
<li>
<p><strong>Fetch a sample</strong> from the BME280 Sensor</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L194-L245">(<strong>bme280_sample_fetch</strong>)</a></p>
</li>
<li>
<p>Get the <strong>Temperature, Humidity and Pressure</strong> from the fetched sample</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L247-L286">(<strong>bme280_channel_get</strong>)</a></p>
</li>
</ol>
<p>This is how we do it: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L487-L572">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Fetch pressure, temperature and humidity from sensor
static int bme280_fetch(
  FAR struct device *priv,  //  NuttX Device Struct
  FAR struct sensor_event_baro *baro_data,  //  Returns pressure and temperature (if non-null)
  FAR struct sensor_event_humi *humi_data   //  Returns humidity (if non-null)
) {

  //  Zephyr BME280 Driver assumes that sensor is not in sleep mode
  if (!priv-&gt;activated) {
    snerr(&quot;Device must be active before fetch\n&quot;);
    return -EIO;
  }</code></pre></div>
<p>We begin by verifying that the sensor is in <strong>Normal Power Mode</strong>.</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L397-L431">(<strong>activated</strong> is set by <strong>bme280_activate</strong>)</a></p>
<p>Next we call the Zephyr Driver to <strong>fetch a sample</strong> from BME280‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Fetch the sensor sample (from Zephyr BME280 Driver)
  int ret = bme280_sample_fetch(
    priv,            //  NuttX Device Struct
    SENSOR_CHAN_ALL  //  Fetch Temperature, Humidity and Pressure
  );
  if (ret &lt; 0) { return ret; }</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L194-L245">(<strong>bme280_sample_fetch</strong> is defined here)</a></p>
<p>The fetched sample contains <strong>Temperature, Humidity and Pressure</strong>.</p>
<p>To get the Pressure we call the Zephyr Driver‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Get the pressure (from Zephyr BME280 Driver)
  struct sensor_value val;
  ret = bme280_channel_get(
    priv,               //  NuttX Device Struct
    SENSOR_CHAN_PRESS,  //  Get Pressure from fetched sample
    &amp;val                //  Pressure in Fixed Point format
  );
  if (ret &lt; 0) { return ret; }</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L247-L286">(<strong>bme280_channel_get</strong> is defined here)</a></p>
<p>This returns a Zephyr <a href="https://docs.zephyrproject.org/latest/reference/peripherals/sensor.html#c.sensor_value"><strong>sensor_value</strong></a> struct that stores the Pressure (kilopascal) as a <a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic"><strong>Fixed-Point Number</strong></a>.</p>
<p>We convert the Pressure from <strong>Fixed Point to Float</strong> (in millibars)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Convert pressure to float, scale up by 10 to convert kilopascal to millibars
  float pressure = get_sensor_value(&amp;val) * 10;</code></pre></div>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L93-L107">(<strong>get_sensor_value</strong> is defined here)</a></p>
<p>We do the same to get the <strong>Temperature</strong> (¬∞C) from the fetched sample‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Get the temperature (from Zephyr BME280 Driver)
  ret = bme280_channel_get(
    priv,                      //  NuttX Device Struct
    SENSOR_CHAN_AMBIENT_TEMP,  //  Get Temperature from fetched sample
    &amp;val                       //  Temperature in Fixed Point format
  );
  if (ret &lt; 0) { return ret; }
  float temperature = get_sensor_value(&amp;val);</code></pre></div>
<p>And the <strong>Humidity</strong> (relative %)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Get the humidity (from Zephyr BME280 Driver) */
  ret = bme280_channel_get(
    priv,                  //  NuttX Device Struct
    SENSOR_CHAN_HUMIDITY,  //  Get Humidity from fetched sample
    &amp;val                   //  Humidity in Fixed Point format
  );
  if (ret &lt; 0) { return ret; }
  float humidity = get_sensor_value(&amp;val);</code></pre></div>
<p>Sensor Values in NuttX are <strong>timestamped</strong>. We get the timestamp like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Get the timestamp  
  struct timespec ts;
  clock_systime_timespec(&amp;ts);
  uint64_t timestamp = 1000000ull * ts.tv_sec + ts.tv_nsec / 1000;</code></pre></div>
<p>Finally we return the <strong>Pressure and Temperature</strong> data‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Return the pressure and temperature data
  if (baro_data != NULL) {
    baro_data-&gt;pressure    = pressure;
    baro_data-&gt;temperature = temperature;
    baro_data-&gt;timestamp   = timestamp;
  }</code></pre></div>
<p>And the <strong>Humidity</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Return the humidity data
  if (humi_data != NULL) {
    humi_data-&gt;humidity    = humidity;
    humi_data-&gt;timestamp   = timestamp;
  }
  return 0;
}</code></pre></div>
<p>That‚Äôs how we call the Zephyr Driver to fetch the BME280 Sensor Data!</p>
<p><em>Why did we return the Sensor Data as two structs: baro_data and humi_data?</em></p>
<p>That‚Äôs because our NuttX BME280 Driver is implemented as a <strong>Composite Sensor</strong>: Barometer Sensor + Humidity Sensor.</p>
<p>More about this in the next chapter.</p>
<p><img src="https://lupyuen.github.io/images/bme280-code8a.png" alt="Read Sensor Data from Zephyr Driver" /></p>
<h2 id="power-management" class="section-header"><a href="#power-management">3.3 Power Management</a></h2>
<p>Mapping the <strong>Power Management</strong> functions from Zephyr to NuttX is straightforward: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L397-L431">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/****************************************************************************
 * Name: bme280_activate
 *
 * Description:
 *   Set Power Mode for the device. If enable is true, set Power Mode 
 *   to normal. Else set to sleep mode.
 *
 ****************************************************************************/

static int bme280_activate(FAR struct device *priv,
                           bool enable)
{
  DEBUGASSERT(priv != NULL);
  int ret = 0;

  if (enable)
    {
      /* Set power mode to normal */

      ret = bme280_pm_action(priv, PM_DEVICE_ACTION_RESUME);
    }
  else
    {
      /* Set to sleep mode */

      ret = bme280_pm_action(priv, PM_DEVICE_ACTION_SUSPEND);
    }

  if (ret &gt;= 0)
    {
      priv-&gt;activated = enable;
    }

  return ret;
}</code></pre></div>
<p><img src="https://lupyuen.github.io/images/bme280-code10.png" alt="Power Management" /></p>
<h2 id="standby-duration" class="section-header"><a href="#standby-duration">3.4 Standby Duration</a></h2>
<p>TODO</p>
<p>BME280 Standby Duration is static in Zephyr but configured at runtime in NuttX ‚Ä¶ So we set it in our NuttX BME280 Driver: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L217-L255">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int bme280_set_standby(FAR struct device *priv, uint8_t value)
{
  sninfo(&quot;value=%d\n&quot;, value);
  
  uint8_t v_data_u8;
  uint8_t v_sb_u8;
  int ret;

  /* Set the standby duration value */

  ret = bme280_reg_read(priv, BME280_REG_CONFIG, &amp;v_data_u8, 1);
  if (ret &lt; 0)
    {
      return ret;
    }
  v_data_u8 = (v_data_u8 &amp; ~(0x07 &lt;&lt; 5)) | (value &lt;&lt; 5);
  ret = bme280_reg_write(priv, BME280_REG_CONFIG, v_data_u8);
  if (ret &lt; 0)
    {
      return ret;
    }

  /* Check the standby duration value */

  ret = bme280_reg_read(priv, BME280_REG_CONFIG, &amp;v_data_u8, 1);
  if (ret &lt; 0)
    {
      return ret;
    }
  v_sb_u8 = (v_data_u8 &gt;&gt; 5) &amp; 0x07;

  if (v_sb_u8 != value)
    {
      snerr(&quot;Failed to set value for standby time.&quot;);
      return ERROR;
    }

  return OK;
}</code></pre></div>
<p>TODO11</p>
<p><img src="https://lupyuen.github.io/images/bme280-code11.png" alt="" /></p>
<h2 id="wrap-zephyr-driver-as-nuttx-driver" class="section-header"><a href="#wrap-zephyr-driver-as-nuttx-driver">3.5 Wrap Zephyr Driver as NuttX Driver</a></h2>
<p>TODO</p>
<p>Zephyr BME280 Driver builds OK on #NuttX (with a few tweaks) üéâ </p>
<p>TODO7</p>
<p><img src="https://lupyuen.github.io/images/bme280-code7a.png" alt="" /></p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c">(Source)</a></p>
<p>Now we wrap the Zephyr Driver as a NuttX Driver‚Ä¶</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c">(Source)</a></p>
<h2 id="zephyr-driver-modified-for-nuttx" class="section-header"><a href="#zephyr-driver-modified-for-nuttx">3.6 Zephyr Driver Modified For NuttX</a></h2>
<p>TODO</p>
<p>Here are the minor modifications we made to the Zephyr BME280 Driver while porting to NuttX‚Ä¶</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/pull/1/files#diff-80464162211b7180f107757b7aee91398cdc088e5775ffadf7e6e1f0bbb4ad65">bme280.c</a></p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/pull/1/files#diff-e13ff0ab44de7ead31a3dd6cbbbbf2a6fbfb2f04889300993b87ff5a31ffc233">bme280.h</a></p>
<p>The above files are wrapped by <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c">bundle.c</a> and <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.h">bundle.h</a> to become a NuttX Driver.</p>
<p>TODO12</p>
<p><img src="https://lupyuen.github.io/images/bme280-code12.png" alt="" /></p>
<h2 id="output-log" class="section-header"><a href="#output-log">3.7 Output Log</a></h2>
<p>TODO</p>
<p>Zephyr BME280 Driver ported to Apache #NuttX OS ‚Ä¶ Works great on NuttX! üéâ</p>
<div class="example-wrap"><pre class="language-text"><code>spi_test_driver_register: devpath=/dev/spitest0, spidev=0
bme280_register: devno=0
bme280_reg_read: start=0xd0, size=1
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: &quot;BME280&quot; OK
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
sensor_custom_register: Registering /dev/sensor/baro0
bme280_register: BME280 driver loaded successfully!

NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt; sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: period_us=1107411860
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: enable=1
bme280_reg_read: start=0xd0, size=1
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: &quot;BME280&quot; OK
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21140000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21160000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21180000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21200000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21220000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21240000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21260000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21280000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21300000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21320000 value1:1010.60 value2:29.62
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: enable=0
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4

nsh&gt; sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: period_us=1107411860
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: enable=1
bme280_reg_read: start=0xd0, size=1
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: &quot;BME280&quot; OK
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25440000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25460000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25480000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25500000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25520000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25540000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25560000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25580000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25600000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25620000 value1:1010.60 value2:29.65
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: enable=0
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: 2c transfer error, event = 4

nsh&gt; sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: period_us=1107411860
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: enable=1
bme280_reg_read: start=0xd0, size=1
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: &quot;BME280&quot; OK
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27510000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27530000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27550000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27570000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27590000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27610000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27630000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27650000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27670000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27690000 value1:1010.58 value2:29.66
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: enable=0
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
nsh&gt;</code></pre></div>
<p>Detailed Log:</p>
<div class="example-wrap"><pre class="language-text"><code>gpio_pin_register: Registering /dev/gpio0
gpio_pin_register: Registering /dev/gpio1
gpint_enable: Disable the interrupt
gpio_pin_register: Registering /dev/gpio2
bl602_gpio_set_intmod: ****gpio_pin=115, int_ctlmod=1, int_trgmod=0
bl602_spi_setfrequency: frequency=400000, actual=0
bl602_spi_setbits: nbits=8
bl602_spi_setmode: mode=0
spi_test_driver_register: devpath=/dev/spitest0, spidev=0
bl602_spi_select: devid: 0, CS: free
bme280_reg_read: start=0xd0, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xd0, sublen=1
bl602_i2c_recvdata: count=1, temp=0x60
bl602_i2c_transfer: i2c transfer success
bme280_chip_init: ID OKbme280_reg_write: reg=0xe0, val=0xb6
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0xb6e0
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x0
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0x88, size=24
bl602_i2c_transfer: subflag=1, subaddr=0x88, sublen=1
bl602_i2c_recvdata: count=24, temp=0x65e66e97
bl602_i2c_recvdata: count=20, temp=0x8f990032
bl602_i2c_recvdata: count=16, temp=0xbd0d581
bl602_i2c_recvdata: count=12, temp=0xffdb1e71
bl602_i2c_recvdata: count=8, temp=0x26acfff9
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xa1, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xa1, sublen=1
bl602_i2c_recvdata: count=1, temp=0x10bdd84b
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xe1, size=7
bl602_i2c_transfer: subflag=1, subaddr=0xe1, sublen=1
bl602_i2c_recvdata: count=7, temp=0x14000165
bl602_i2c_recvdata: count=3, temp=0x141e000b
bl602_i2c_transfer: i2c transfer success
bme280_reg_write: reg=0xf2, val=0x05
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0x5f2
bl602_i2c_transfer: i2c transfer success
bme280_reg_write: reg=0xf4, val=0x57
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0x57f4
bl602_i2c_transfer: i2c transfer success
bme280_reg_write: reg=0xf5, val=0xa8
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0xa8f5
bl602_i2c_transfer: i2c transfer success
bme280_chip_init: &quot;BME280&quot; OKsensor_custom_register: Registering /dev/sensor/baro0
bme280_register: BME280 driver loaded successfully!

NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt; sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: TODO period_us=1107411860
bme280_set_standby: TODO value=5
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: TODO enable=1
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x141e0000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38390000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38410000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38430000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38450000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38470000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38490000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38510000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38530000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38550000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38570000 value1:106.94 value2:30.11
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: TODO enable=0

nsh&gt; sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: TODO period_us=1107411860
bme280_set_standby: TODO value=5
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: TODO enable=1
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47120000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_trasfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47140000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47160000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47180000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47200000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47220000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47240000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2crecvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47260000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47280000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, ublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47300000 value1:106.94 value2:30.12
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: TODO enable=0
nsh&gt;</code></pre></div>
<p>TODO32</p>
<p><img src="https://lupyuen.github.io/images/bme280-run6a.png" alt="" /></p>
<h1 id="combined-barometer-and-humidity-sensor" class="section-header"><a href="#combined-barometer-and-humidity-sensor">4 Combined Barometer and Humidity Sensor</a></h1>
<p>TODO</p>
<p>NuttX doesn‚Äôt have a Sensor Type that supports BME280 Temperature + Humidity + Pressure ‚Ä¶ So our NuttX BME280 Driver combines 2 Sensor Types: 1Ô∏è‚É£ Barometer Sensor (Pressure + Temperature) 2Ô∏è‚É£ Humidity Sensor</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/device.h#L36-L49">device.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* NuttX Device for BME280 */

struct device
{
  FAR struct sensor_lowerhalf_s sensor_baro;  /* Barometer and Temperature Sensor */
  FAR struct sensor_lowerhalf_s sensor_humi;  /* Humidity Sensor */
  FAR struct i2c_master_s *i2c; /* I2C interface */
  uint8_t addr;                 /* BME280 I2C address */
  int freq;                     /* BME280 Frequency &lt;= 3.4MHz */
  bool activated;               /* True if device is not in sleep mode */

  char *name;                   /* Name of the device */
  struct bme280_data *data;     /* Compensation parameters (bme280.c) */
};</code></pre></div>
<p>TODO14</p>
<p><img src="https://lupyuen.github.io/images/bme280-combine1.png" alt="" /></p>
<p>Each NuttX Sensor defines its operations for 1Ô∏è‚É£ Activating the sensor 2Ô∏è‚É£ Fetching sensor data 3Ô∏è‚É£ Setting the standby interval</p>
<p><a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L71-L87">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Operations for Barometer and Temperature Sensor */

static const struct sensor_ops_s g_baro_ops =
{
  .activate      = bme280_activate_baro,
  .fetch         = bme280_fetch_baro,
  .set_interval  = bme280_set_interval_baro,
};

/* Operations for Humidity Sensor */

static const struct sensor_ops_s g_humi_ops =
{
  .activate      = bme280_activate_humi,
  .fetch         = bme280_fetch_humi,
  .set_interval  = bme280_set_interval_humi,
};</code></pre></div>
<p><img src="https://lupyuen.github.io/images/bme280-combine2a.png" alt="" /></p>
<p>At NuttX Startup we register both BME280 sensors: Barometer Sensor and Humidity Sensor: <a href="https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L755-L773">driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>int bme280_register(int devno, FAR struct i2c_master_s *i2c)
{
  ...
  /* Register the Barometer Sensor */

  ret = sensor_register(&amp;priv-&gt;sensor_baro, devno);
  if (ret &lt; 0)
    {
      snerr(&quot;Failed to register barometer sensor: %d\n&quot;, ret);
      kmm_free(data);
      kmm_free(priv);
    }

  /* Register the Humidity Sensor */

  ret = sensor_register(&amp;priv-&gt;sensor_humi, devno);
  if (ret &lt; 0)
    {
      snerr(&quot;Failed to register humidity sensor: %d\n&quot;, ret);
      kmm_free(data);
      kmm_free(priv);
    }</code></pre></div>
<p>TODO17</p>
<p><img src="https://lupyuen.github.io/images/bme280-combine3.png" alt="" /></p>
<p>Our NuttX BME280 Driver appears as 2 sensors: 1Ô∏è‚É£ ‚Äú/dev/sensor/baro0‚Äù (Barometer Sensor) 2Ô∏è‚É£ ‚Äú/dev/sensor/humi0‚Äù (Humidity Sensor)</p>
<h1 id="run-bme280-driver" class="section-header"><a href="#run-bme280-driver">5 Run BME280 Driver</a></h1>
<p>TODO</p>
<p>Edit the function <code>bl602_bringup</code> or <code>esp32_bringup</code> in this file‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code># For BL602:
nuttx/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c

# For ESP32: Change &quot;esp32-devkitc&quot; to our ESP32 board 
nuttx/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c</code></pre></div>
<p>And call <code>bme280_register</code> to register our BME280 Driver:</p>
<p>https://github.com/lupyuen/incubator-nuttx/blob/bme280/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L623-L640</p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_SENSORS_BME280
#include &lt;nuttx/sensors/bme280.h&gt;
#endif /* CONFIG_SENSORS_BME280 */

...

int bl602_bringup(void) {
  ...

#ifdef CONFIG_SENSORS_BME280

  /* Init I2C bus for BME280 */

  struct i2c_master_s *bme280_i2c_bus = bl602_i2cbus_initialize(0);
  if (!bme280_i2c_bus)
    {
      _err(&quot;ERROR: Failed to get I2C%d interface\n&quot;, 0);
    }

  /* Register the BME280 driver */

  ret = bme280_register(0, bme280_i2c_bus);
  if (ret &lt; 0)
    {
      _err(&quot;ERROR: Failed to register BME280\n&quot;);
    }
#endif /* CONFIG_SENSORS_BME280 */</code></pre></div>
<p>This is how we read each sensor:</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt; ls /dev/sensor
/dev/sensor:
 baro0
 humi0
nsh&gt; 
nsh&gt; sensortest -n 1 baro0
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
baro0: timestamp:43760000 value1:1011.29 value2:29.09
SensorTest: Received message: baro0, number:1/1
bl602_i2c_transfer: i2c transfer error, event = 4
nsh&gt; 
nsh&gt; sensortest -n 1 humi0
SensorTest: Test /dev/sensor/humi0 with interval(1000000us), latency(0us)
humi0: timestamp:60120000 value:90.58
SensorTest: Received message: humi0, number:1/1
bl602_i2c_transfer: i2c transfer error, event = 4
nsh&gt; 
nsh&gt; </code></pre></div>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/bme280-run8a.jpg" alt="" /></p>
<p>Detailed Log:</p>
<div class="example-wrap"><pre class="language-text"><code>spi_test_driver_register: devpath=/dev/spitest0, spidev=0
bme280_register: devno=0
bme280_register: priv=4201b770, sensor_baro=4201b770, sensor_humi=4201b78c
bme280_reg_read: start=0xd0, size=1, buf[0]=0x60
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1, buf[0]=0x00
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1, buf[0]=0x4b
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: &quot;BME280&quot; OK
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
sensor_custom_register: Registering /dev/sensor/baro0
sensor_custom_register: Registering /dev/sensor/humi0
bme280_register: BME280 driver loaded successfully!

NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt; sensortest -n 1 baro0
sensor_ioctl: cmd=a81 arg=4201c424
bme280_set_interval_baro: period_us=1107412004
bme280_set_interval_baro: priv=4201b770, sensor_baro=4201b770
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1, buf[0]=0xa8
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1, buf[0]=0xa8
sensor_ioctl: cmd=a82 arg=4201c428
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate_baro: enable=1
bme280_activate_baro: priv=4201b770, sensor_baro=4201b770
bme280_reg_read: start=0xd0, size=1, buf[0]=0x60
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1, buf[0]=0x00
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1, buf[0]=0x4b
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: &quot;BME280&quot; OK
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch_baro: buflen=16
bme280_fetch_baro: priv=4201b770, sensor_baro=4201b770
bme280_reg_read: start=0xf3, size=1, buf[0]=0x0c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x0c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x04
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=30.820000 ¬∞C, pressure=1006.847229 mbar, humidity=75.403320 %
baro0: timestamp:45090000 value1:1006.85 value2:30.82
SensorTest: Received message: baro0, number:1/1
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate_baro: enable=0
bme280_activate_baro: priv=4201b770, sensor_baro=4201b770
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
nsh&gt;
nsh&gt;
nsh&gt; sensortest -n 1 humi0
sensor_ioctl: cmd=a81 arg=4201c424
bme280_set_interval_humi: period_us=1107412004
bme280_set_interval_humi: priv=4201b770, sensor_humi=4201b78c
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1, buf[0]=0xa8
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1, buf[0]=0xa8
sensor_ioctl: cmd=a82 arg=4201c428
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate_humi: enable=1
bme280_activate_humi: priv=4201b770, sensor_humi=4201b78c
bme280_reg_read: start=0xd0, size=1, buf[0]=0x60
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1, buf[0]=0x00
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1, buf[0]=0x4b
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: &quot;BME280&quot; OK
SensorTest: Test /dev/sensor/humi0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch_humi: buflen=16
bme280_fetch_humi: priv=4201b770, sensor_humi=4201b78c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x0c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x0c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x04
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=30.820000 ¬∞C, pressure=1006.873535 mbar, humidity=75.338867 %
humi0: timestamp:57950000 value:75.34
SensorTest: Received message: humi0, number:1/1
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate_humi: enable=0
bme280_activate_humi: priv=4201b770, sensor_humi=4201b78c
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
nsh&gt;</code></pre></div><h1 id="pending-issues" class="section-header"><a href="#pending-issues">6 Pending Issues</a></h1>
<p>TODO</p>
<p>Why does this fail? Perhaps because BME280 is in low power mode?</p>
<div class="example-wrap"><pre class="language-text"><code># Resume BME280: This is OK
bme280_reg_write: reg=0xf4, val=0x57
...
# Suspend BME280: This fails
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4</code></pre></div>
<p>The BME280 Driver writes a different value to Register F4 and doesn‚Äôt fail‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code># Resume BMP280: This is OK
bmp280_putreg8: regaddr=0xf4, regval=0x2f
...
# Suspend BMP280: This is OK
bmp280_putreg8: regaddr=0xf4, regval=0x00</code></pre></div><h1 id="whats-next" class="section-header"><a href="#whats-next">7 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/bme280.md"><code>lupyuen.github.io/src/bme280.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">8 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1494301654186823683">this Twitter Thread</a></li>
</ol>
<h1 id="appendix-log-i2c-transfers" class="section-header"><a href="#appendix-log-i2c-transfers">9 Appendix: Log I2C Transfers</a></h1>
<p>TODO</p>
<p>BL602 NuttX I2C Driver doesn‚Äôt log the data transferred ‚Ä¶ Let‚Äôs log ourselves: <a href="https://github.com/lupyuen/incubator-nuttx/blob/bme280/arch/risc-v/src/bl602/bl602_i2c.c#L194-L197">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static void bl602_i2c_send_data(struct bl602_i2c_priv_s *priv)
{
  ...
  putreg32(temp, BL602_I2C_FIFO_WDATA);
  priv-&gt;bytes += count;
  i2cinfo(&quot;count=%d, temp=0x%x\n&quot;, count, temp); ////
}</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/bme280/arch/risc-v/src/bl602/bl602_i2c.c#L207-L216">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static void bl602_i2c_recvdata(struct bl602_i2c_priv_s *priv)
{
  ...
  count = msg-&gt;length - priv-&gt;bytes;
  temp  = getreg32(BL602_I2C_FIFO_RDATA);
  i2cinfo(&quot;count=%d, temp=0x%x\n&quot;, count, temp); ////</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/bme280/arch/risc-v/src/bl602/bl602_i2c.c#L740-L742">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int bl602_i2c_transfer(struct i2c_master_s *dev,
                              struct i2c_msg_s *   msgs,
                              int                      count)
{
  ...
  for (i = 0; i &lt; count; i++)
    {
      ...
      priv-&gt;msgid = i;
      i2cinfo(&quot;subflag=%d, subaddr=0x%x, sublen=%d\n&quot;, priv-&gt;subflag, priv-&gt;subaddr, priv-&gt;sublen); ////
      bl602_i2c_start_transfer(priv);</code></pre></div>
<p>TODO3</p>
<p><img src="https://lupyuen.github.io/images/bme280-code3a.png" alt="" /></p>
<h1 id="appendix-build-flash-and-run-nuttx" class="section-header"><a href="#appendix-build-flash-and-run-nuttx">10 Appendix: Build, Flash and Run NuttX</a></h1>
<p><em>(For BL602, BL604 and ESP32)</em></p>
<p>Below are the steps to build, flash and run NuttX on BL602, BL604 and ESP32.</p>
<p>The instructions below will work on <strong>Linux (Ubuntu)</strong>, <strong>WSL (Ubuntu)</strong> and <strong>macOS</strong>.</p>
<p><a href="https://nuttx.apache.org/docs/latest/quickstart/install.html">(Instructions for other platforms)</a></p>
<p><a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(See this for Arch Linux)</a></p>
<h2 id="download-nuttx" class="section-header"><a href="#download-nuttx">10.1 Download NuttX</a></h2>
<p>To use the NuttX BME280 Driver, download the modified source code for <strong>NuttX OS and NuttX Apps</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>mkdir nuttx
cd nuttx
git clone --recursive --branch bme280 https://github.com/lupyuen/incubator-nuttx nuttx
git clone --recursive --branch bme280 https://github.com/lupyuen/incubator-nuttx-apps apps</code></pre></div>
<p>Or if we prefer to <strong>add the BME280 Driver</strong> to our NuttX Project, follow these instructions‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bme280-nuttx#install-driver"><strong>‚ÄúInstall BME280 Driver‚Äù</strong></a></li>
</ul>
<h2 id="configure-nuttx" class="section-header"><a href="#configure-nuttx">10.2 Configure NuttX</a></h2>
<p>Now we configure our NuttX project‚Ä¶</p>
<ol>
<li>
<p>Install the build prerequisites‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Configure the build‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cd nuttx

# For BL602 / BL604: Configure the build for BL602 / BL604
./tools/configure.sh bl602evb:nsh

# For ESP32: Configure the build for ESP32.
# TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

# Edit the Build Config
make menuconfig </code></pre></div></li>
<li>
<p>Enable <strong>I2C0 Port</strong>‚Ä¶</p>
<p><strong>For BL602 / BL604:</strong> Check the box for <strong>‚ÄúSystem Type‚Äù</strong> ‚Üí <strong>‚ÄúBL602 Peripheral Support‚Äù</strong> ‚Üí <strong>‚ÄúI2C0‚Äù</strong></p>
<p><strong>For ESP32:</strong> Check the box for <strong>‚ÄúSystem Type‚Äù</strong> ‚Üí <strong>‚ÄúESP32 Peripheral Select‚Äù</strong> ‚Üí <strong>‚ÄúI2C 0‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
<p><img src="https://lupyuen.github.io/images/bme280-config1.png" alt="Enable the I2C Port and I2C Character Driver" /></p>
</li>
<li>
<p>Enable <strong>I2C Character Driver</strong>‚Ä¶</p>
<p>Check the box for <strong>‚ÄúDevice Drivers‚Äù</strong> ‚Üí <strong>‚ÄúI2C Driver Support‚Äù</strong> ‚Üí <strong>‚ÄúI2C Character Driver‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
</li>
<li>
<p>Enable <strong>Sensor Driver Test App</strong>‚Ä¶</p>
<p>Check the box for <strong>‚ÄúApplication Configuration‚Äù</strong> ‚Üí <strong>‚ÄúTesting‚Äù</strong> ‚Üí <strong>‚ÄúSensor Driver Test‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
<p><img src="https://lupyuen.github.io/images/bme280-config4a.png" alt="Enable the Sensor Test App" /></p>
</li>
<li>
<p>Enable <strong>ls</strong> command‚Ä¶</p>
<p>Select <strong>‚ÄúApplication Configuration‚Äù</strong> ‚Üí <strong>‚ÄúNSH Library‚Äù</strong> ‚Üí <strong>‚ÄúDisable Individual commands‚Äù</strong></p>
<p>Uncheck <strong>‚ÄúDisable ls‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
</li>
<li>
<p>Enable <strong>Logging and Assertion Checks</strong>‚Ä¶</p>
<p>Select <strong>‚ÄúBuild Setup‚Äù</strong> ‚Üí <strong>‚ÄúDebug Options‚Äù</strong></p>
<p>Check the boxes for the following‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Enable Debug Features
Enable Error Output
Enable Warnings Output
Enable Informational Debug Output
Enable Debug Assertions
I2C Debug Features
I2C Error Output
I2C Warnings Output
I2C Informational Output  
Sensor Debug Features
Sensor Error Output
Sensor Warnings Output  
Sensor Informational Output </code></pre></div>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
</li>
<li>
<p>Save the configuration and exit menuconfig</p>
<p><a href="https://gist.github.com/lupyuen/9d84889f5e2415ecb0f28cea2c2a657f">(See the .config for BL602)</a></p>
</li>
</ol>
<p>The BME280 Driver will appear in NuttX at <strong>/dev/baro0</strong> and <strong>/dev/humi0</strong></p>
<h2 id="build-nuttx" class="section-header"><a href="#build-nuttx">10.3 Build NuttX</a></h2>
<p>Follow these steps to build NuttX for BL602, BL604 or ESP32‚Ä¶</p>
<ol>
<li>
<p>To build NuttX, enter this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>make</code></pre></div></li>
<li>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>LD: nuttx
CP: nuttx.hex
CP: nuttx.bin</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/8f725c278c25e209c1654469a2855746">(See the complete log for BL602 / BL604)</a></p>
</li>
<li>
<p><strong>For WSL:</strong> Copy the <strong>NuttX Firmware</strong> to the <strong>c:\blflash</strong> directory in the Windows File System‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  /mnt/c/blflash refers to c:\blflash in Windows
mkdir /mnt/c/blflash
cp nuttx.bin /mnt/c/blflash</code></pre></div>
<p>For WSL we need to run <strong>blflash</strong> under plain old Windows CMD (not WSL) because it needs to access the COM port.</p>
</li>
<li>
<p>In case of problems, refer to the <strong>NuttX Docs</strong>‚Ä¶</p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/risc-v/bl602/index.html"><strong>‚ÄúBL602 / BL604 NuttX‚Äù</strong></a></p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html"><strong>‚ÄúESP32 NuttX‚Äù</strong></a></p>
<p><a href="https://nuttx.apache.org/docs/latest/quickstart/install.html"><strong>‚ÄúInstalling NuttX‚Äù</strong></a></p>
</li>
</ol>
<blockquote>
<p><img src="https://lupyuen.github.io/images/nuttx-build2.png" alt="Building NuttX" /></p>
</blockquote>
<h2 id="flash-nuttx" class="section-header"><a href="#flash-nuttx">10.4 Flash NuttX</a></h2>
<p><strong>For ESP32:</strong> <a href="https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html#flashing"><strong>See instructions here</strong></a> <a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(Also check out this article)</a></p>
<p><strong>For BL602 / BL604:</strong> Follow these steps to install <strong>blflash</strong>‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>‚ÄúInstall rustup‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>‚ÄúDownload and build blflash‚Äù</strong></a></p>
</li>
</ol>
<p>We assume that our Firmware Binary File <strong>nuttx.bin</strong> has been copied to the <strong>blflash</strong> folder.</p>
<p>Set BL602 / BL604 to <strong>Flashing Mode</strong> and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>High</strong> <a href="https://lupyuen.github.io/images/pinedio-high.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ol>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>Enter these commands to flash <strong>nuttx.bin</strong> to BL602 / BL604 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># For Linux: Change &quot;/dev/ttyUSB0&quot; to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/ttyUSB0 

# For macOS: Change &quot;/dev/tty.usbserial-1410&quot; to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/tty.usbserial-1410 \
  --initial-baud-rate 230400 \
  --baud-rate 230400

# For Windows: Change &quot;COM5&quot; to the BL602 / BL604 Serial Port
blflash flash c:\blflash\nuttx.bin --port COM5</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9c0dbd75bb6b8e810939a36ffb5c399f">(See the Output Log)</a></p>
<p>For WSL: Do this under plain old Windows CMD (not WSL) because <strong>blflash</strong> needs to access the COM port.</p>
<p><a href="https://github.com/apache/incubator-nuttx/issues/4336">(Flashing WiFi apps to BL602 / BL604? Remember to use <strong>bl_rfbin</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">(More details on flashing firmware)</a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-flash2.png" alt="Flashing NuttX" /></p>
<h2 id="run-nuttx" class="section-header"><a href="#run-nuttx">10.5 Run NuttX</a></h2>
<p><strong>For ESP32:</strong> Use Picocom to connect to ESP32 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>picocom -b 115200 /dev/ttyUSB0</code></pre></div>
<p><a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(More about this)</a></p>
<p><strong>For BL602 / BL604:</strong> Set BL602 / BL604 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>Low</strong> <a href="https://lupyuen.github.io/images/pinedio-low.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ol>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>After restarting, connect to BL602 / BL604‚Äôs UART Port at 2 Mbps like so‚Ä¶</p>
<p><strong>For Linux:</strong></p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 2000000</code></pre></div>
<p><strong>For macOS:</strong> Use CoolTerm (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>For Windows:</strong> Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>Alternatively:</strong> Use the Web Serial Terminal (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p>Press Enter to reveal the <strong>NuttX Shell</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt;</code></pre></div>
<p>Congratulations NuttX is now running on BL602 / BL604!</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">(More details on connecting to BL602 / BL604)</a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-boot2.png" alt="Running NuttX" /></p>
<p><strong>macOS Tip:</strong> Here‚Äôs the script I use to build, flash and run NuttX on macOS, all in a single step: <a href="https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af">run.sh</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-script.png" alt="Script to build, flash and run NuttX on macOS" /></p>
<p><a href="https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af">(Source)</a></p>
<p>Connect BME280 to #RISCV PineCone #BL602 @PINE64 ‚Ä¶ Preferably not on a cooking pot üòÇ</p>
<p>TODO24</p>
<p><img src="https://lupyuen.github.io/images/bme280-pot.jpg" alt="" /></p>

    
</body>
</html>