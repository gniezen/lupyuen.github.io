<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>SPI on Apache NuttX OS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="SPI on Apache NuttX OS" 
    data-rh="true">
<meta property="og:description" 
    content="How we transmit and receive data over SPI on Apache NuttX OS... By coding a NuttX Device Driver"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/spi2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">SPI on Apache NuttX OS</h1>
    <nav id="TOC"><ul>
<li><a href="#spi-test-app-and-driver">1 SPI Test App and Driver</a><ul></ul></li>
<li><a href="#inside-the-spi-test-driver">2 Inside the SPI Test Driver</a><ul>
<li><a href="#file-operations">2.1 File Operations</a><ul></ul></li>
<li><a href="#write-operation">2.2 Write Operation</a><ul></ul></li>
<li><a href="#read-operation">2.3 Read Operation</a><ul></ul></li>
<li><a href="#configure-spi">2.4 Configure SPI</a><ul></ul></li></ul></li>
<li><a href="#load-the-spi-test-driver">3 Load the SPI Test Driver</a><ul></ul></li>
<li><a href="#inside-the-spi-test-app">4 Inside the SPI Test App</a><ul>
<li><a href="#open-spi-test-driver">4.1 Open SPI Test Driver</a><ul></ul></li>
<li><a href="#transmit-spi-data">4.2 Transmit SPI Data</a><ul></ul></li>
<li><a href="#receive-spi-data">4.3 Receive SPI Data</a><ul></ul></li>
<li><a href="#close-spi-test-driver">4.4 Close SPI Test Driver</a><ul></ul></li></ul></li>
<li><a href="#run-the-spi-test-app">5 Run the SPI Test App</a><ul></ul></li>
<li><a href="#test-with-logic-analyser">6 Test with Logic Analyser</a><ul></ul></li>
<li><a href="#control-chip-select-with-gpio">7 Control Chip Select with GPIO</a><ul>
<li><a href="#gpio-output-as-chip-select">7.1 GPIO Output as Chip Select</a><ul></ul></li></ul></li>
<li><a href="#test-with-semtech-sx1262">8 Test with Semtech SX1262</a><ul>
<li><a href="#connect-sx1262">8.1 Connect SX1262</a><ul></ul></li>
<li><a href="#test-sx1262">8.2 Test SX1262</a><ul></ul></li></ul></li>
<li><a href="#test-with-pinedio-stack">9 Test with PineDio Stack</a><ul>
<li><a href="#pin-definitions">9.1 Pin Definitions</a><ul></ul></li>
<li><a href="#run-nuttx-on-pinedio-stack">9.2 Run NuttX on PineDio Stack</a><ul></ul></li></ul></li>
<li><a href="#whats-next">10 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">11 Notes</a><ul></ul></li>
<li><a href="#appendix-create-a-nuttx-device-driver">12 Appendix: Create a NuttX Device Driver</a><ul>
<li><a href="#update-makefile-and-kconfig">12.1 Update Makefile and Kconfig</a><ul></ul></li>
<li><a href="#enable-spi">12.2 Enable SPI</a><ul></ul></li>
<li><a href="#enable-logging">12.3 Enable Logging</a><ul></ul></li>
<li><a href="#register-device-driver">12.4 Register Device Driver</a><ul></ul></li>
<li><a href="#verify-device-driver">12.5 Verify Device Driver</a><ul></ul></li></ul></li>
<li><a href="#appendix-create-a-nuttx-app">13 Appendix: Create a NuttX App</a><ul>
<li><a href="#enable-app">13.1 Enable App</a><ul></ul></li>
<li><a href="#run-the-app">13.2 Run the App</a><ul></ul></li></ul></li>
<li><a href="#appendix-build-flash-and-run-nuttx">14 Appendix: Build, Flash and Run Nuttx</a><ul></ul></li>
<li><a href="#appendix-nuttx-spi-interface">15 Appendix: NuttX SPI Interface</a><ul></ul></li>
<li><a href="#appendix-miso-and-mosi-are-swapped">16 Appendix: MISO And MOSI Are Swapped</a><ul></ul></li>
<li><a href="#appendix-spi-mode-quirk">17 Appendix: SPI Mode Quirk</a><ul></ul></li>
<li><a href="#appendix-pinedio-stack-bl604">18 Appendix: PineDio Stack BL604</a><ul></ul></li></ul></nav><p>üìù <em>15 Dec 2021</em></p>
<p><img src="https://lupyuen.github.io/images/spi2-title.jpg" alt="PineCone BL602 Board (right) connected to Semtech SX1262 LoRa Transceiver (left)" /></p>
<p><em>PineCone BL602 Board (right) connected to Semtech SX1262 LoRa Transceiver (left)</em></p>
<p>Last article we explored <strong>Apache NuttX OS</strong> and its <strong>GPIO Functions</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/nuttx"><strong>‚ÄúApache NuttX OS on RISC-V BL602 and BL604‚Äù</strong></a></li>
</ul>
<p>Today we shall venture into the <strong>SPI Functions</strong> and discover‚Ä¶</p>
<ul>
<li>
<p>How to <strong>transmit and receive</strong> data over SPI</p>
</li>
<li>
<p>By coding a simple NuttX <strong>Device Driver</strong></p>
</li>
<li>
<p>And testing with <strong>Semtech SX1262</strong> (LoRa Transceiver)</p>
</li>
<li>
<p>On Bouffalo Lab‚Äôs <strong>BL602 and BL604</strong> RISC-V SoCs</p>
</li>
</ul>
<p>We‚Äôll also study briefly the internals of the <strong>NuttX SPI Driver</strong>, to understand how it works.</p>
<p><em>What about ESP32? NuttX works the same across platforms right?</em></p>
<p>I realise that many of my readers are using ESP32 instead of BL602.</p>
<p>In this article I‚Äôll point out the tweaks needed to <strong>run the code on ESP32</strong>.</p>
<p>(Watch for the <strong>‚ÄúFor ESP32‚Äù</strong> tags)</p>
<p><img src="https://lupyuen.github.io/images/spi2-plan.jpg" alt="SPI Test App calls SPI Test Driver to access SPI Driver" /></p>
<h1 id="spi-test-app-and-driver" class="section-header"><a href="#spi-test-app-and-driver">1 SPI Test App and Driver</a></h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>Our plan for today (pic above)‚Ä¶</p>
<ol>
<li>
<p>We create an <strong>SPI Test App</strong> that will transfer data over SPI.</p>
<p>(A tiny program with a few lines of code)</p>
</li>
<li>
<p>We create an <strong>SPI Test Driver</strong> (called by SPI Test App) that will handle the SPI Operations.</p>
<p>(To transmit and receive data over SPI)</p>
</li>
<li>
<p>Our SPI Test Driver exposes a NuttX <a href="https://nuttx.apache.org/docs/latest/components/drivers/character/index.html"><strong>Character Device Interface</strong></a>: open(), write(), read() and close().</p>
<p>(Yep it looks like Linux, because NuttX is POSIX Compliant)</p>
</li>
<li>
<p>Our SPI Test Driver executes the SPI Operations by calling the <strong>BL602 or ESP32 SPI Driver</strong>.</p>
<p>(Which is equivalent to the Hardware Abstraction Layer in other operating systems)</p>
</li>
</ol>
<p><em>This looks complex. Is there a simpler way?</em></p>
<p>Yes we have options for doing <strong>SPI on NuttX</strong>‚Ä¶</p>
<ol>
<li>
<p>If our SPI Device is supported by an <strong>existing NuttX Device Driver</strong>, just go ahead and use the driver!</p>
<p><a href="https://github.com/apache/incubator-nuttx/tree/master/drivers">(Browse the NuttX Device Drivers)</a></p>
</li>
<li>
<p>If we‚Äôre transferring data over SPI <strong>for testing only</strong> (not for a real app), we may call the <a href="https://github.com/apache/incubator-nuttx/blob/master/include/nuttx/spi/spi_transfer.h"><strong>SPI Transfer Interface</strong></a></p>
<p><a href="https://github.com/apache/incubator-nuttx-apps/blob/master/system/spi">(Here‚Äôs how‚Ä¶ It‚Äôs complicated)</a></p>
</li>
<li>
<p>But today we experiment with a <strong>Custom Device Driver</strong> that will talk to our own SPI Device.</p>
<p>That‚Äôs why we‚Äôre building the <strong>SPI Test Driver</strong>.</p>
<p>(Eventually we‚Äôll build a LoRaWAN Driver for Semtech SX1262)</p>
</li>
</ol>
<p><em>Can our app call the BL602 / ESP32 SPI Driver directly?</em></p>
<p>Nope that‚Äôs not supported by NuttX. (Unlike other embedded operating systems)</p>
<p>It might seemingly work on BL602 and ESP32, but it will fail on platforms with <strong>Memory Protection</strong>.</p>
<p>(Imagine a Linux App directly calling a Kernel Driver‚Ä¶ That‚Äôs no-no!)</p>
<p>Later we‚Äôll see the layers of code that abstract the BL602 / ESP32 SPI Driver from our NuttX App.</p>
<p><a href="https://www.linkedin.com/feed/update/urn:li:activity:6871062176673742848/?commentUrn=urn%3Ali%3Acomment%3A%28activity%3A6871062176673742848%2C6871868918772846592%29&amp;replyUrn=urn%3Ali%3Acomment%3A%28activity%3A6871062176673742848%2C6871912576393986048%29">(Thanks to Alan Carvalho de Assis for the tip!)</a></p>
<p><em>Must everything be done through the read() and write() interfaces?</em></p>
<p>There‚Äôs another POSIX Interface that‚Äôs supported by NuttX: <strong>ioctl()</strong>.</p>
<p>We‚Äôll see this when we cover the NuttX Device Driver for Semtech SX1276.</p>
<p><img src="https://lupyuen.github.io/images/spi2-plan2.jpg" alt="SPI Test Driver" /></p>
<h1 id="inside-the-spi-test-driver" class="section-header"><a href="#inside-the-spi-test-driver">2 Inside the SPI Test Driver</a></h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>Let‚Äôs study the code in our <strong>SPI Test Driver</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/drivers/rf/spi_test_driver.c"><strong>drivers/rf/spi_test_driver.c</strong></a></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/include/nuttx/rf/spi_test_driver.h">(Header File)</a></p>
</li>
</ul>
<p>We created the SPI Test Driver by cloning another device driver, as explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#appendix-create-a-nuttx-device-driver"><strong>‚ÄúCreate a NuttX Device Driver‚Äù</strong></a></li>
</ul>
<p>In the following sections we explain the SPI features that we have implemented in the driver.</p>
<p><img src="https://lupyuen.github.io/images/spi2-driver2a.png" alt="File operations implemented by our driver" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L80-L89">(Source)</a></p>
<h2 id="file-operations" class="section-header"><a href="#file-operations">2.1 File Operations</a></h2>
<p>Every <a href="https://nuttx.apache.org/docs/latest/components/drivers/character/index.html"><strong>NuttX Character Device Driver</strong></a> defines a list of supported <strong>File Operations</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>open()</strong>: Open the driver</p>
</li>
<li>
<p><strong>close()</strong>: Close the driver</p>
</li>
<li>
<p><strong>read()</strong>: Read data</p>
</li>
<li>
<p><strong>write()</strong>: Write data</p>
</li>
<li>
<p><strong>ioctl()</strong>: Other operations</p>
</li>
</ul>
<p>(Plus others: seek(), poll(), ‚Ä¶)</p>
<p>Our driver defines the File Operations like so: <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L88-L97">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static const struct file_operations g_spi_test_driver_fops =
{
  spi_test_driver_open,
  spi_test_driver_close,
  spi_test_driver_read,
  spi_test_driver_write,
  NULL,  /* Seek not implemented */
  spi_test_driver_ioctl,
  NULL   /* Poll not implemented */
};

/* In spi_test_driver_register() we register the character driver */

register_driver(
  devpath, 
  &amp;g_spi_test_driver_fops, 
  0666, 
  priv);</code></pre></div>
<p><strong>spi_test_driver_register()</strong> and <strong>register_driver()</strong> are called during NuttX Startup, as explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#register-device-driver"><strong>‚ÄúRegister Device Driver‚Äù</strong></a></li>
</ul>
<p>Our driver implements the <strong>write()</strong> and <strong>read()</strong> operations to transfer data over SPI.</p>
<p>(They will be called by our <strong>SPI Test App</strong>, as we‚Äôll see later)</p>
<p><em>SPI is a full-duplex protocol. How will we implement read() and write()?</em></p>
<p>To simplify our SPI Test Driver, the <strong>read operation shall be buffered</strong>‚Ä¶</p>
<ol>
<li>
<p><strong>write()</strong> transmits the provided data over SPI</p>
</li>
<li>
<p>And saves the received data into the <strong>Receive Buffer</strong></p>
</li>
<li>
<p>Then <strong>read()</strong> returns the received data from the <strong>Receive Buffer</strong></p>
</li>
</ol>
<p>The <strong>Receive Buffer</strong> is defined like so: <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L99-L101">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static char recv_buffer[256];  /* Buffer for SPI response */

static int recv_buffer_len = 0;  /* Length of SPI response */</code></pre></div>
<p>Let‚Äôs dive into the write() and read() operations.</p>
<h2 id="write-operation" class="section-header"><a href="#write-operation">2.2 Write Operation</a></h2>
<p>In the write() operation for our SPI Test Driver, we‚Ä¶</p>
<ol>
<li>
<p><strong>Lock</strong> the SPI Bus</p>
</li>
<li>
<p><strong>Configure</strong> the SPI Interface</p>
</li>
<li>
<p><strong>Select</strong> the SPI Device</p>
</li>
<li>
<p><strong>Transfer</strong> SPI Data</p>
</li>
<li>
<p><strong>Deselect</strong> the device and <strong>unlock</strong> the bus</p>
</li>
</ol>
<p>Below is the implementation: <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L168-L208">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Write the buffer to the SPI device */

static ssize_t spi_test_driver_write(
  FAR struct file *filep,
  FAR const char *buffer,
  size_t buflen)
{
  DEBUGASSERT(buflen &lt;= sizeof(recv_buffer));  /* TODO: Range eheck */
  DEBUGASSERT(buffer != NULL);
  DEBUGASSERT(filep  != NULL);

  /* Get the SPI interface */

  FAR struct inode *inode = filep-&gt;f_inode;
  DEBUGASSERT(inode != NULL);
  FAR struct spi_test_driver_dev_s *priv = inode-&gt;i_private;
  DEBUGASSERT(priv != NULL);</code></pre></div>
<p>We begin by fetching the <strong>SPI Interface</strong> from the File Struct.</p>
<p>Next we <strong>lock the SPI Bus</strong> and <strong>configure the SPI Interface</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Lock the SPI bus and configure the SPI interface */

  DEBUGASSERT(priv-&gt;spi != NULL);
  SPI_LOCK(priv-&gt;spi, true);
  spi_test_driver_configspi(priv-&gt;spi);</code></pre></div>
<p>(We‚Äôll see <strong>spi_test_driver_configspi</strong> in a while)</p>
<p>We <strong>select the SPI Device</strong> by pulling SPI Chip Select to Low‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Select the SPI device (unused for BL602) */

  SPI_SELECT(priv-&gt;spi, priv-&gt;spidev, true);</code></pre></div>
<p>(This has no effect on BL602. The SPI Hardware automatically sets Chip Select to Low during SPI transfer)</p>
<p>Then we <strong>transfer the data</strong> over SPI (transmit and receive)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Transmit buffer to SPI device and receive the response */

  SPI_EXCHANGE(priv-&gt;spi, buffer, recv_buffer, buflen);
  recv_buffer_len = buflen;</code></pre></div>
<p>Note that the received data goes into our <strong>Receive Buffer</strong>.</p>
<p>(Which will be returned in the read() operation)</p>
<p>Finally we <strong>deselect the device</strong> and <strong>unlock the bus</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Deselect the SPI device (unused for BL602) */

  SPI_SELECT(priv-&gt;spi, priv-&gt;spidev, false);

  /* Unlock the SPI bus */

  SPI_LOCK(priv-&gt;spi, false);

  return buflen;
}</code></pre></div>
<p>The return value is the number of bytes transferred.</p>
<p>(Deselect has no effect on BL602. The SPI Hardware automatically sets Chip Select to High after SPI transfer)</p>
<p><em>What are SPI_LOCK, SPI_SELECT and SPI_EXCHANGE?</em></p>
<p>That‚Äôs the <strong>SPI Interface</strong> for NuttX. We‚Äôll cover this in the Appendix.</p>
<p><img src="https://lupyuen.github.io/images/spi2-driver2.png" alt="Write Operation" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L168-L208">(Source)</a></p>
<h2 id="read-operation" class="section-header"><a href="#read-operation">2.3 Read Operation</a></h2>
<p>Remember that the write() operation has saved the received SPI data into the <strong>Receive Buffer</strong>.</p>
<p>Thus for the read() operation we simply return the data in the Receive Buffer: <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L210-L233">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Return the data received from the SPI device */

static ssize_t spi_test_driver_read(
  FAR struct file *filep, 
  FAR char *buffer,
  size_t buflen)
{
  DEBUGASSERT(filep  != NULL);
  DEBUGASSERT(buffer != NULL);

  /* Copy the SPI response to the buffer */

  DEBUGASSERT(recv_buffer_len &gt;= 0);
  DEBUGASSERT(recv_buffer_len &lt;= buflen);  /* TODO: Range check */
  memcpy(buffer, recv_buffer, recv_buffer_len);

  /* Return the number of bytes read */

  return recv_buffer_len;
}</code></pre></div><h2 id="configure-spi" class="section-header"><a href="#configure-spi">2.4 Configure SPI</a></h2>
<p>Earlier we called <strong>spi_test_driver_configspi</strong> to configure the SPI Interface.</p>
<p>Below is the implementation: <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L107-L129">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static inline void spi_test_driver_configspi(FAR struct spi_dev_s *spi)
{
  DEBUGASSERT(spi != NULL);

  /* Set SPI Mode (Polarity and Phase) and Transfer Size (8 bits) */

  SPI_SETMODE(spi, SPI_TEST_DRIVER_SPI_MODE);
  SPI_SETBITS(spi, 8);

  /* Set SPI Hardware Features and Frequency */

  SPI_HWFEATURES(spi, 0);
  SPI_SETFREQUENCY(spi, CONFIG_SPI_TEST_DRIVER_SPI_FREQUENCY);
}</code></pre></div>
<p>(SPI_SETMODE, SPI_SETBITS, SPI_HWFEATURES and SPI_SETFREQUENCY are defined in the NuttX SPI Interface)</p>
<p>The code above configures the SPI Interface as follows‚Ä¶</p>
<ul>
<li>
<p><strong>SPI Mode</strong> (Polarity Phase): 0</p>
<p>(For BL602 we‚Äôre using Mode 1)</p>
</li>
<li>
<p><strong>SPI Transfer Size</strong>: 8 bits</p>
</li>
<li>
<p><strong>SPI Hardware Features</strong>: None</p>
</li>
<li>
<p><strong>SPI Frequency</strong>: 1 MHz</p>
</li>
</ul>
<p><strong>SPI Mode</strong> and <strong>SPI Frequency</strong> are defined below: <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L45-L57">spi_test_driver.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* We set SPI Frequency to 1 MHz */

#ifndef CONFIG_SPI_TEST_DRIVER_SPI_FREQUENCY
#define CONFIG_SPI_TEST_DRIVER_SPI_FREQUENCY 1000000
#endif /* CONFIG_SPI_TEST_DRIVER_SPI_FREQUENCY */

/* For BL602 we use SPI Mode 1 instead of Mode 0 due to SPI quirk */

#ifdef CONFIG_BL602_SPI0
#define SPI_TEST_DRIVER_SPI_MODE (SPIDEV_MODE1) /* SPI Mode 1: Workaround for BL602 */
#else
#define SPI_TEST_DRIVER_SPI_MODE (SPIDEV_MODE0) /* SPI Mode 0: CPOL=0,CPHA=0 */
#endif /* CONFIG_BL602_SPI0 */</code></pre></div>
<p>BL602 uses <strong>SPI Mode 1</strong> (instead of Mode 0) because of an <strong>SPI Mode Quirk</strong> in BL602. </p>
<p>(More about this in the Appendix)</p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver4.png" alt="Register SPI Test Driver at startup" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/newdriver/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L599-L617">(Source)</a></p>
<h1 id="load-the-spi-test-driver" class="section-header"><a href="#load-the-spi-test-driver">3 Load the SPI Test Driver</a></h1>
<p><em>(For BL602 and ESP32)</em></p>
<p><em>How do we load our SPI Test Driver at startup?</em></p>
<p>During NuttX Startup, we <strong>load our SPI Test Driver</strong> like so: <a href="https://github.com/lupyuen/incubator-nuttx/blob/newdriver/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L599-L617">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>int bl602_bringup(void)
{
  ...
#ifdef CONFIG_RF_SPI_TEST_DRIVER

  /* Init SPI bus again */

  struct spi_dev_s *spitest = bl602_spibus_initialize(0);
  if (!spitest)
    {
      _err(&quot;ERROR: Failed to initialize SPI %d bus\n&quot;, 0);
    }

  /* Register the SPI Test Driver */

  ret = spi_test_driver_register(&quot;/dev/spitest0&quot;, spitest, 0);
  if (ret &lt; 0)
    {
      _err(&quot;ERROR: Failed to register SPI Test Driver\n&quot;);
    }

#endif /* CONFIG_RF_SPI_TEST_DRIVER */</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/newdriver/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L367-L620"><strong>bl602_bringup</strong></a> is the NuttX Startup Function for BL602.</p>
<p>(<a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L118-L426"><strong>esp32_bringup</strong></a> for ESP32)</p>
<p>We modified the Startup Function to <strong>register our SPI Test Driver</strong>, which loads the driver into NuttX at startup.</p>
<p>Let‚Äôs run NuttX on BL602 / ESP32 and check that our <strong>SPI Test Driver loads correctly</strong>‚Ä¶</p>
<ol>
<li>
<p>Install the build prerequisites‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Download the modified source code‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>mkdir nuttx
cd nuttx
git clone --branch spi_test https://github.com/lupyuen/incubator-nuttx nuttx
git clone --branch spi_test https://github.com/lupyuen/incubator-nuttx-apps apps</code></pre></div></li>
<li>
<p>Configure the build‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cd nuttx

# For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

# For ESP32: Configure the build for ESP32.
# TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

# Edit the Build Config
make menuconfig </code></pre></div></li>
<li>
<p>Enable the SPI Peripheral and SPI Character Driver in menuconfig‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-spi"><strong>‚ÄúEnable SPI‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-debug.png" alt="Enable SPI" /></p>
</li>
<li>
<p>Enable our SPI Test Driver‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-spi"><strong>‚ÄúEnable SPI‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver6.png" alt="Select SPI Test Driver" /></p>
</li>
<li>
<p>Enable SPI logging for easier troubleshooting‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-logging"><strong>‚ÄúEnable Logging‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-driver4.png" alt="Enable logging" /></p>
</li>
<li>
<p>Save the configuration and exit menuconfig</p>
</li>
<li>
<p><strong>For ESP32:</strong> Edit <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L118-L426"><strong>esp32_bringup.c</strong></a> to register our SPI Test Driver <a href="https://lupyuen.github.io/articles/spi2#register-device-driver">(See this)</a></p>
</li>
<li>
<p>Build (‚Äúmake‚Äù), flash and run the NuttX Firmware on BL602 or ESP32</p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>ls /dev</code></pre></div>
<p>Our SPI Test Driver appears as <strong>‚Äú/dev/spitest0‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver10.png" alt="Our SPI Test Driver appears as ‚Äú/dev/spitest0‚Äù" /></p>
<p>Congratulations NuttX has loaded our Device Driver!</p>
<p>Let‚Äôs talk about our SPI Test App.</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/spi2-plan3.jpg" alt="SPI Test App" /></p>
<h1 id="inside-the-spi-test-app" class="section-header"><a href="#inside-the-spi-test-app">4 Inside the SPI Test App</a></h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>We‚Äôve seen the write() and read() operations in our SPI Test Driver.  Now we learn how they are called by our <strong>SPI Test App</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/spi_test/examples/spi_test"><strong>examples/spi_test</strong></a></li>
</ul>
<p>We created the SPI Test App by cloning another app, as explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#appendix-create-a-nuttx-app"><strong>‚ÄúCreate a NuttX App‚Äù</strong></a></li>
</ul>
<p>We‚Äôll do the following in our SPI Test App‚Ä¶</p>
<ol>
<li>
<p><strong>Open</strong> our SPI Test Driver</p>
</li>
<li>
<p><strong>Transmit</strong> data over SPI</p>
</li>
<li>
<p><strong>Receive</strong> data over SPI</p>
</li>
<li>
<p><strong>Close</strong> our SPI Test Driver</p>
</li>
</ol>
<h2 id="open-spi-test-driver" class="section-header"><a href="#open-spi-test-driver">4.1 Open SPI Test Driver</a></h2>
<p>Earlier we saw that our SPI Test Driver appears in NuttX as <strong>‚Äú/dev/spitest0‚Äù</strong></p>
<p>Let‚Äôs open the driver: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/spi_test/examples/spi_test/spi_test_main.c">spi_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>int main(int argc, FAR char *argv[])
{
  /* Open SPI Test Driver */

  int fd = open(&quot;/dev/spitest0&quot;, O_RDWR);
  assert(fd &gt;= 0);  /* TODO: Handle error */</code></pre></div>
<p>(Yep this looks very Linux-like!)</p>
<p><strong>open()</strong> returns a <strong>File Descriptor</strong> that we‚Äôll use to transmit and receive data over SPI.</p>
<h2 id="transmit-spi-data" class="section-header"><a href="#transmit-spi-data">4.2 Transmit SPI Data</a></h2>
<p>Our SPI Test Driver implements a <strong>write()</strong> operation that will transmit SPI data.</p>
<p>We call it like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Write to SPI Test Driver */

  static char data[] = &quot;Hello World&quot;;
  int bytes_written = write(fd, data, sizeof(data));
  assert(bytes_written == sizeof(data));</code></pre></div>
<p>This transmits the string <strong>‚ÄúHello World‚Äù</strong> to our SPI Device.</p>
<p>(Including the terminating null character)</p>
<h2 id="receive-spi-data" class="section-header"><a href="#receive-spi-data">4.3 Receive SPI Data</a></h2>
<p>Remember that the <strong>write()</strong> operation will actually transmit and receive SPI data at the same time.</p>
<p>We read the received SPI data by calling <strong>read()</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Read response from SPI Test Driver */

  static char rx_data[256];  /* Buffer for SPI response */
  int bytes_read = read(fd, rx_data, sizeof(rx_data));
  assert(bytes_read == sizeof(get_status));</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c#L65-L69">(Source)</a></p>
<p>This code isn‚Äôt in our SPI Test App, we‚Äôll see this later when we test with Semtech SX1262.</p>
<h2 id="close-spi-test-driver" class="section-header"><a href="#close-spi-test-driver">4.4 Close SPI Test Driver</a></h2>
<p>Finally we close the File Descriptor for our SPI Test Driver‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Close SPI Test Driver */

  close(fd);
  return 0;
}</code></pre></div>
<p>Let‚Äôs run our SPI Test App!</p>
<p><img src="https://lupyuen.github.io/images/spi2-app4.png" alt="SPI Test App" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/spi_test/examples/spi_test/spi_test_main.c">(Source)</a></p>
<h1 id="run-the-spi-test-app" class="section-header"><a href="#run-the-spi-test-app">5 Run the SPI Test App</a></h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>Follow these steps to run our SPI Test App on BL602 or ESP32‚Ä¶</p>
<ol>
<li>
<p>Assume that we have downloaded and configured our NuttX code‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#load-the-spi-test-driver"><strong>‚ÄúLoad the SPI Test Driver‚Äù</strong></a></p>
</li>
<li>
<p>Edit the build configuration‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>make menuconfig</code></pre></div></li>
<li>
<p>Enable our SPI Test App in menuconfig‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-app"><strong>‚ÄúEnable App‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-newapp4.png" alt="Enable SPI Test App in menuconfig" /></p>
</li>
<li>
<p>Save the configuration and exit menuconfig</p>
</li>
<li>
<p>Build (‚Äúmake‚Äù), flash and run the NuttX Firmware on BL602 or ESP32</p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>spi_test</code></pre></div></li>
<li>
<p>We should see every byte transmitted and received over SPI.</p>
<p>(Thanks to SPI Logging!)</p>
<p>The pic below shows that our app has transmitted the string <strong>‚ÄúHello World‚Äù</strong> (plus the terminating null) over SPI.</p>
<p>But because we‚Äôre not connected to any SPI Device, we don‚Äôt receive any meaningful response. (It‚Äôs all <code>0xFF</code>)</p>
<p><img src="https://lupyuen.github.io/images/spi2-app3.png" alt="SPI Test App" /></p>
</li>
</ol>
<h1 id="test-with-logic-analyser" class="section-header"><a href="#test-with-logic-analyser">6 Test with Logic Analyser</a></h1>
<p><em>(For BL602 and ESP32)</em></p>
<p><em>How do we check if our app is transmitting SPI data correctly?</em></p>
<p>Let‚Äôs connect a <strong>Logic Analyser</strong> to BL602 / ESP32 and verify the SPI output‚Ä¶</p>
<div><table><thead><tr><th align="center">Logic Analyser</th><th align="center">BL602 Pin</th><th align="center">ESP32 Pin</th></tr></thead><tbody>
<tr><td align="center"><strong>MOSI</strong></td><td align="center">GPIO 1</td><td align="center">GPIO 13</td></tr>
<tr><td align="center"><strong>MISO</strong></td><td align="center">GPIO 0</td><td align="center">GPIO 12</td></tr>
<tr><td align="center"><strong>SCK</strong></td><td align="center">GPIO 3</td><td align="center">GPIO 14</td></tr>
<tr><td align="center"><strong>CS</strong></td><td align="center">GPIO 2</td><td align="center">GPIO 15</td></tr>
<tr><td align="center"><strong>GND</strong></td><td align="center">GND</td><td align="center">GND</td></tr>
</tbody></table>
</div>
<p><img src="https://lupyuen.github.io/images/spi2-logic4.jpg" alt="Logic Analyser connected to PineCone BL602" /></p>
<p><em>How did we get the GPIO Pin Numbers for the SPI Port?</em></p>
<p><strong>For BL602:</strong> SPI Pins are defined in <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/boards/risc-v/bl602/bl602evb/include/board.h#L87-L92">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define BOARD_SPI_CS   (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN2)
#define BOARD_SPI_MOSI (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN1)
#define BOARD_SPI_MISO (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN0)
#define BOARD_SPI_CLK  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN3)</code></pre></div>
<p><strong>For ESP32:</strong> SPI Pins are defined in <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/arch/xtensa/src/esp32/Kconfig#L799-L817">Kconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>config ESP32_SPI2_CSPIN
	int &quot;SPI2 CS Pin&quot;
	default 15
	range 0 39

config ESP32_SPI2_CLKPIN
	int &quot;SPI2 CLK Pin&quot;
	default 14
	range 0 39

config ESP32_SPI2_MOSIPIN
	int &quot;SPI2 MOSI Pin&quot;
	default 13
	range 0 39

config ESP32_SPI2_MISOPIN
	int &quot;SPI2 MISO Pin&quot;
	default 12
	range 0 39</code></pre></div>
<p>When we run <strong>‚Äúspi_test‚Äù</strong>, we see this in our Logic Analyser‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-logic2.png" alt="Running spi_test and observing the Logic Analyser" /></p>
<p>This looks OK! Though MISO is idle because it‚Äôs not connected to an SPI Device.</p>
<p>Let‚Äôs test with a real SPI Device: Semtech SX1262.</p>
<p>(BL602 has a quirk that swaps MISO and MOSI, the fix is explained in the Appendix)</p>
<h1 id="control-chip-select-with-gpio" class="section-header"><a href="#control-chip-select-with-gpio">7 Control Chip Select with GPIO</a></h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>If we zoom out the above display in the Logic Analyser, we see a problem with <strong>SPI Chip Select on BL602</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-logic3.png" alt="Chip Select goes Low after every byte" /></p>
<p>BL602 sets Chip Select to <strong>High after EVERY byte</strong>!</p>
<p>This will be a problem for <strong>Semtech SX1262</strong>‚Ä¶</p>
<p>It expects Chip Select to be <strong>High after the entire multi-byte command</strong> has been transmitted! (Not after every byte)</p>
<p>(I don‚Äôt think ESP32 has this problem, please lemme know! üôè)</p>
<p><em>Can we control SPI Chip Select ourselves?</em></p>
<p>Yes, we may control Chip Select ourselves with the <strong>GPIO Output</strong> function in NuttX.</p>
<p>This means we designate a <strong>GPIO Output Pin</strong> that will be used for Chip Select.</p>
<p>And we call NuttX to flip the pin Low and High, before and after each SPI transfer.</p>
<p><em>Is there another reason for controlling Chip Select with GPIO?</em></p>
<p>On many BL602 / ESP32 boards, the SPI Bus (MISO, MOSI and SCK) is <strong>shared by multiple SPI Devices</strong>.</p>
<p>But each SPI Device has its own <strong>Chip Select Pin</strong>.</p>
<p>For such boards we‚Äôll have to control each Chip Select Pin with GPIO.</p>
<p><a href="https://lupyuen.github.io/articles/pinedio">(PineDio Stack BL604 shares its SPI Bus with SX1262 Transceiver, ST7789 Display and SPI Flash)</a></p>
<h2 id="gpio-output-as-chip-select" class="section-header"><a href="#gpio-output-as-chip-select">7.1 GPIO Output as Chip Select</a></h2>
<p>Let‚Äôs look at the code in <strong>SPI Test App #2</strong> that controls Chip Select with GPIO: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c#L42-L74">spi_test2_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Open GPIO Output for SPI Chip Select */

int cs = open(&quot;/dev/gpout1&quot;, O_RDWR);
assert(cs &gt;= 0);  /* TODO: Handle error */</code></pre></div>
<p>This is new: We open the GPIO Output device <strong>‚Äú/dev/gpout1‚Äù</strong> for the SPI Chip Select Pin.</p>
<p>Next we <strong>open our SPI Test Driver</strong> as before‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* Open SPI Test Driver */

int fd = open(&quot;/dev/spitest0&quot;, O_RDWR);
assert(fd &gt;= 0);</code></pre></div>
<p>Then we set our <strong>GPIO Output / Chip Select</strong> to Low by calling <strong>ioctl()</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* Set SPI Chip Select to Low */

int ret = ioctl(cs, GPIOC_WRITE, 0);
assert(ret &gt;= 0);</code></pre></div>
<p>Now that the SPI Device is active, we can <strong>transmit and receive</strong> our SPI data‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* Transmit command to SX1262: Get Status */

static char get_status[] = { 0xc0, 0x00 };
int bytes_written = write(fd, get_status, sizeof(get_status));
assert(bytes_written == sizeof(get_status));

/* Read response from SX1262 */

static char rx_data[256];  /* Buffer for SPI response */
int bytes_read = read(fd, rx_data, sizeof(rx_data));
assert(bytes_read == sizeof(get_status));</code></pre></div>
<p>(We‚Äôll explain <strong>get_status</strong> in the next section)</p>
<p>Finally we set our <strong>GPIO Output / Chip Select</strong> to High‚Ä¶ </p>
<div class="example-wrap"><pre class="language-c"><code>/* Set SPI Chip Select to High */

ret = ioctl(cs, GPIOC_WRITE, 1);
assert(ret &gt;= 0);

/* Close SPI Test Driver and GPIO Output */

close(fd);
close(cs);</code></pre></div>
<p>And close the SPI Test Driver and GPIO Output.</p>
<p>Let‚Äôs watch SPI Test App #2 in action with Semtech SX1262.</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#gpio-demo">(More about GPIO Output)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-sx5.png" alt="Control Chip Select with GPIO" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c#L42-L74">(Source)</a></p>
<h1 id="test-with-semtech-sx1262" class="section-header"><a href="#test-with-semtech-sx1262">8 Test with Semtech SX1262</a></h1>
<p><em>(For BL602 and ESP32)</em></p>
<p><a href="https://www.semtech.com/products/wireless-rf/lora-core/sx1262"><strong>Semtech SX1262</strong></a> is a LoRa Transceiver (Radio Transmitter + Receiver) that‚Äôs not yet supported by NuttX.</p>
<p><a href="https://github.com/apache/incubator-nuttx/tree/master/drivers/wireless/lpwan/sx127x">(Though the older model SX1276 is supported by NuttX)</a></p>
<p>Today we shall send two short commands to SX1262 for testing‚Ä¶</p>
<ul>
<li>
<p><strong>Get Status:</strong> We transmit this sequence of bytes to SX1262‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>C0 00</code></pre></div>
<p>We expect the SPI Response to look like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>A2 22</code></pre></div>
<p>(The response might get muddled, we‚Äôll learn why in a while)</p>
</li>
<li>
<p><strong>Read Register 0x08:</strong>  We transmit this sequence of bytes to SX1262‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>1D 00 08 00 00</code></pre></div>
<p>We expect the SPI Response to end with <strong><code>0x80</code></strong> like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>A2 A2 A2 A2 80</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/lorawan#troubleshoot-lorawan">(Register <code>0x08</code> is expected to have value <code>0x80</code> at startup)</a></p>
</li>
</ul>
<p>We send the <strong>‚ÄúGet Status‚Äù</strong> command with this code: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c#L59-L83">spi_test2_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Transmit command to SX1262: Get Status */

static char get_status[] = { 0xc0, 0x00 };
int bytes_written = write(fd, get_status, sizeof(get_status));
assert(bytes_written == sizeof(get_status));

/* Read response from SX1262 */

static char rx_data[256];  /* Buffer for SPI response */
int bytes_read = read(fd, rx_data, sizeof(rx_data));
assert(bytes_read == sizeof(get_status));

/* Show the received status */

printf(&quot;\nSX1262 Status is %d\n&quot;, (rx_data[1] &gt;&gt; 4) &amp; 0b111);  /* Bits 6:4 */</code></pre></div>
<p>And the <strong>‚ÄúRead Register 0x08‚Äù</strong> command with this code: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c#L94-L117">spi_test2_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Transmit command to SX1262: Read Register 8 */

static char read_reg[] = { 0x1d, 0x00, 0x08, 0x00, 0x00 };
bytes_written = write(fd, read_reg, sizeof(read_reg));
assert(bytes_written == sizeof(read_reg));

/* Read response from SX1262 */

bytes_read = read(fd, rx_data, sizeof(rx_data));
assert(bytes_read == sizeof(read_reg));

/* Show the received register value */

printf(&quot;\nSX1262 Register 8 is 0x%02x\n&quot;, rx_data[4]);</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c">(See the complete program)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-sx6.png" alt="Transmit command to SX1262: Read Register 0x08" /></p>
<h2 id="connect-sx1262" class="section-header"><a href="#connect-sx1262">8.1 Connect SX1262</a></h2>
<p>We connect SX1262 to BL602 / ESP32 as follows‚Ä¶</p>
<div><table><thead><tr><th align="center">SX1262</th><th align="center">BL602 Pin</th><th align="center">ESP32 Pin</th><th align="center">Colour</th></tr></thead><tbody>
<tr><td align="center"><strong>MOSI</strong></td><td align="center">GPIO 1</td><td align="center">GPIO 13</td><td align="center">Yellow</td></tr>
<tr><td align="center"><strong>MISO</strong></td><td align="center">GPIO 0</td><td align="center">GPIO 12</td><td align="center">Light Green</td></tr>
<tr><td align="center"><strong>SCK</strong></td><td align="center">GPIO 3</td><td align="center">GPIO 14</td><td align="center">Blue</td></tr>
<tr><td align="center"><strong>CS</strong></td><td align="center">GPIO 11</td><td align="center">GPIO 15 / 16</td><td align="center">Dark Green</td></tr>
<tr><td align="center"><strong>VCC</strong></td><td align="center">3V3</td><td align="center">3V3</td><td align="center">Red</td></tr>
<tr><td align="center"><strong>GND</strong></td><td align="center">GND</td><td align="center">GND</td><td align="center">Black</td></tr>
</tbody></table>
</div>
<p>(We don‚Äôt need all the pins connected, we‚Äôre testing simple commands)</p>
<p>Here‚Äôs SX1262 connected to PineCone BL602‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-title.jpg" alt="SX1262 connected to PineCone BL602" /></p>
<p><em>Why did we connect Chip Select to GPIO 11 / 15 / 16?</em></p>
<p>Remember that we‚Äôre controlling SPI Chip Select ourselves through <strong>GPIO Output</strong>, which is defined as follows‚Ä¶</p>
<p><strong>For BL602:</strong> GPIO Output Pin is defined as <strong>GPIO 11</strong> in <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/boards/risc-v/bl602/bl602evb/include/board.h#L48-L49">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define BOARD_GPIO_OUT1 \
  (GPIO_OUTPUT | GPIO_FLOAT | \
  GPIO_FUNC_SWGPIO | GPIO_PIN11)</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/nuttx#configure-pins">(More about this)</a></p>
<p><strong>For ESP32:</strong> GPIO Output Pin depends on our ESP32 Board (and may be customised)‚Ä¶</p>
<p>ESP32-DevKitC defines <strong>GPIO 15</strong> as the default GPIO Output Pin: <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src/esp32_gpio.c#L43-L67">esp32_gpio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Output pins. GPIO15 is used as an example, any other outputs could be used. */

#define GPIO_OUT1    15</code></pre></div>
<p>ESP32-WROVER-KIT uses <strong>GPIO 16</strong>: <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/boards/xtensa/esp32/esp32-wrover-kit/src/esp32_gpio.c#L43-L67">esp32_gpio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define GPIO_OUT1    16</code></pre></div>
<p>TTGO-LoRa-ESP32 uses <strong>GPIO 15</strong>: <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/boards/xtensa/esp32/ttgo_lora_esp32/src/esp32_gpio.c#L43-L67">esp32_gpio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define GPIO_OUT1    15</code></pre></div><h2 id="test-sx1262" class="section-header"><a href="#test-sx1262">8.2 Test SX1262</a></h2>
<p>Follow these steps to run our SPI Test App #2 on BL602 or ESP32‚Ä¶</p>
<ol>
<li>
<p>Assume that we have downloaded and configured our NuttX code‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#load-the-spi-test-driver"><strong>‚ÄúLoad the SPI Test Driver‚Äù</strong></a></p>
</li>
<li>
<p>Edit the build configuration‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>make menuconfig</code></pre></div></li>
<li>
<p>Enable the GPIO Driver‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#enable-gpio-driver"><strong>‚ÄúEnable GPIO Driver‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-menu7a.png" alt="Enable the GPIO Driver" /></p>
</li>
<li>
<p>Hit ‚ÄúExit‚Äù until the Top Menu appears</p>
<p>(‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
</li>
<li>
<p>Enable SPI Test App #2‚Ä¶</p>
<p>Select <strong>‚ÄúApplication Configuration‚Äù</strong> ‚Üí <strong>‚ÄúExamples‚Äù</strong></p>
<p>Check the box for <strong>‚Äúspi_test2‚Äù</strong></p>
</li>
<li>
<p>Save the configuration and exit menuconfig</p>
</li>
<li>
<p>Build (‚Äúmake‚Äù), flash and run the NuttX Firmware on BL602 or ESP32</p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>spi_test2</code></pre></div>
<p>(Pic below)</p>
</li>
<li>
<p>We should see the output from the <strong>‚ÄúGet Status‚Äù</strong> command‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Get Status: received
  8a 8a
SX1262 Status is 0</code></pre></div>
<p>(This output is not quite correct, we‚Äôll explain why in the next section)</p>
</li>
<li>
<p>And the output from the <strong>‚ÄúRead Register 0x08‚Äù</strong> command‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Read Register 8: received
  a8 a8 a8 a8 80
SX1262 Register 8 is 0x80</code></pre></div>
<p>The value of Register 0x08 is correct: <strong><code>0x80</code></strong></p>
<p>Yep our NuttX App is working OK with SX1262!</p>
<p>(BL602 has an SPI Quirk: We must use SPI Mode 1 instead of Mode 0 or the register value will be garbled)</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/spi2-sx.png" alt="SPI Test App #2 reads the SX1262 Register correctly" /></p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio2a.jpg" alt="PineDio Stack BL604" /></p>
<h1 id="test-with-pinedio-stack" class="section-header"><a href="#test-with-pinedio-stack">9 Test with PineDio Stack</a></h1>
<p><em>(For BL604 only)</em></p>
<p>Pine64 has just sent me a prototype of <a href="https://lupyuen.github.io/articles/pinedio"><strong>PineDio Stack BL604</strong></a> (version 2, pic above) with onboard SX1262 Transceiver, ST7789 Display, SPI Flash, GPS, Compass, Touch Panel, Heart Rate Sensor, Vibrator, ‚Ä¶</p>
<p>(Yep multiple devices on the same SPI Bus)</p>
<p>Let‚Äôs test NuttX with PineDio Stack BL604 and its <strong>onboard SX1262</strong>! Here are the innards‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio1.jpg" alt="Inside PineDio Stack BL604" /></p>
<p>Before testing, remember to connect the <strong>LoRa Antenna</strong>‚Ä¶ </p>
<p>(So we don‚Äôt fry the SX1262 Transceiver as we charge up the Power Amplifier)</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio10a.jpg" alt="PineDio Stack BL604 with Antenna" /></p>
<h2 id="pin-definitions" class="section-header"><a href="#pin-definitions">9.1 Pin Definitions</a></h2>
<p>Based on this schematic for PineDio Stack BL604 (version 2)‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio3.png" alt="SX1262 Interface on PineDio Stack" /></p>
</blockquote>
<p>We update the following Pin Definitions in <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L42-L95">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Busy Pin for PineDio SX1262 */

#define BOARD_GPIO_IN1    (GPIO_INPUT | GPIO_FLOAT | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN10)

/* SPI Chip Select for PineDio SX1262 */

#define BOARD_GPIO_OUT1   (GPIO_OUTPUT | GPIO_PULLUP | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN15)

/* GPIO Interrupt (DIO1) for PineDio SX1262 */

#define BOARD_GPIO_INT1   (GPIO_INPUT | GPIO_PULLUP | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN19)

/* SPI Configuration: Chip Select is unused because we control via GPIO instead */

#define BOARD_SPI_CS   (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN8)  /* Unused */
#define BOARD_SPI_MOSI (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN13)
#define BOARD_SPI_MISO (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN0)
#define BOARD_SPI_CLK  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN11)</code></pre></div><h2 id="run-nuttx-on-pinedio-stack" class="section-header"><a href="#run-nuttx-on-pinedio-stack">9.2 Run NuttX on PineDio Stack</a></h2>
<p>TODO</p>
<ol>
<li>
<p>Assume that we have downloaded and configured our NuttX code‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#load-the-spi-test-driver"><strong>‚ÄúLoad the SPI Test Driver‚Äù</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/spi2#test-sx1262"><strong>‚ÄúTest SX1262‚Äù</strong></a></p>
</li>
<li>
<p>Edit the <strong>Pin Defitions</strong> as shown above‚Ä¶</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L42-L95">boards/risc-v/bl602/bl602evb/include/board.h</a> </p>
</li>
<li>
<p>Build (‚Äúmake‚Äù), flash and run the NuttX Firmware on PineDio Stack BL604</p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>spi_test2</code></pre></div>
<p>(Pic below)</p>
</li>
<li>
<p>We should see the output from the <strong>‚ÄúGet Status‚Äù</strong> command‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Get Status: received
  a2 22
SX1262 Status is 2</code></pre></div>
<p>(This looks different from the BL602 output, we‚Äôll explain why in a while)</p>
</li>
<li>
<p>And the output from the <strong>‚ÄúRead Register 0x08‚Äù</strong> command‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Read Register 8: received
  a2 a2 a2 a2 80
SX1262 Register 8 is 0x80</code></pre></div>
<p>The value of Register 0x08 is correct: <strong><code>0x80</code></strong></p>
<p>Our SPI Test App #2 runs OK on PineDio Stack BL604 with onboard SX1262! üéâ</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio2.png" alt="NuttX on PineDio Stack BL604" /></p>
<p><em>Why did the ‚ÄúGet Status‚Äù command return different results?</em></p>
<p>TODO</p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">10 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>I‚Äôm new to NuttX but I had lots of fun experimenting with it. I hope you‚Äôll enjoy NuttX too!</p>
<p>Here are some topics I might explore in future articles, lemme know if I should do these‚Ä¶</p>
<ul>
<li>
<p><strong>SPI Driver</strong>: PineDio Stack BL604 has an onboard LoRa SX1262 Transceiver wired via SPI. Great way to test the NuttX SPI Driver for BL602 / BL604!</p>
<p><a href="https://lupyuen.github.io/articles/lorawan2">(More about PineDio Stack BL604)</a></p>
</li>
<li>
<p><strong>LoRaWAN Driver</strong>: Once we get SX1262 talking OK on SPI, we can port the LoRaWAN Driver to NuttX!</p>
<p><a href="https://lupyuen.github.io/articles/lorawan2">(LoRaWAN on PineDio Stack BL604)</a></p>
</li>
<li>
<p><strong>Rust</strong>: Porting the Embedded Rust HAL to NuttX sounds really interesting. We might start with GPIO and SPI to see whether the concept is feasible.</p>
</li>
</ul>
<p>(BL602 IoT SDK / FreeRTOS is revamping right now to the <a href="https://twitter.com/MisterTechBlog/status/1456259223323508748"><strong>new ‚Äúhosal‚Äù HAL</strong></a>. Terrific time to explore NuttX now!)</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/spi2.md"><code>lupyuen.github.io/src/spi2.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">11 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1464898624026906625">this Twitter Thread</a></li>
</ol>
<h1 id="appendix-create-a-nuttx-device-driver" class="section-header"><a href="#appendix-create-a-nuttx-device-driver">12 Appendix: Create a NuttX Device Driver</a></h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>This section explains the steps to create a <strong>NuttX Device Driver</strong> named <strong>‚Äúspi_test_driver‚Äù</strong>.</p>
<p>(Change ‚Äúspi_test_driver‚Äù to the desired name of our driver)</p>
<ol>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/incubator-nuttx/blob/newdriver/drivers/rf"><strong>‚Äúnuttx/nuttx/drivers/rf‚Äù</strong></a> folder</p>
</li>
<li>
<p>Copy the file <strong>‚Äúdat-31r5-sp.c‚Äù</strong> and paste it as <strong>‚Äúspi_test_driver.c‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver.png" alt="Copy ‚Äúdat-31r5-sp.c‚Äù to ‚Äúspi_test_driver.c‚Äù" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/newdriver/drivers/rf/spi_test_driver.c">(Source)</a></p>
</li>
<li>
<p>Inside the <strong>‚Äúspi_test_driver.c‚Äù</strong> file, search and replace all <strong>‚Äúdat31r5sp‚Äù</strong> by <strong>‚Äúspi_test_driver‚Äù</strong></p>
<p>Be sure to <strong>Preserve Case!</strong></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver2.png" alt="Change all ‚Äúdat31r5sp‚Äù to ‚Äúspi_test_driver‚Äù" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/commit/8fee69215163180b77dc9d5b9e7449ebe00ac1cc">(Source)</a></p>
</li>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/incubator-nuttx/blob/newdriver/include/nuttx/rf"><strong>‚Äúnuttx/nuttx/include/nuttx/rf‚Äù</strong></a> folder</p>
</li>
<li>
<p>Copy the file <strong>‚Äúdat-31r5-sp.h‚Äù</strong> and paste it as <strong>‚Äúspi_test_driver.h‚Äù</strong></p>
</li>
<li>
<p>Inside the <strong>‚Äúspi_test_driver.h‚Äù</strong> file, search and replace all <strong>‚Äúdat31r5sp‚Äù</strong> by <strong>‚Äúspi_test_driver‚Äù</strong></p>
<p>Remember to <strong>Preserve Case!</strong></p>
<p>The Header File should look like this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver3.png" alt="spi_test_driver.h" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/newdriver/include/nuttx/rf/spi_test_driver.h">(Source)</a></p>
</li>
</ol>
<h2 id="update-makefile-and-kconfig" class="section-header"><a href="#update-makefile-and-kconfig">12.1 Update Makefile and Kconfig</a></h2>
<p>Now we update the Makefile so that NuttX will build our Device Driver‚Ä¶</p>
<ol>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/incubator-nuttx/blob/newdriver/drivers/rf"><strong>‚Äúnuttx/nuttx/drivers/rf‚Äù</strong></a> folder</p>
</li>
<li>
<p>Edit the file <strong>‚ÄúMake.defs‚Äù</strong></p>
<p>Insert this section‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>ifeq ($(CONFIG_RF_SPI_TEST_DRIVER),y)
  CSRCS += spi_test_driver.c
  RFDEPPATH = --dep-path rf
  RFVPATH = :rf
endif</code></pre></div>
<p>As shown below‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver9.png" alt="Update ‚ÄúMake.defs‚Äù" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/newdriver/drivers/rf/Make.defs#L33-L37">(Source)</a></p>
</li>
<li>
<p>Edit the file <strong>‚ÄúKconfig‚Äù</strong></p>
<p>Insert this section‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>config RF_SPI_TEST_DRIVER
    bool &quot;SPI Test Driver&quot;
    default n
    select SPI
    ---help---
        Enable SPI Test Driver.</code></pre></div>
<p>As shown below‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver5.png" alt="Update ‚ÄúKconfig‚Äù" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/newdriver/drivers/rf/Kconfig#L22-L27">(Source)</a></p>
</li>
<li>
<p>Enter the following‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># TODO: Change this to the path of our &quot;incubator-nuttx&quot; folder
cd nuttx/nuttx

# Preserve the Build Config
cp .config ../config

# Erase the Build Config and Kconfig files
make distclean

# For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

# For ESP32: Configure the build for ESP32.
# TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

# Restore the Build Config
cp ../config .config

# Edit the Build Config
make menuconfig </code></pre></div></li>
</ol>
<h2 id="enable-spi" class="section-header"><a href="#enable-spi">12.2 Enable SPI</a></h2>
<p>We enable SPI and our Device Driver as follows‚Ä¶</p>
<ol>
<li>
<p>In <strong>menuconfig</strong>, select <strong>‚ÄúSystem Type‚Äù</strong></p>
<p><strong>For BL602:</strong> Check the box for <strong>‚ÄúBL602 Peripheral Support‚Äù</strong> ‚Üí <strong>‚ÄúSPI0‚Äù</strong></p>
<p><strong>For ESP32:</strong> Check the box for <strong>‚ÄúESP32 Peripheral Select‚Äù</strong> ‚Üí <strong>‚ÄúSPI 2‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
<p><img src="https://lupyuen.github.io/images/spi2-debug.png" alt="Enable SPI" /></p>
</li>
<li>
<p>At the Top Menu, select <strong>‚ÄúDevice Drivers‚Äù</strong></p>
<p>Select <strong>‚ÄúSPI Driver‚Äù</strong></p>
<p>Check the box for <strong>‚ÄúSPI Character Driver‚Äù</strong></p>
<p>(<strong>‚ÄúSPI Exchange‚Äù</strong> should already be checked, see pic above)</p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> to return to ‚ÄúDevice Drivers‚Äù</p>
</li>
<li>
<p>Under ‚ÄúDevice Drivers‚Äù, check the box for <strong>‚ÄúRF Device Support‚Äù</strong></p>
<p>Go inside <strong>‚ÄúRF Device Support‚Äù</strong></p>
<p>Check the box for <strong>‚ÄúSPI Test Driver‚Äù</strong></p>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until the Top Menu appears. (‚ÄúNuttX/x64_64 Configuration‚Äù)</p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver6.png" alt="Select SPI Test Driver" /></p>
</li>
</ol>
<h2 id="enable-logging" class="section-header"><a href="#enable-logging">12.3 Enable Logging</a></h2>
<p>Next we enable SPI logging for easier troubleshooting‚Ä¶</p>
<ol>
<li>
<p>In <strong>menuconfig</strong>, select <strong>‚ÄúBuild Setup‚Äù</strong> ‚Üí <strong>‚ÄúDebug Options‚Äù</strong> </p>
</li>
<li>
<p>Check the boxes for the following‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Enable Debug Features
Enable Error Output
Enable Warnings Output
Enable Informational Debug Output
Enable Debug Assertions
GPIO Debug Features
GPIO Error Output
GPIO Warnings Output
GPIO Informational Output
SPI Debug Features
SPI Error Output
SPI Warnings Output
SPI Informational Output</code></pre></div>
<p>(See pic below)</p>
</li>
<li>
<p>Hit <strong>‚ÄúSave‚Äù</strong> then <strong>‚ÄúOK‚Äù</strong> to save the NuttX Configuration to <strong>‚Äú.config‚Äù</strong></p>
</li>
<li>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until <strong>menuconfig</strong> quits</p>
<p><img src="https://lupyuen.github.io/images/spi2-driver4.png" alt="Enable logging" /></p>
</li>
</ol>
<h2 id="register-device-driver" class="section-header"><a href="#register-device-driver">12.4 Register Device Driver</a></h2>
<p>During NuttX startup, we need to register our Device Driver like so‚Ä¶</p>
<ol>
<li>
<p>Browse to the <strong>Board Folder</strong>‚Ä¶</p>
<p><strong>For BL602:</strong> <a href="https://github.com/lupyuen/incubator-nuttx/blob/newdriver/boards/risc-v/bl602/bl602evb/src"><strong>nuttx/nuttx/boards/ risc-v/bl602/bl602evb</strong></a> </p>
<p><strong>For ESP32:</strong> <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src"><strong>nuttx/nuttx/boards/ xtensa/esp32/esp32-devkitc</strong></a></p>
<p>(Change ‚Äúesp32-devkitc‚Äù to our ESP32 board)</p>
</li>
<li>
<p>Edit the <strong>Bringup Code</strong>‚Ä¶</p>
<p><strong>For BL602:</strong> <a href="https://github.com/lupyuen/incubator-nuttx/blob/newdriver/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L599-L617"><strong>bl602_bringup.c</strong></a></p>
<p><strong>For ESP32:</strong> <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L118-L426"><strong>esp32_bringup.c</strong></a></p>
</li>
<li>
<p>Edit the function <strong>bl602_bringup()</strong> to register our Device Driver as <strong>‚Äú/dev/spitest0‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* Insert this code after the #include block */

#ifdef CONFIG_RF_SPI_TEST_DRIVER
#include &lt;nuttx/rf/spi_test_driver.h&gt;
#endif /* CONFIG_RF_SPI_TEST_DRIVER */

/* End of inserted code */

...

int bl602_bringup(void)
{
  /* Omitted: Existing code in the function */

  /* Insert this code just before the &quot;return&quot; statement */

#ifdef CONFIG_RF_SPI_TEST_DRIVER

  /* Init SPI bus again */

  struct spi_dev_s *spitest = bl602_spibus_initialize(0);
  if (!spitest)
    {
      _err(&quot;ERROR: Failed to initialize SPI %d bus\n&quot;, 0);
    }

  /* Register the SPI Test Driver */

  ret = spi_test_driver_register(&quot;/dev/spitest0&quot;, spitest, 0);
  if (ret &lt; 0)
    {
      _err(&quot;ERROR: Failed to register SPI Test Driver\n&quot;);
    }

#endif /* CONFIG_RF_SPI_TEST_DRIVER */

  /* End of inserted code */

  return ret;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/newdriver/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L599-L617">(Source)</a></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/commit/4cae36747314bacb49ff0bba3632fbb8136f3f66#diff-387529ed7b85b38e4e96d58de6cab8a83e706c26c97e9fc71db5ea5ff20be297">(See the changes)</a></p>
<p><strong>For ESP32:</strong> Edit the function <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L118-L426"><strong>esp32_bringup()</strong></a> and insert the code above. Change <strong>‚Äúbl602_spibus_initialize‚Äù</strong> to <strong>‚Äúesp32_spibus_initialize‚Äù</strong>. <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/boards/xtensa/esp32/common/src/esp32_board_spidev.c#L47-L72">(Like this)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver4.png" alt="Register our device driver at startup" /></p>
</li>
</ol>
<h2 id="verify-device-driver" class="section-header"><a href="#verify-device-driver">12.5 Verify Device Driver</a></h2>
<p>Finally we run the NuttX Firmware and check for our Device Driver‚Ä¶</p>
<ol>
<li>
<p>Build (‚Äúmake‚Äù), flash and run the NuttX Firmware on BL602 or ESP32.</p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>ls /dev</code></pre></div>
<p>Our Device Driver appears as <strong>‚Äú/dev/spitest0‚Äù</strong>.</p>
<p>Congratulations our Device Driver is now running on NuttX!</p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver10.png" alt="Our Device Driver appears as ‚Äú/dev/spitest0‚Äù" /></p>
</li>
<li>
<p>Look what happens if we forget to enable ‚ÄúSPI0‚Äù (BL602) or ‚ÄúSPI 2‚Äù (ESP32) and NuttX won‚Äôt start‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/spi2-crash2.png" alt="NuttX fails to start if we don‚Äôt enable SPI" /></p>
<p><a href="https://gist.github.com/lupyuen/ccfd90125f9a180b4cfb459e8a57b323">(Source)</a></p>
</li>
</ol>
<p><em>Why did we choose the ‚Äúdat-31r5-sp‚Äù driver for cloning?</em></p>
<p>We scanned the NuttX SPI Device Drivers (‚Äúgrep‚Äù and ‚Äúwc‚Äù) and picked <strong>‚Äúdat-31r5-sp‚Äù</strong> because‚Ä¶</p>
<ol>
<li>
<p>The driver code is <strong>simple</strong></p>
<p>(No dependencies on other modules)</p>
</li>
<li>
<p>It has the <strong>fewest lines of code</strong></p>
<p>(Easier to customise)</p>
</li>
<li>
<p>It‚Äôs the <strong>only driver</strong> in the RF Category</p>
<p>(Quick to modify the Makefile and Kconfig)</p>
</li>
</ol>
<p>Remember to move our driver to the correct category before releasing it!</p>
<p><img src="https://lupyuen.github.io/images/spi2-interface7.png" alt="dat-31r5-sp is the simplest smallest SPI Device Driver" /></p>
<p><a href="https://docs.google.com/spreadsheets/d/1MDps5cPe7tIgCL1Cz98iVccJAUJq1lgctpKgg9OwztI/edit#gid=0">(Source)</a></p>
<h1 id="appendix-create-a-nuttx-app" class="section-header"><a href="#appendix-create-a-nuttx-app">13 Appendix: Create a NuttX App</a></h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>This section explains the steps to create a <strong>NuttX App</strong> named <strong>‚Äúspi_test‚Äù</strong>.</p>
<p>(Change ‚Äúspi_test‚Äù to the desired name of our app)</p>
<ol>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/incubator-nuttx-apps/tree/newapp/examples"><strong>‚Äúnuttx/apps/examples‚Äù</strong></a> folder</p>
</li>
<li>
<p>Copy the <strong>‚Äúhello‚Äù</strong> subfolder and paste it as <strong>‚Äúspi_test‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/spi2-newapp.png" alt="Copy the ‚Äúhello‚Äù subfolder and paste it as ‚Äúspi_test‚Äù" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/commit/9af4ad6cab225d333ce0dae98c65a2a48621b3b4">(Source)</a></p>
</li>
<li>
<p>Inside the <strong>‚Äúspi_test‚Äù</strong> folder, rename <strong>‚Äúhello_main.c‚Äù</strong> to <strong>‚Äúspi_test_main.c‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/spi2-newapp2.png" alt="Rename ‚Äúhello_main.c‚Äù to ‚Äúspi_test_main.c‚Äù" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/commit/a4f884c67dc4c1042831d0554aed1d55a0e28b40">(Source)</a></p>
</li>
<li>
<p>Inside the <strong>‚Äúspi_test‚Äù</strong> folder, search and replace all <strong>‚Äúhello‚Äù</strong> by <strong>‚Äúspi_test‚Äù</strong></p>
<p>Be sure to <strong>Preserve Case!</strong></p>
<p><img src="https://lupyuen.github.io/images/spi2-newapp3.png" alt="Change all ‚Äúhello‚Äù to ‚Äúspi_test‚Äù" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/commit/0e19613b3059882f002eee948c0a79f622eccb74">(Source)</a></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/tree/newapp/examples/spi_test">(See ‚Äúspi_test‚Äù folder)</a></p>
</li>
<li>
<p>Enter the following‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># TODO: Change this to the path of our &quot;incubator-nuttx&quot; folder
cd nuttx/nuttx

# Preserve the Build Config
cp .config ../config

# Erase the Build Config and Kconfig files
make distclean

# For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

# For ESP32: Configure the build for ESP32.
# TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

# Restore the Build Config
cp ../config .config

# Edit the Build Config
make menuconfig </code></pre></div>
<p><img src="https://lupyuen.github.io/images/spi2-newapp4.png" alt="Select ‚Äúspi_test‚Äù in menuconfig" /></p>
</li>
</ol>
<h2 id="enable-app" class="section-header"><a href="#enable-app">13.1 Enable App</a></h2>
<p>Next we enable our app (pic above)‚Ä¶</p>
<ol>
<li>
<p>In <strong>menuconfig</strong>, select <strong>‚ÄúApplication Configuration‚Äù</strong> ‚Üí <strong>‚ÄúExamples‚Äù</strong></p>
</li>
<li>
<p>Check the box for <strong>‚Äúspi_test‚Äù</strong></p>
</li>
<li>
<p>Hit <strong>‚ÄúSave‚Äù</strong> then <strong>‚ÄúOK‚Äù</strong> to save the NuttX Configuration to <strong>‚Äú.config‚Äù</strong></p>
</li>
<li>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until <strong>menuconfig</strong> quits</p>
</li>
</ol>
<h2 id="run-the-app" class="section-header"><a href="#run-the-app">13.2 Run the App</a></h2>
<p>Finally we run the NuttX Firmware and start our app‚Ä¶</p>
<ol>
<li>
<p>Build (‚Äúmake‚Äù), flash and run the NuttX Firmware on BL602 or ESP32.</p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>spi_test</code></pre></div></li>
<li>
<p>We should see the output below.</p>
<p>Congratulations we have created the <strong>‚Äúspi_test‚Äù</strong> app!</p>
<p><img src="https://lupyuen.github.io/images/spi2-newapp5.png" alt="‚Äúspi_test‚Äù running on BL602" /></p>
</li>
</ol>
<h1 id="appendix-build-flash-and-run-nuttx" class="section-header"><a href="#appendix-build-flash-and-run-nuttx">14 Appendix: Build, Flash and Run Nuttx</a></h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>TODO</p>
<p>Build, Flash and Run #NuttX OS on #BL602 ‚Ä¶ Here‚Äôs the script I use for macOS</p>
<p><img src="https://lupyuen.github.io/images/spi2-script.png" alt="" /></p>
<h1 id="appendix-nuttx-spi-interface" class="section-header"><a href="#appendix-nuttx-spi-interface">15 Appendix: NuttX SPI Interface</a></h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>TODO</p>
<p>#NuttX SPI Interface is defined here ‚Ä¶ Let‚Äôs call it from our ‚Äúspi_test‚Äù app</p>
<p><a href="https://github.com/apache/incubator-nuttx/blob/master/include/nuttx/spi/spi.h">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-interface.png" alt="" /></p>
<p>TODO30</p>
<p>Can our #NuttX App directly call the SPI Interface? Let‚Äôs find out! ü§î</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/spi_test/examples/spi_test/spi_test_main.c">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-interface2.png" alt="" /></p>
<p>TODO31</p>
<p>#NuttX SPI Interface needs an SPI Device ‚Äúspi_dev_s‚Äù ‚Ä¶ How do we get an SPI Device? ü§î</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/master/arch/risc-v/src/bl602/bl602_spi.c#L932-L967">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-interface3.png" alt="" /></p>
<p>TODO32</p>
<p>Tracing thru #NuttX Virtual File System ‚Ä¶ We see that ioctl() maps the File Descriptor to a File Struct</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/master/fs/vfs/fs_ioctl.c#L118-L138">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-interface4.png" alt="" /></p>
<p>TODO33</p>
<p>#NuttX File Struct contains a Private Pointer to the SPI Driver ‚Äúspi_driver_s‚Äù</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/master/drivers/spi/spi_driver.c#L112-L147">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-interface5.png" alt="" /></p>
<p>TODO34</p>
<p>#NuttX SPI Driver ‚Äúspi_driver_s‚Äù contains the SPI Device ‚Äúspi_dev_s‚Äù ‚Ä¶ That we need for testing the SPI Interface! But the SPI Device is private and hidden from apps üôÅ</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/master/drivers/spi/spi_driver.c#L55-L65">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-interface6.png" alt="" /></p>
<h1 id="appendix-miso-and-mosi-are-swapped" class="section-header"><a href="#appendix-miso-and-mosi-are-swapped">16 Appendix: MISO And MOSI Are Swapped</a></h1>
<p><em>(For BL602 only)</em></p>
<p>TODO</p>
<p>How to verify the #NuttX SPI Output? We sniff the #BL602 SPI Bus with a Logic Analyser</p>
<p><a href="https://lupyuen.github.io/articles/spi#appendix-troubleshoot-bl602-spi-with-logic-analyser">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-logic4.jpg" alt="" /></p>
<p>TODO26</p>
<p>In #NuttX the SPI Pins for #BL602 are defined in ‚Äúboard.h‚Äù ‚Ä¶ MOSI is GPIO 1, MISO is GPIO 0</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/boards/risc-v/bl602/bl602evb/include/board.h#L87-L92">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-driver5.png" alt="" /></p>
<p>TODO27</p>
<p>#NuttX‚Äôs SPI Pins match the #BL602 Reference Manual: MOSI = GPIO 1, MISO = GPIO 0 ‚Ä¶ But we‚Äôre about to witness a BL602 SPI Quirk</p>
<p><a href="https://github.com/bouffalolab/bl_docs/tree/main/BL602_RM/en">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-driver6.png" alt="" /></p>
<p>TODO37</p>
<p>Logic Analyser connected to #BL602 shows that MISO and MOSI are swapped! This happens in BL602 IoT SDK ‚Ä¶ Also in #NuttX!</p>
<p><a href="https://lupyuen.github.io/articles/spi#spi-data-pins-are-flipped">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-logic.png" alt="" /></p>
<p>TODO28</p>
<p>We can swap MISO and MOSI on #BL602 by setting a Hardware Register ‚Ä¶ Let‚Äôs do this on #NuttX</p>
<p><a href="https://lupyuen.github.io/articles/pinedio#spi-pins-are-swapped">(Source)</a></p>
<p>Here‚Äôs how we swap #BL602 MOSI and MISO on #NuttX ‚Ä¶ So that the SPI Pins are consistent with the BL602 Reference Manual</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/swap_miso_mosi/arch/risc-v/src/bl602/bl602_spi.c#L1080-L1140">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-driver7.png" alt="" /></p>
<p>TODO38</p>
<p>After swapping #BL602 MISO and MOSI at #NuttX startup ‚Ä¶ Logic Analyser shows that the SPI Pins are now consistent with BL602 Reference Manual! üéâ</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/swap_miso_mosi/arch/risc-v/src/bl602/bl602_spi.c#L1080-L1140">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-logic2.png" alt="" /></p>
<h1 id="appendix-spi-mode-quirk" class="section-header"><a href="#appendix-spi-mode-quirk">17 Appendix: SPI Mode Quirk</a></h1>
<p><em>(For BL602 only)</em></p>
<p>TODO</p>
<p>Let‚Äôs test #NuttX SPI with #BL602 and Semtech SX1262 LoRa Transceiver</p>
<p><a href="https://www.semtech.com/products/wireless-rf/lora-core/sx1262">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-title.jpg" alt="" /></p>
<p>TODO60</p>
<p>Our #NuttX App transmits an SPI Command to SX1262 ‚Ä¶ And reads the SPI Response from SX1262</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c#L54-L84">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-sx4.png" alt="" /></p>
<p>TODO62</p>
<p>Now our #NuttX App is ready to read an SX1262 Register over SPI!</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c#L90-L119">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-sx6.png" alt="" /></p>
<p>TODO58</p>
<p>Our #NuttX App reads an SX1262 Register ‚Ä¶ But it returns garbage! There‚Äôs a workaround for this #BL602 SPI Quirk</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c#L90-L119">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-sx2.png" alt="" /></p>
<p>TODO63</p>
<p>#BL602 has an SPI Quirk ‚Ä¶ We must use SPI Mode 1 instead of Mode 0 ‚Ä¶ Let‚Äôs fix this in #NuttX</p>
<p><a href="https://lupyuen.github.io/articles/spi#spi-phase-looks-sus">(Source)</a></p>
<p>For #NuttX on #BL602, we use SPI Mode 1 instead of Mode 0 ‚Ä¶ To work around the SPI Mode Quirk</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/drivers/rf/spi_test_driver.c#L51-L57">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-sx7.png" alt="" /></p>
<p>TODO57</p>
<p>Our #NuttX App now reads the SX1262 Register correctly! üéâ</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/spi_test/examples/spi_test2/spi_test2_main.c">(Source)</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-sx.png" alt="" /></p>
<h1 id="appendix-pinedio-stack-bl604" class="section-header"><a href="#appendix-pinedio-stack-bl604">18 Appendix: PineDio Stack BL604</a></h1>
<p>TODO8</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio3.jpg" alt="" /></p>
<p>TODO9</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio8.jpg" alt="" /></p>
<p>TODO10</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio9.jpg" alt="" /></p>
<p>TODO11</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio7.jpg" alt="" /></p>
<p>TODO12</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio5.jpg" alt="" /></p>
<p>TODO14</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio6.jpg" alt="" /></p>
<p>TODO16</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio4.jpg" alt="" /></p>

    
</body>
</html>