<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Rust on RISC-V BL602: Rhai Scripting</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Rust on RISC-V BL602: Rhai Scripting" 
    data-rh="true">
<meta property="og:description" 
    content="Can we drag-and-drop Rhai Scripts... And run them on WebAssembly and BL602 RISC-V SoC?"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/rhai-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Rust on RISC-V BL602: Rhai Scripting</h1>
    <nav id="TOC"><ul>
<li><a href="#bestest-outcome">1 Bestest Outcome</a><ul></ul></li>
<li><a href="#rhai-scripts">2 Rhai Scripts</a><ul>
<li><a href="#variables-and-expressions">2.1 Variables and Expressions</a><ul></ul></li>
<li><a href="#loops-and-conditionals">2.2 Loops and Conditionals</a><ul></ul></li>
<li><a href="#rust-functions-and-modules">2.3 Rust Functions and Modules</a><ul></ul></li></ul></li>
<li><a href="#add-rhai-scripting-to-simulator">3 Add Rhai Scripting to Simulator</a><ul>
<li><a href="#register-function">3.1 Register Function</a><ul></ul></li>
<li><a href="#register-module">3.2 Register Module</a><ul></ul></li></ul></li>
<li><a href="#convert-rhai-to-ulisp">4 Convert Rhai to uLisp</a><ul>
<li><a href="#abstract-syntax-tree">4.1 Abstract Syntax Tree</a><ul></ul></li>
<li><a href="#rhai-transcoder">4.2 Rhai Transcoder</a><ul></ul></li>
<li><a href="#transcode-statement">4.3 Transcode Statement</a><ul></ul></li>
<li><a href="#transcode-block">4.4 Transcode Block</a><ul></ul></li>
<li><a href="#transcode-expression">4.5 Transcode Expression</a><ul></ul></li>
<li><a href="#transcoder-scope">4.6 Transcoder Scope</a><ul></ul></li></ul></li>
<li><a href="#run-the-transcoded-ulisp">5 Run the Transcoded uLisp</a><ul></ul></li>
<li><a href="#drag-and-drop-rhai-scripting">6 Drag-and-Drop Rhai Scripting</a><ul></ul></li>
<li><a href="#whats-next">7 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">8 Notes</a><ul></ul></li>
<li><a href="#appendix-add-c-functions-to-ulisp">9 Appendix: Add C Functions to uLisp</a><ul></ul></li></ul></nav><p>üìù <em>7 Sep 2021</em></p>
<p><em>What is Rhai?</em></p>
<p><a href="https://rhai.rs/book/"><strong>Rhai</strong></a> is a <strong>Rust-like Scripting Language</strong>, implemented in Rust.</p>
<p><em>Can we use Rhai for coding microcontrollers the REPL way?</em></p>
<p><em>Like on the BL602 / BL604 RISC-V + WiFi + Bluetooth LE SoC?</em></p>
<p><img src="https://lupyuen.github.io/images/rhai-rust2.jpg" alt="Rhai Script vs Rust Firmware" /></p>
<p>Sadly the Rhai Scripting Engine is <strong>too heavy</strong> for most microcontrollers (including BL602 and BL604).</p>
<p><em><a href="https://lupyuen.github.io/articles/lisp"><strong>uLisp</strong></a> runs OK on microcontrollers. Why don‚Äôt we auto-convert Rhai Scripts to uLisp?</em></p>
<p><img src="https://lupyuen.github.io/images/rhai-transcode4.jpg" alt="Rhai Script transcoded to uLisp" /></p>
<p><strong>Transpile Rhai to uLisp</strong>‚Ä¶ What an intriguing idea! Which we shall explore in this article.</p>
<p><em>Let‚Äôs make Rhai Scripting more fun for learners‚Ä¶</em></p>
<p><em>Can we drag-and-drop Rhai Scripts (the Scratch way) and run them on BL602?</em></p>
<p><img src="https://lupyuen.github.io/images/rhai-title.jpg" alt="Drag-and-drop scripting with Blockly and Rhai" /></p>
<p>Yep it sounds feasible, let‚Äôs explore that too.</p>
<p><em>One more thing‚Ä¶ Can we run Rhai Scripts in a Web Browser? Like on a Simulated BL602?</em></p>
<p>Yes we can‚Ä¶ Because we‚Äôve implemented a <strong>BL602 Simulator in WebAsssembly</strong>!</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rustsim">‚ÄúRust on RISC-V BL602: Simulated with WebAssembly‚Äù</a></li>
</ul>
<p>So today we shall explore‚Ä¶</p>
<ol>
<li>
<p>Running <strong>Rhai Scripts on BL602</strong></p>
<p>(The REPL way)</p>
</li>
<li>
<p>By <strong>Auto-Converting Rhai Scripts to uLisp</strong></p>
<p>(Because Rhai can‚Äôt run directly on BL602)</p>
</li>
<li>
<p>With <strong>Drag-and-Drop Rhai Scripting</strong></p>
<p>(The Scratch way)</p>
</li>
<li>
<p>That also runs <strong>Rhai Scripts in a Web Browser</strong></p>
<p>(With BL602 simulated in WebAssembly)</p>
</li>
</ol>
<h1 id="bestest-outcome" class="section-header"><a href="#bestest-outcome">1 Bestest Outcome</a></h1>
<p><em>Why are we doing ALL this? (Waving hands)</em></p>
<p><em>What challenges are BL602 (and BL604) Firmware Developers facing?</em></p>
<p>Most developers code BL602 (and BL604) Firmware in <strong>C with the BL602 IoT SDK</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-outcome2.jpg" alt="C Firmware for BL602" /></p>
<p>I introduced <strong>Rust</strong> as an option for coding BL602 Firmware, by creating a <a href="https://lupyuen.github.io/articles/adc#rust-wrapper-for-bl602-iot-sdk"><strong>Rust Wrapper for BL602 IoT SDK</strong></a>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-outcome5.jpg" alt="Rust Firmware for BL602" /></p>
<p>But flashing the C (or Rust) Firmware to BL602 over USB UART (and flipping a jumper) <strong>feels cumbersome</strong>.</p>
<p>(Especially when we keep fixing the code and reflashing to BL602)</p>
<p>Thus we created the <a href="https://lupyuen.github.io/articles/rustsim"><strong>WebAssembly Simulator for BL602</strong></a> that runs BL602 Rust Firmware in a Web Browser, for <strong>quicker testing, debugging and fixing</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-outcome.jpg" alt="WebAssembly Simulator for BL602" /></p>
<p><em>But what about the learners?</em></p>
<p>Scripted REPL platforms for microcontrollers like uLisp and MicroPython are popular for learners.</p>
<p>Since we have a WebAssembly Simulator for BL602, we can run REPL Scripts too‚Ä¶ With <strong>Rhai, the Drag-and-Drop Way!</strong></p>
<p><img src="https://lupyuen.github.io/images/rhai-outcome4.jpg" alt="Drag-and-Drop Rhai Scripts" /></p>
<p>And to run Rhai Scripts on actual BL602 Hardware, we need to <strong>convert Rhai Scripts to uLisp</strong>‚Ä¶</p>
<p>(Because Rhai Scripting Engine is too heavy for BL602)</p>
<p><img src="https://lupyuen.github.io/images/rhai-outcome3.jpg" alt="Convert Rhai Scripts to uLisp" /></p>
<p>Which is perfectly OK, because we can <strong>do the conversion in WebAssembly!</strong></p>
<p>(And transmit the converted uLisp code to BL602 via the <strong>WebSerial API</strong>)</p>
<p>In this article we‚Äôll learn how this grand scheme is implemented with these 3 repos‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bl602-simulator/tree/transcode"><strong><code>bl602-simulator</code></strong> (<code>transcode</code> branch)</a>: WebAssembly Simulator for BL602 and BL604</p>
<p>(With Rhai Scripting Engine and Rhai to uLisp Transcoder)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/blockly-bl602"><strong><code>blockly-bl602</code></strong></a>: Blockly Drag-and-Drop Scripting for BL602 and BL604</p>
<p>(Works like Scratch)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/tree/sdk"><strong><code>ulisp-bl602</code></strong> (<code>sdk</code> branch)</a>: uLisp for BL602 and BL604</p>
<p>(Integrated with BL602 / BL604 IoT SDK)</p>
</li>
</ul>
<h1 id="rhai-scripts" class="section-header"><a href="#rhai-scripts">2 Rhai Scripts</a></h1>
<p>Let‚Äôs look at the <strong>Rhai Scripts</strong> that will‚Ä¶</p>
<ol>
<li>
<p>Run OK on our BL602 Simulator and</p>
</li>
<li>
<p>Convert correctly to uLisp for execution on BL602</p>
</li>
</ol>
<h2 id="variables-and-expressions" class="section-header"><a href="#variables-and-expressions">2.1 Variables and Expressions</a></h2>
<p>This Rhai Script evaluates to the value 42‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Rhai Variables and Expression</span>
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">40</span>; 
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="number">2</span>;
<span class="ident">a</span> <span class="op">+</span> <span class="ident">b</span> </pre></div>
<h2 id="loops-and-conditionals" class="section-header"><a href="#loops-and-conditionals">2.2 Loops and Conditionals</a></h2>
<p><strong><code>loop</code></strong>, <strong><code>break</code></strong>, <strong><code>print</code></strong> and <strong><code>if</code></strong> (simple conditionals) shall be supported‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Rhai Loop and Conditional</span>
<span class="kw">loop</span> { 
  <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">1</span>;
  <span class="ident">print</span>(<span class="ident">a</span>);
  <span class="kw">if</span> <span class="ident">a</span> <span class="op">=</span><span class="op">=</span> <span class="number">1</span> { <span class="kw">break</span>; }
}</pre></div>
<p>See the next section for another loop that we shall support: <code>for i in range(0, 10)</code></p>
<h2 id="rust-functions-and-modules" class="section-header"><a href="#rust-functions-and-modules">2.3 Rust Functions and Modules</a></h2>
<p>Here‚Äôs a Rhai Script that blinks the LED on BL602‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Rhai Blinky: Blink the LED connected on BL602 GPIO 11</span>
<span class="kw">let</span> <span class="ident">LED_GPIO</span> <span class="op">=</span> <span class="number">11</span>;

<span class="comment">//  Configure the LED GPIO for output (instead of input)</span>
<span class="ident">gpio::enable_output</span>(<span class="ident">LED_GPIO</span>, <span class="number">0</span>, <span class="number">0</span>);

<span class="comment">//  Blink the LED 5 times</span>
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="ident">range</span>(<span class="number">0</span>, <span class="number">10</span>) {

  <span class="comment">//  Toggle the LED GPIO between 0 (on) and 1 (off)</span>
  <span class="ident">gpio::output_set</span>(
    <span class="ident">LED_GPIO</span>, 
    <span class="ident">i</span> <span class="op">%</span> <span class="number">2</span>
  );

  <span class="comment">//  Sleep 1 second</span>
  <span class="ident">time_delay</span>(<span class="number">1000</span>);
}</pre></div>
<p><strong><code>time_delay</code></strong> is a <strong>Rust Function</strong> that we shall import into the Rhai Scripting Engine.</p>
<p><strong><code>gpio</code></strong> is a <strong>Rust Module</strong> that we shall import into Rhai.</p>
<p>The <code>gpio</code> module has two functions: <strong><code>enable_output</code></strong> and <strong><code>output_set</code></strong>.</p>
<h1 id="add-rhai-scripting-to-simulator" class="section-header"><a href="#add-rhai-scripting-to-simulator">3 Add Rhai Scripting to Simulator</a></h1>
<p>We begin by adding the Rhai Scripting Engine to our <strong>WebAssembly Simulator</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L21-L98"><code>bl602-script/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// This function will be called by </span>
<span class="doccomment">/// WebAssembly to run a script</span>
<span class="attribute">#[<span class="ident">no_mangle</span>]</span>  <span class="comment">//  Don&#39;t mangle the function name</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span>    <span class="comment">//  Declare `extern &quot;C&quot;` because it will be called by Emscripten</span>
<span class="kw">fn</span> <span class="ident">rust_script</span>( ... ) {

  <span class="comment">//  Init the Rhai script engine</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>();

  <span class="comment">//  Rhai Script to be evaluated</span>
  <span class="kw">let</span> <span class="ident">script</span> <span class="op">=</span> <span class="string">r#&quot; 
    //  Evaluate an expression
    let a = 40; 
    let b = 2;
    a + b 
  &quot;#</span>;

  <span class="comment">//  Evaluate the Rhai Script</span>
  <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">engine</span>.<span class="ident">eval</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>(<span class="ident">script</span>)
    .<span class="ident">unwrap</span>() <span class="kw">as</span> <span class="ident">isize</span>;

  <span class="comment">//  Display the result</span>
  <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">result</span>);
}</pre></div>
<p>Here we <strong>initialise the Rhai engine</strong> and evaluate a Rhai Script that returns an integer result‚Ä¶</p>
<pre><code class="language-text">42
</code></pre>
<h2 id="register-function" class="section-header"><a href="#register-function">3.1 Register Function</a></h2>
<p>To <strong>register a Rust Function</strong> that will be called by the Rhai Script, we do this: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L21-L98"><code>bl602-script/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Init the Rhai script engine</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>();

<span class="comment">//  Register our functions with Rhai</span>
<span class="ident">engine</span>.<span class="ident">register_fn</span>(<span class="string">&quot;time_delay&quot;</span>, <span class="ident">time_delay</span>);

<span class="comment">//  Rhai Script to be evaluated</span>
<span class="kw">let</span> <span class="ident">script</span> <span class="op">=</span> <span class="string">r#&quot; 
  //  Sleep 1 second
  time_delay(1000);

  //  Return 0
  0
&quot;#</span>;

<span class="comment">//  Evaluate the Rhai Script (returns 0)</span>
<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">engine</span>.<span class="ident">eval</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>(<span class="ident">script</span>)
  .<span class="ident">unwrap</span>() <span class="kw">as</span> <span class="ident">isize</span>;</pre></div>
<p><strong><code>time_delay</code></strong> is defined like so: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L146-L161"><code>bl602-script/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Rhai Shim for Time Delay</span>
<span class="doccomment">/// TODO: Modified parameter from u32 to i32</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">time_delay</span>(
    <span class="ident">ticks</span>: <span class="ident">i32</span>  <span class="comment">//  Number of ticks to sleep</span>
) {
  <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {  <span class="comment">//  Import C Function</span>
    <span class="doccomment">/// Sleep for the specified number of system ticks (from NimBLE Porting Layer)</span>
    <span class="kw">fn</span> <span class="ident">ble_npl_time_delay</span>(<span class="ident">ticks</span>: <span class="ident">u32</span>);
  }

  <span class="comment">//  Call the C function</span>
  <span class="kw">unsafe</span> {  <span class="comment">//  Flag this code as unsafe because we&#39;re calling a C function</span>
    <span class="ident">ble_npl_time_delay</span>(<span class="ident">ticks</span> <span class="kw">as</span> <span class="ident">u32</span>);
  }
}</pre></div>
<p><strong><code>time_delay</code></strong> is a Rust Shim Function that calls out to the C function <strong><code>ble_npl_time_delay</code></strong> which we have defined in our WebAssembly Simulator.</p>
<p><a href="https://lupyuen.github.io/articles/rustsim#json-stream-of-simulation-events">(More about <code>time_delay</code>)</a></p>
<p><em>Why not register <code>ble_npl_time_delay</code> with Rhai and rename it as <code>time_delay</code>?</em></p>
<p>Because <code>ble_npl_time_delay</code> is ‚Äú<code>extern C</code>‚Äù and it accepts a parameter of type <strong><code>u32</code></strong>, but our Rhai engine is configured for <a href="https://rhai.rs/book/start/features.html"><strong><code>only_i32</code></strong></a>.</p>
<h2 id="register-module" class="section-header"><a href="#register-module">3.2 Register Module</a></h2>
<p>Now we register the <strong><code>gpio</code></strong> module with Rhai: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L21-L98"><code>bl602-script/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Init the Rhai script engine</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>();

<span class="comment">//  Create a Rhai module from the plugin module</span>
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="macro">exported_module!</span>(<span class="ident">gpio</span>);

<span class="comment">//  Register our module as a Static Module</span>
<span class="ident">engine</span>.<span class="ident">register_static_module</span>(<span class="string">&quot;gpio&quot;</span>, <span class="ident">module</span>.<span class="ident">into</span>());</pre></div>
<p><strong><code>gpio</code></strong> is a Rust Module that exports the functions <strong><code>enable_output</code></strong> and <strong><code>output_set</code></strong>, which may be called like so‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Rhai Script to be evaluated</span>
<span class="kw">let</span> <span class="ident">script</span> <span class="op">=</span> <span class="string">r#&quot; 
  //  Blink the LED connected on BL602 GPIO 11
  let LED_GPIO = 11;

  //  Configure the LED GPIO for output (instead of input)
  gpio::enable_output(LED_GPIO, 0, 0);

  //  Blink the LED 5 times
  for i in range(0, 10) {

    //  Toggle the LED GPIO between 0 (on) and 1 (off)
    gpio::output_set(
      LED_GPIO, 
      i % 2
    );

    //  Sleep 1 second
    time_delay(1000);
  }

  //  Return 0
  0
&quot;#</span>;

<span class="comment">//  Evaluate the Rhai Script (returns 0)</span>
<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">engine</span>.<span class="ident">eval</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>(<span class="ident">script</span>)
  .<span class="ident">unwrap</span>() <span class="kw">as</span> <span class="ident">isize</span>;</pre></div>
<p>Here‚Äôs the definition of the <strong><code>gpio</code></strong> module: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L100-L144"><code>bl602-script/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// GPIO Module will be exported to Rhai as a Static Module</span>
<span class="attribute">#[<span class="ident">export_module</span>]</span>
<span class="kw">mod</span> <span class="ident">gpio</span> {
  <span class="doccomment">/// Rhai Shim for Enable GPIO Output</span>
  <span class="doccomment">/// TODO: Modified parameters from u8 to i32</span>
  <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">enable_output</span>(<span class="ident">pin</span>: <span class="ident">i32</span>, <span class="ident">pullup</span>: <span class="ident">i32</span>, <span class="ident">pulldown</span>: <span class="ident">i32</span>) {
    <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
      <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bl_gpio_enable_output</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">pullup</span>: <span class="ident">u8</span>, <span class="ident">pulldown</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span>;
    }
    <span class="kw">unsafe</span> {
      <span class="kw">let</span> <span class="ident">_res</span> <span class="op">=</span> <span class="ident">bl_gpio_enable_output</span>(<span class="ident">pin</span> <span class="kw">as</span> <span class="ident">u8</span>, <span class="ident">pullup</span> <span class="kw">as</span> <span class="ident">u8</span>, <span class="ident">pulldown</span> <span class="kw">as</span> <span class="ident">u8</span>);
      <span class="comment">//  TODO: Throw exception if result is non-zero</span>
    }
  }

  <span class="doccomment">/// Rhai Shim for Set GPIO Output</span>
  <span class="doccomment">/// TODO: Modified parameters from u8 to i32</span>
  <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">output_set</span>(<span class="ident">pin</span>: <span class="ident">i32</span>, <span class="ident">value</span>: <span class="ident">i32</span>) {
    <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
      <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bl_gpio_output_set</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">value</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span>;
    }
    <span class="kw">unsafe</span> {
      <span class="kw">let</span> <span class="ident">_res</span> <span class="op">=</span> <span class="ident">bl_gpio_output_set</span>(<span class="ident">pin</span> <span class="kw">as</span> <span class="ident">u8</span>, <span class="ident">value</span> <span class="kw">as</span> <span class="ident">u8</span>);
      <span class="comment">//  TODO: Throw exception if result is non-zero</span>
    }
  }
}</pre></div>
<p><em>So <code>gpio</code> module is also a Rust Shim?</em></p>
<p>Yep. Maybe someday we‚Äôll use a Rust Procedural Macro to <strong>generate the shims</strong>, similar to this‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/adc#appendix-generating-the-rust-wrapper-for-bl602-iot-sdk">‚ÄúGenerating the Rust Wrapper for BL602 IoT SDK‚Äù</a></li>
</ul>
<p><a href="https://lupyuen.github.io/articles/rustsim#json-stream-of-simulation-events">(More about <code>enable_output</code> and <code>output_set</code>)</a></p>
<p><img src="https://lupyuen.github.io/images/rhai-module.png" alt="Register Rhai Module" /></p>
<h1 id="convert-rhai-to-ulisp" class="section-header"><a href="#convert-rhai-to-ulisp">4 Convert Rhai to uLisp</a></h1>
<p>Yep the Rhai Blinky Script runs OK in the <strong>BL602 WebAssembly Simulator</strong>, blinking the simulated LED.</p>
<p>Now let‚Äôs <strong>auto-convert the Rhai Script to uLisp</strong>, and run it on a real BL602 board (and blink a real LED)!</p>
<p><img src="https://lupyuen.github.io/images/rhai-transcode4.jpg" alt="Rhai Script transcoded to uLisp" /></p>
<p>We do the same as earlier‚Ä¶</p>
<ol>
<li>
<p><strong>Initialise</strong> the Rhai script engine</p>
</li>
<li>
<p><strong>Register <code>gpio</code> module</strong> with Rhai</p>
</li>
<li>
<p><strong>Register <code>time_delay</code> function</strong> with Rhai</p>
</li>
</ol>
<p>From <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L21-L98"><code>bl602-script/lib.rs</code></a> ‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Init the Rhai script engine</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::new</span>();

<span class="comment">//  Omitted: Create a Rhai module from the plugin module</span>
<span class="comment">//  Omitted: Register `gpio` module as a Static Module</span>
<span class="comment">//  Omitted: Register `time_delay` function with Rhai</span>
...</pre></div>
<p>Below is the kitchen-sink <strong>Rhai Script</strong> that will be converted to uLisp‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Rhai Script to be parsed</span>
<span class="kw">let</span> <span class="ident">script</span> <span class="op">=</span> <span class="string">r#&quot; 
  //  Rhai Loop and Conditional
  loop { 
    let a = 1;
    print(a);
    if a == 1 { break; }
  }

  //  Rhai Blinky: Blink the LED connected on BL602 GPIO 11
  let LED_GPIO = 11;

  //  Configure the LED GPIO for output (instead of input)
  gpio::enable_output(LED_GPIO, 0, 0);

  //  Blink the LED 5 times
  for i in range(0, 10) {

    //  Toggle the LED GPIO between 0 (on) and 1 (off)
    gpio::output_set(
      LED_GPIO, 
      i % 2
    );

    //  Sleep 1 second
    time_delay(1000);
  }

  //  Rhai Variables and Expression
  let a = 40; 
  let b = 2;
  a + b 
&quot;#</span>;</pre></div>
<p>Here comes the interesting part: Rhai lets us <strong>compile our script</strong> into an <strong>Abstract Syntax Tree</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Compile the Rhai Script into</span>
<span class="comment">//  an Abstract Syntax Tree</span>
<span class="kw">let</span> <span class="ident">ast</span> <span class="op">=</span> <span class="ident">engine</span>.<span class="ident">compile</span>(<span class="ident">script</span>)
  .<span class="ident">unwrap</span>();</pre></div>
<p>(More about the Abstract Syntax Tree in a while)</p>
<p>We may <strong>walk the Abstract Syntax Tree</strong> and <strong>convert each node</strong> to uLisp‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Transcode the Rhai Abstract </span>
<span class="comment">//  Syntax Tree to uLisp</span>
<span class="ident">transcode::transcode</span>(<span class="kw-2">&amp;</span><span class="ident">ast</span>);</pre></div>
<p>(More about <code>transcode</code> later)</p>
<p>FYI: Here‚Äôs how we <strong>evaluate the compiled Rhai Script</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Evaluate the compiled Rhai Script (returns 42)</span>
<span class="kw">let</span> <span class="ident">result</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="ident">engine</span>.<span class="ident">eval_ast</span>(<span class="kw-2">&amp;</span><span class="ident">ast</span>)
  .<span class="ident">unwrap</span>();</pre></div>
<p>Let‚Äôs learn about the Abstract Syntax Tree‚Ä¶</p>
<h2 id="abstract-syntax-tree" class="section-header"><a href="#abstract-syntax-tree">4.1 Abstract Syntax Tree</a></h2>
<p><em>What is an Abstract Syntax Tree?</em></p>
<p>The Rhai Scripting Engine <strong>parses our Rhai Script</strong> and produces a <strong>tree of syntax elements</strong>‚Ä¶ That‚Äôs the <strong>Abstract Syntax Tree</strong>.</p>
<p>This Rhai Script‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">LED_GPIO</span> <span class="op">=</span> <span class="number">11</span>;
<span class="ident">gpio::enable_output</span>(<span class="ident">LED_GPIO</span>, <span class="number">0</span>, <span class="number">0</span>);</pre></div>
<p>Generates this <strong>Abstract Syntax Tree</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L227-L252"><code>bl602-script/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">Var</span>(
  <span class="number">11</span> @ <span class="number">11</span>:<span class="number">24</span>,
  <span class="string">&quot;LED_GPIO&quot;</span> @ <span class="number">11</span>:<span class="number">13</span>,
  (),
  <span class="number">11</span>:<span class="number">9</span>,
),
<span class="ident">FnCall</span>(
  <span class="ident">FnCallExpr</span> {
    <span class="ident">namespace</span>: <span class="prelude-val">Some</span>(
      <span class="ident">gpio</span>,
    ),
    <span class="ident">hashes</span>: <span class="number">12987214658708294900</span>,
    <span class="ident">args</span>: [
      <span class="ident">Variable</span>(<span class="ident">LED_GPIO</span> #<span class="number">1</span>) @ <span class="number">14</span>:<span class="number">29</span>,
      <span class="ident">StackSlot</span>(<span class="number">0</span>) @ <span class="number">14</span>:<span class="number">39</span>,
      <span class="ident">StackSlot</span>(<span class="number">1</span>) @ <span class="number">14</span>:<span class="number">42</span>,
    ],
    <span class="ident">constants</span>: [
      <span class="number">0</span>,
      <span class="number">0</span>,
    ],
    <span class="ident">name</span>: <span class="string">&quot;enable_output&quot;</span>,
    <span class="ident">capture</span>: <span class="bool-val">false</span>,
  },
  <span class="number">14</span>:<span class="number">15</span>,
)</pre></div>
<p>(<code>StackSlot</code> refers to the values in the <code>constants</code> array)</p>
<p>Here‚Äôs how they match up‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-ast2.jpg" alt="Rhai Script vs Abstract Syntax Tree" /></p>
<p>Yep Abstract Syntax Trees can get <strong>deeply nested</strong>, like this <strong><code>for</code></strong> loop‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-ast.jpg" alt="Abstract Syntax Tree for for loop" /></p>
<p>But Abstract Syntax Trees are actually <strong>perfect for converting Rhai to uLisp</strong>.</p>
<p>Lisp is a recursive language and the <strong>Lisp parentheses match the nodes</strong> in the Abstract Syntax Tree quite closely.</p>
<p>Let‚Äôs talk about the Rhai to uLisp conversion‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-transcode6.png" alt="Converting the Abstract Syntax Tree to uLisp" /></p>
<h2 id="rhai-transcoder" class="section-header"><a href="#rhai-transcoder">4.2 Rhai Transcoder</a></h2>
<p>(Since we‚Äôre converting Rhai Code to uLisp Code, let‚Äôs call it <strong>‚Äútranscoding‚Äù</strong> instead of ‚Äútranspiling‚Äù)</p>
<p>To transcode the compiled Rhai Code to uLisp, we <strong>walk the Abstract Syntax Tree</strong> and <strong>transcode each node to uLisp</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L15-L27"><code>bl602-script/transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Transcode the compiled Rhai Script </span>
<span class="doccomment">/// (Abstract Syntax Tree) to uLisp</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">transcode</span>(<span class="ident">ast</span>: <span class="kw-2">&amp;</span><span class="ident">AST</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">String</span> {
  <span class="comment">//  Start the first uLisp Scope</span>
  <span class="kw">let</span> <span class="ident">scope_index</span> <span class="op">=</span> <span class="ident">scope::begin_scope</span>(<span class="string">&quot;let* ()&quot;</span>);

  <span class="comment">//  Walk the nodes in the Rhai Abstract Syntax Tree</span>
  <span class="ident">ast</span>.<span class="ident">walk</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">transcode_node</span>);

  <span class="comment">//  End the first uLisp Scope and get the uLisp S-Expression for the scope</span>
  <span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="ident">scope::end_scope</span>(<span class="ident">scope_index</span>);

  <span class="comment">//  Return the transcoded uLisp S-Expression</span>
  <span class="ident">output</span>
}</pre></div>
<p>(More about <code>scope</code> in a while)</p>
<p><strong><code>ast.walk</code></strong> calls <strong><code>transcode_node</code></strong> to transcode each node in the Abstract Syntax Tree: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L29-L59"><code>transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Transcode the Rhai AST Node to uLisp</span>
<span class="kw">fn</span> <span class="ident">transcode_node</span>(<span class="ident">nodes</span>: <span class="kw-2">&amp;</span>[<span class="ident">ASTNode</span>]) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
  <span class="comment">//  We take the root node, ignore the subnodes</span>
  <span class="kw">let</span> <span class="ident">node</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">nodes</span>[<span class="number">0</span>];

  <span class="comment">//  Get the source code position</span>
  <span class="kw">let</span> <span class="ident">pos</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">node</span> {
    <span class="ident">ASTNode::Stmt</span>(<span class="ident">stmt</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">stmt</span>.<span class="ident">position</span>(),
    <span class="ident">ASTNode::Expr</span>(<span class="ident">expr</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">expr</span>.<span class="ident">position</span>(),
  };

  <span class="comment">//  Skip this node if we&#39;ve already handled it</span>
  <span class="kw">unsafe</span> {
    <span class="kw">static</span> <span class="kw-2">mut</span> <span class="ident">LAST_POSITION</span>: <span class="ident">Position</span> <span class="op">=</span> <span class="ident">Position::NONE</span>;
    <span class="kw">if</span> <span class="ident">LAST_POSITION</span> <span class="op">=</span><span class="op">=</span> <span class="ident">pos</span> { <span class="kw">return</span> <span class="bool-val">true</span>; }
    <span class="ident">LAST_POSITION</span> <span class="op">=</span> <span class="ident">pos</span>;
  }

  <span class="comment">//  Transcode the Node: Statement or Expression</span>
  <span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">node</span> {
    <span class="ident">ASTNode::Stmt</span>(<span class="ident">stmt</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">transcode_stmt</span>(<span class="ident">stmt</span>),
    <span class="ident">ASTNode::Expr</span>(<span class="ident">expr</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">transcode_expr</span>(<span class="ident">expr</span>),
  };

  <span class="comment">//  Add the transcoded uLisp S-Expression to the current scope</span>
  <span class="ident">scope::add_to_scope</span>(<span class="kw-2">&amp;</span><span class="ident">output</span>);

  <span class="comment">//  Return true to walk the next node in the tree</span>
  <span class="bool-val">true</span>
}</pre></div>
<p>Each node is either a Rhai <strong>Statement or Expression</strong>. We call‚Ä¶</p>
<ul>
<li>
<p><strong><code>transcode_stmt</code></strong> to transcode a Rhai Statement</p>
</li>
<li>
<p><strong><code>transcode_expr</code></strong> to transcode a Rhai Expression</p>
</li>
</ul>
<p>Let‚Äôs look into each of these functions‚Ä¶</p>
<h2 id="transcode-statement" class="section-header"><a href="#transcode-statement">4.3 Transcode Statement</a></h2>
<p>We start with the <strong><code>let</code></strong> Statement that declares a variable‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">LED_GPIO</span> <span class="op">=</span> <span class="number">11</span></pre></div>
<p>This will be transcoded to uLisp like so‚Ä¶</p>
<pre><code class="language-text">( let* 
  (( LED_GPIO 11 ))
  ...
)
</code></pre>
<p>Here‚Äôs how we transcode the <strong><code>let</code></strong> Statement: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L61-L89"><code>transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Transcode a Rhai Statement to uLisp</span>
<span class="kw">fn</span> <span class="ident">transcode_stmt</span>(<span class="ident">stmt</span>: <span class="kw-2">&amp;</span><span class="ident">Stmt</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">String</span> {
  <span class="kw">match</span> <span class="ident">stmt</span> {
    <span class="comment">//  Let or Const Statement: `let LED_GPIO = 11`</span>
    <span class="ident">Stmt::Var</span>(<span class="ident">expr</span>, <span class="ident">ident</span>, <span class="kw">_</span>, <span class="kw">_</span>) <span class="op">=</span><span class="op">&gt;</span> {
      <span class="comment">//  Begin a new uLisp Scope</span>
      <span class="ident">scope::begin_scope</span>(
        <span class="macro">format!</span>(
          <span class="string">&quot;let* (( {} {} ))&quot;</span>,    <span class="comment">//  `let* (( LED_GPIO 11 ))`</span>
          <span class="ident">ident</span>.<span class="ident">name</span>,            <span class="comment">//  `LED_GPIO`</span>
          <span class="ident">transcode_expr</span>(<span class="ident">expr</span>),  <span class="comment">//  `11`</span>
        ).<span class="ident">as_str</span>()
      );

      <span class="comment">//  Scope will end when the parent scope ends</span>
      <span class="string">&quot;&quot;</span>.<span class="ident">to_string</span>()
    }</pre></div>
<p><em>Why do we need uLisp Scopes?</em></p>
<p>Here‚Äôs a hint: The transcoded uLisp will look like this‚Ä¶</p>
<pre><code class="language-text">( let* 
  (( LED_GPIO 11 ))
  ...
)
</code></pre>
<p>Where <strong>‚Äú<code>...</code>‚Äù</strong> refers to the <strong>uLisp Scope</strong> of the statements that will be transcoded after the <code>let</code> statement.</p>
<p>(More about uLisp Scopes in a while)</p>
<p>Next: <strong><code>for</code></strong> Statements like this‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="ident">range</span>(<span class="number">0</span>, <span class="number">10</span>) { ... }</pre></div>
<p>Shall be transcoded to uLisp like so‚Ä¶</p>
<pre><code class="language-text">( dotimes (i 10)
  ...
)
</code></pre>
<p>Here‚Äôs how we transcode the <strong><code>for</code></strong> Statement: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L91-L142"><code>transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="kw">match</span> <span class="ident">stmt</span> {
    ...
    <span class="comment">//  For Statement: `for i in range(0, 10) { ... }`</span>
    <span class="ident">Stmt::For</span>(<span class="ident">expr</span>, <span class="ident">id_counter</span>, <span class="kw">_</span>) <span class="op">=</span><span class="op">&gt;</span> {
      <span class="comment">//  TODO: Support `for` counter</span>
      <span class="kw">let</span> <span class="ident">id</span>    <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">id_counter</span>.<span class="number">0</span>;  <span class="comment">//  `i`</span>
      <span class="kw">let</span> <span class="ident">stmts</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">id_counter</span>.<span class="number">2</span>;  <span class="comment">//  `{ ... }`</span>

      <span class="comment">//  Get the `for` range, e.g. `[0, 10]`</span>
      <span class="kw">let</span> <span class="ident">range</span> <span class="op">=</span> <span class="ident">get_range</span>(<span class="ident">expr</span>);  <span class="comment">//  `[0, 10]`</span>
      <span class="kw">let</span> <span class="ident">lower_limit</span> <span class="op">=</span> <span class="ident">range</span>[<span class="number">0</span>];   <span class="comment">//  `0`</span>
      <span class="kw">let</span> <span class="ident">upper_limit</span> <span class="op">=</span> <span class="ident">range</span>[<span class="number">1</span>];   <span class="comment">//  `10`</span>
      <span class="macro">assert!</span>(<span class="ident">lower_limit</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span>);    <span class="comment">//  TODO: Allow Lower Limit to be non-zero</span>

      <span class="comment">//  Begin a new uLisp Scope</span>
      <span class="kw">let</span> <span class="ident">scope_index</span> <span class="op">=</span> <span class="ident">scope::begin_scope</span>(
        <span class="macro">format!</span>(
          <span class="string">&quot;dotimes ({} {})&quot;</span>,  <span class="comment">//  `dotimes (i 10)`</span>
          <span class="ident">id</span>.<span class="ident">name</span>,            <span class="comment">//  `i`</span>
          <span class="ident">upper_limit</span>,        <span class="comment">//  `10`</span>
        ).<span class="ident">as_str</span>()
      );

      <span class="comment">//  Transcode the Statement Block: `{ ... }`</span>
      <span class="ident">transcode_block</span>(<span class="ident">stmts</span>);

      <span class="comment">//  End the uLisp Scope and add the transcoded uLisp S-Expression to the parent scope</span>
      <span class="ident">scope::end_scope</span>(<span class="ident">scope_index</span>)
    }        </pre></div>
<p><strong><code>transcode_block</code></strong> transcodes the block of statements in the body of a <code>for</code> loop.</p>
<p>(Coming up in the next section)</p>
<p><strong><code>get_range</code></strong> is defined here: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L345-L391"><code>transcode.rs</code></a></p>
<p><strong>Function Calls</strong> are transcoded as a special kind of Expression: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L91-L142"><code>transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="kw">match</span> <span class="ident">stmt</span> {
    ...
    <span class="comment">//  Function Call: `gpio::enable_output(LED_GPIO, 0, 0)`</span>
    <span class="ident">Stmt::FnCall</span>(<span class="ident">expr</span>, <span class="kw">_</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="macro">format!</span>(
      <span class="string">&quot;{}&quot;</span>,
      <span class="ident">transcode_fncall</span>(<span class="ident">expr</span>)
    ),</pre></div>
<p>(We‚Äôll meet <code>transcode_fncall</code> in a while)</p>
<p>Check out the source code to see how we transcode these statements‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L144-L194"><strong><code>loop</code></strong> Statement</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L196-L239"><strong><code>break</code></strong> Statement</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L241-L243"><strong><code>if</code></strong> Statement</a></p>
</li>
</ul>
<h2 id="transcode-block" class="section-header"><a href="#transcode-block">4.4 Transcode Block</a></h2>
<p>Our transcoder calls <strong><code>transcode_block</code></strong> to transcode a block of statements (<code>for</code>, <code>loop</code>, <code>if</code>, ‚Ä¶)</p>
<p>From <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L324-L333"><code>transcode.rs</code></a> ‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Transcode the Statement Block and </span>
<span class="doccomment">/// the transcoded uLisp S-Expression </span>
<span class="doccomment">/// into the current scope</span>
<span class="kw">fn</span> <span class="ident">transcode_block</span>(<span class="ident">stmts</span>: <span class="kw-2">&amp;</span><span class="ident">StmtBlock</span>) {  
  <span class="comment">//  Iterate through each Statement in the block...</span>
  <span class="ident">stmts</span>.<span class="ident">clone</span>().<span class="ident">statements_mut</span>().<span class="ident">iter</span>().<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">stmt</span><span class="op">|</span> {
    <span class="comment">//  Transcode each Statement</span>
    <span class="kw">let</span> <span class="ident">output</span> <span class="op">=</span> <span class="ident">transcode_stmt</span>(<span class="ident">stmt</span>);

    <span class="comment">//  Add the transcoded uLisp S-Expression to the current scope</span>
    <span class="ident">scope::add_to_scope</span>(<span class="kw-2">&amp;</span><span class="ident">output</span>);
  });
}</pre></div>
<p>This code transcodes every statement in the block.</p>
<h2 id="transcode-expression" class="section-header"><a href="#transcode-expression">4.5 Transcode Expression</a></h2>
<p><strong><code>transcode_expr</code></strong> transcodes an Expression from Rhai to uLisp: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L255-L269"><code>transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Transcode a Rhai Expression to uLisp</span>
<span class="kw">fn</span> <span class="ident">transcode_expr</span>(<span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="ident">Expr</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">String</span> {
  <span class="kw">match</span> <span class="ident">expr</span> {
    <span class="comment">//  Integers become themselves, e.g. `1`</span>
    <span class="ident">Expr::IntegerConstant</span>(<span class="ident">i</span>, <span class="kw">_</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">i</span>),

    <span class="comment">//  Variables become their names, e.g. `a`</span>
    <span class="ident">Expr::Variable</span>(<span class="kw">_</span>, <span class="kw">_</span>, <span class="ident">var</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">var</span>.<span class="number">2</span>),

    <span class="comment">//  Function Call: `gpio::enable_output(LED_GPIO, 0, 0)`</span>
    <span class="ident">Expr::FnCall</span>(<span class="ident">expr</span>, <span class="kw">_</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">transcode_fncall</span>(<span class="ident">expr</span>),

    <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">panic!</span>(<span class="string">&quot;Unknown expr: {:#?}&quot;</span>, <span class="ident">expr</span>)
  }
}</pre></div>
<p>Which means that‚Ä¶</p>
<ul>
<li>
<p><strong><code>1</code></strong> is transcoded as <strong><code>1</code></strong></p>
</li>
<li>
<p><strong><code>a</code></strong> is transcoded as <strong><code>a</code></strong></p>
</li>
</ul>
<p>Now for <strong>Function Calls</strong>: We shall transcode‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">gpio::enable_output</span>(<span class="ident">LED_GPIO</span>, <span class="number">0</span>, <span class="number">0</span>)</pre></div>
<p>To‚Ä¶</p>
<pre><code class="language-text">( bl_gpio_enable_output LED_GPIO 0 0 )
</code></pre>
<p>Here‚Äôs how: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L271-L322"><code>transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Transcode a Rhai Function Call to uLisp:</span>
<span class="doccomment">/// `gpio::enable_output(11, 0, 0)`</span>
<span class="kw">fn</span> <span class="ident">transcode_fncall</span>(<span class="ident">expr</span>: <span class="kw-2">&amp;</span><span class="ident">FnCallExpr</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">String</span> {
  <span class="comment">//  Compose namespace e.g. `bl_gpio_` or ``</span>
  <span class="kw">let</span> <span class="ident">namespace</span> <span class="op">=</span> <span class="kw">match</span> <span class="kw-2">&amp;</span><span class="ident">expr</span>.<span class="ident">namespace</span> {
    <span class="prelude-val">Some</span>(<span class="ident">ns</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="macro">format!</span>(<span class="string">&quot;bl_{:#?}_&quot;</span>, <span class="ident">ns</span>),  <span class="comment">//  TODO</span>
    <span class="prelude-val">None</span> <span class="op">=</span><span class="op">&gt;</span> <span class="string">&quot;&quot;</span>.<span class="ident">to_string</span>()
  };</pre></div>
<p><strong><code>transcode_fncall</code></strong> begins by converting the Rhai Namespace (like <strong>‚Äú<code>gpio::</code>‚Äù</strong>) to its uLisp equivalent (like <strong>‚Äú<code>bl_gpio_</code>‚Äù</strong>)</p>
<p>Next it composes the <strong>list of arguments</strong> for the function call‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Compose arguments e.g. `11 0 0 `</span>
  <span class="kw">let</span> <span class="ident">args</span> <span class="op">=</span> <span class="ident">expr</span>.<span class="ident">args</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">arg</span><span class="op">|</span> {
    <span class="comment">//  Transcode each argument</span>
    <span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="kw">match</span> <span class="ident">arg</span> {
      <span class="comment">//  Transcode a StackSlot by looking up the constants</span>
      <span class="ident">Expr::Stack</span>(<span class="ident">i</span>, <span class="kw">_</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">expr</span>.<span class="ident">constants</span>[<span class="kw-2">*</span><span class="ident">i</span>]),

      <span class="comment">//  Transcode other expressions</span>
      <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="ident">transcode_expr</span>(<span class="kw-2">&amp;</span><span class="ident">arg</span>)
    };
    <span class="ident">val</span> <span class="op">+</span> <span class="string">&quot; &quot;</span>
  });</pre></div>
<p>And combines them into a <strong>uLisp Function Call</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Transcode to uLisp Function Call:</span>
  <span class="comment">//  `( bl_gpio_enable_output 11 0 0 )`</span>
  <span class="macro">format!</span>(
    <span class="string">&quot;( {}{} {})&quot;</span>,
    <span class="ident">namespace</span>,                             <span class="comment">//  `bl_gpio_` or ``</span>
    <span class="ident">rename_function</span>(<span class="kw-2">&amp;</span><span class="ident">expr</span>.<span class="ident">name</span>.<span class="ident">as_str</span>()),  <span class="comment">//  `enable_output`, `+` or `mod`</span>
    <span class="ident">args</span>.<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>()               <span class="comment">//  `11 0 0 `</span>
  )
}</pre></div>
<p><em>What‚Äôs <code>rename_function</code>?</em></p>
<p><strong>Rhai Operators</strong> are parsed as Function Calls‚Ä¶</p>
<p><strong>‚Äú<code>a % b</code>‚Äù</strong> is represented in the Abstract Syntax Tree as <strong>‚Äú<code>% (a, b)</code>‚Äù</strong></p>
<p>We call <strong><code>rename_function</code></strong> to convert the Rhai Operator to its uLisp equivalent: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/transcode.rs#L335-L343"><code>transcode.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Rename a Rhai Function or Operator Name to uLisp:</span>
<span class="doccomment">/// `%` becomes `mod`, `==` becomes `eq`</span>
<span class="kw">fn</span> <span class="ident">rename_function</span>(<span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">String</span> {
  <span class="kw">match</span> <span class="ident">name</span> {
    <span class="string">&quot;%&quot;</span>  <span class="op">=</span><span class="op">&gt;</span> <span class="string">&quot;mod&quot;</span>,  <span class="comment">//  `%` becomes `mod`</span>
    <span class="string">&quot;==&quot;</span> <span class="op">=</span><span class="op">&gt;</span> <span class="string">&quot;eq&quot;</span>,   <span class="comment">//  `==` becomes `eq`</span>
    <span class="kw">_</span>    <span class="op">=</span><span class="op">&gt;</span> <span class="ident">name</span>    <span class="comment">//  Else pass through</span>
  }.<span class="ident">to_string</span>()
}</pre></div>
<p>This means that <strong>‚Äú<code>a % b</code>‚Äù</strong> in Rhai is rewritten as <strong>‚Äú<code>( mod a b )</code>‚Äù</strong> in uLisp.</p>
<h2 id="transcoder-scope" class="section-header"><a href="#transcoder-scope">4.6 Transcoder Scope</a></h2>
<p><em>Why do we need uLisp Scopes when transcoding Rhai to uLisp?</em></p>
<p>Watch what happens when we transcode Rhai to uLisp <strong>without using scopes</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-transcode3.jpg" alt="Transcode Rhai to uLisp without scopes" /></p>
<p>We see that the transcoded uLisp code ought to be <strong>nested inside each other</strong>.</p>
<p>To fix this we introduce <strong>uLisp Scopes</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/scope.rs"><code>bl602-script/scope.rs</code></a></p>
<p><img src="https://lupyuen.github.io/images/rhai-scope.png" alt="uLisp Scopes" /></p>
<p>With uLisp Scopes, our transcoded uLisp code becomes <strong>correctly nested</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rhai-transcode4.jpg" alt="Rhai Script transcoded to uLisp" /></p>
<h1 id="run-the-transcoded-ulisp" class="section-header"><a href="#run-the-transcoded-ulisp">5 Run the Transcoded uLisp</a></h1>
<p>Remember our <a href="https://lupyuen.github.io/articles/rhai#convert-rhai-to-ulisp"><strong>kitchen-sink Rhai Script</strong></a> from earlier?</p>
<p>Here‚Äôs the uLisp Code <strong>generated by our Rhai Transcoder</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/transcode/bl602-script/src/lib.rs#L550-L571"><code>bl602-script/lib.rs</code></a></p>
<pre><code class="language-text">( let* () 
  ( loop 
    ( let* (( a 1 )) 
      ( print a )
      ( if ( eq a 1 ) 
        ( return )
      )
    )
  )
  ( let* (( LED_GPIO 11 )) 
    ( bl_gpio_enable_output LED_GPIO 0 0 )
    ( dotimes (i 10) 
      ( bl_gpio_output_set LED_GPIO ( mod i 2 ) )
      ( time_delay 1000 )
    )
    ( let* (( a 40 )) 
      ( let* (( b 2 )) 
        ( + a b )
      )
    )
  )
)
</code></pre>
<p>Yep it looks like proper uLisp!</p>
<p>Just that we need to <strong>define these BL602 Functions</strong> in uLisp‚Ä¶</p>
<ul>
<li>
<p><strong><code>bl_gpio_enable_output</code></strong>: Configure a GPIO Pin for output</p>
</li>
<li>
<p><strong><code>bl_gpio_output_set</code></strong>: Set the output value of a GPIO Pin</p>
</li>
<li>
<p><strong><code>time_delay</code></strong>: Delay for a specified number of milliseconds</p>
</li>
</ul>
<p>Fortunately uLisp lets us <strong>extend its interpreter</strong> by adding the above  functions in C.</p>
<p>(Details in the Appendix)</p>
<p>And the output from our Rhai Transcoder <strong>runs OK on uLisp</strong>!</p>
<p><img src="https://lupyuen.github.io/images/rhai-run.png" alt="Running the Transcoded uLisp" /></p>
<h1 id="drag-and-drop-rhai-scripting" class="section-header"><a href="#drag-and-drop-rhai-scripting">6 Drag-and-Drop Rhai Scripting</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/rhai-title.jpg" alt="Drag-and-drop scripting with Blockly and Rhai" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/rhai-blockly.png" alt="" /></p>
<p>TODO6</p>
<p><img src="https://lupyuen.github.io/images/rhai-blockly2.png" alt="" /></p>
<p>TODO</p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">7 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>And soon we shall test all this on <a href="https://lupyuen.github.io/articles/pinedio"><strong>PineDio Stack BL604 with LoRa SX1262</strong></a>‚Ä¶ As we explore whether it‚Äôs feasible to teach <strong>Rust (or Rhai) as a Safer Way</strong> to create firmware for BL602 and BL604.</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/rhai.md"><code>lupyuen.github.io/src/rhai.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">8 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1427758328004759552">this Twitter Thread</a></p>
</li>
<li>
<p>What happens when we run the <strong>Rhai Scripting Engine on BL602</strong> (configured for the smallest feature set)?</p>
<p>It seems to crash with a Stack Overflow. <a href="https://github.com/lupyuen/bl_iot_sdk/tree/adc/customer_app/sdk_app_rust_script">(See this)</a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/rhai-run.png" alt="Running the Transcoded uLisp" /></p>
<h1 id="appendix-add-c-functions-to-ulisp" class="section-header"><a href="#appendix-add-c-functions-to-ulisp">9 Appendix: Add C Functions to uLisp</a></h1>
<p>To run the transcoded uLisp, we need to <strong>define these BL602 Functions</strong> in uLisp‚Ä¶</p>
<ul>
<li>
<p><strong><code>bl_gpio_enable_output</code></strong>: Configure a GPIO Pin for output</p>
</li>
<li>
<p><strong><code>bl_gpio_output_set</code></strong>: Set the output value of a GPIO Pin</p>
</li>
<li>
<p><strong><code>time_delay</code></strong>: Delay for a specified number of milliseconds</p>
</li>
</ul>
<p>Here‚Äôs how we <strong>extend the uLisp Interpreter</strong> by adding the above  functions in C‚Ä¶</p>
<p>First we define the <strong>uLisp Shim Function</strong> in C: <a href="https://github.com/lupyuen/ulisp-bl602/blob/sdk/src/ulisp.c#L4136-L4163"><code>ulisp.c</code></a></p>
<pre><code class="language-c">//  Expose the C function `bl_gpio_enable_output` to uLisp:
//  `int bl_gpio_enable_output(uint8_t pin, uint8_t pullup, uint8_t pulldown)`
object *fn_bl_gpio_enable_output(object *args, object *env) {
  //  Fetch the `pin` parameter from uLisp
  assert(args != NULL);
  int pin = checkinteger(BL_GPIO_ENABLE_OUTPUT, car(args));
  args = cdr(args);

  //  Fetch the `pullup` parameter from uLisp
  assert(args != NULL);
  int pullup = checkinteger(BL_GPIO_ENABLE_OUTPUT, car(args));
  args = cdr(args);

  //  Fetch the `pulldown` parameter from uLisp
  assert(args != NULL);
  int pulldown = checkinteger(BL_GPIO_ENABLE_OUTPUT, car(args));
  args = cdr(args);

  //  No more parameters
  assert(args == NULL);
  printf(&quot;bl_gpio_enable_output: pin=%d, pullup=%d, pulldown=%d\r\n&quot;, pin, pullup, pulldown);

  //  Call the C function `bl_gpio_enable_output`
  int result = bl_gpio_enable_output(pin, pullup, pulldown);

  //  Return the result to uLisp
  //  TODO: Throw an exception if the result is non-zero
  return number(result);
}
</code></pre>
<p>Next we extend the <strong>Function Enum</strong>: <a href="https://github.com/lupyuen/ulisp-bl602/blob/sdk/src/ulisp.c#L196-L200"><code>ulisp.c</code></a></p>
<pre><code class="language-c">enum function {
  ...
  //  Begin User Functions
  BL_GPIO_ENABLE_OUTPUT,
  BL_GPIO_OUTPUT_SET,
  TIME_DELAY,
  //  End User Functions
</code></pre>
<p>Then we define the <strong>uLisp Function Name</strong>: <a href="https://github.com/lupyuen/ulisp-bl602/blob/sdk/src/ulisp.c#L4434-L4438"><code>ulisp.c</code></a></p>
<pre><code class="language-c">// Insert your own function names here
const char str_bl_gpio_enable_output[] PROGMEM = &quot;bl_gpio_enable_output&quot;;
const char str_bl_gpio_output_set[]    PROGMEM = &quot;bl_gpio_output_set&quot;;
const char str_time_delay[]            PROGMEM = &quot;time_delay&quot;;
</code></pre>
<p>Finally we add the uLisp Shim Function to the <strong>Symbol Lookup Table</strong>: <a href="https://github.com/lupyuen/ulisp-bl602/blob/sdk/src/ulisp.c#L4667-L4671"><code>ulisp.c</code></a></p>
<pre><code class="language-c">// Built-in symbol lookup table
const tbl_entry_t lookup_table[] PROGMEM = {
  ...
  // Insert your own table entries here
  { str_bl_gpio_enable_output, fn_bl_gpio_enable_output, 0x33 },
  { str_bl_gpio_output_set,    fn_bl_gpio_output_set,    0x22 },
  { str_time_delay,            fn_time_delay,            0x11 },
</code></pre>
<p><em>What is <code>0x33</code>?</em></p>
<p><strong><code>0x33</code></strong> means that our uLisp Function accepts</p>
<ul>
<li>
<p><strong>Minimum</strong> of 3 parameters, and</p>
</li>
<li>
<p><strong>Maximum</strong> of 3 parameters</p>
</li>
</ul>
<p><a href="http://www.ulisp.com/show?19Q4">(More about extending uLisp)</a></p>

    
</body>
</html>