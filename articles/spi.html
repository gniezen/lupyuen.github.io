<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>PineCone BL602 talks SPI too!</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="PineCone BL602 talks SPI too!" 
    data-rh="true">
<meta property="og:description" 
    content="PineCone BL602 RISC-V Board talks to BME280 Sensor over SPI... Let's find out how" 
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/spi-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">PineCone BL602 talks SPI too!</h1>
    <nav id="TOC"><ul>
<li><a href="#times-are-a-changin">1 Times Are a-Changin'</a><ul></ul></li>
<li><a href="#bl602-hardware-abstraction-layer-for-spi">2 BL602 Hardware Abstraction Layer for SPI</a><ul></ul></li>
<li><a href="#connect-bl602-to-bme280-spi-sensor">3 Connect BL602 to BME280 SPI Sensor</a><ul>
<li><a href="#selecting-spi-pins">3.1 Selecting SPI Pins</a><ul></ul></li>
<li><a href="#spi-protocol-for-bme280">3.2 SPI Protocol for BME280</a><ul></ul></li></ul></li>
<li><a href="#initialise-spi-port">4 Initialise SPI Port</a><ul></ul></li>
<li><a href="#transmit-spi-data">5 Transmit SPI Data</a><ul></ul></li>
<li><a href="#receive-spi-data">6 Receive SPI Data</a><ul></ul></li>
<li><a href="#control-our-own-chip-select-pin">7 Control our own Chip Select Pin</a><ul></ul></li>
<li><a href="#show-the-results">8 Show the Results</a><ul></ul></li>
<li><a href="#build-and-run-the-firmware">9 Build and Run the Firmware</a><ul></ul></li>
<li><a href="#spi-data-pins-are-flipped">10 SPI Data Pins are flipped</a><ul></ul></li>
<li><a href="#spi-polarity-and-phase">11 SPI Polarity and Phase</a><ul></ul></li>
<li><a href="#pin-0-controls-wifi-led">12 Pin 0 controls WiFi LED</a><ul></ul></li>
<li><a href="#port-bl602-spi-hal-to-other-operating-systems">13 Port BL602 SPI HAL to other Operating Systems</a><ul></ul></li>
<li><a href="#whats-next">14 What's Next</a><ul></ul></li>
<li><a href="#appendix-test-bme280-with-bus-pirate">15 Appendix: Test BME280 with Bus Pirate</a><ul></ul></li>
<li><a href="#appendix-troubleshoot-bl602-spi-with-logic-analyser">16 Appendix: Troubleshoot BL602 SPI with Logic Analyser</a><ul></ul></li>
<li><a href="#appendix-inside-bl602-spi-hal">17 Appendix: Inside BL602 SPI HAL</a><ul>
<li><a href="#definitions">17.1 Definitions</a><ul></ul></li>
<li><a href="#spi_init-init-spi-port">17.2 spi_init: Init SPI Port</a><ul></ul></li>
<li><a href="#hal_spi_set_rwspeed-set-spi-speed">17.3 hal_spi_set_rwspeed: Set SPI Speed</a><ul></ul></li>
<li><a href="#hal_spi_init-init-spi-pins-and-dma">17.4 hal_spi_init: Init SPI Pins and DMA</a><ul></ul></li>
<li><a href="#hal_gpio_init-init-spi-pins">17.5 hal_gpio_init: Init SPI Pins</a><ul></ul></li>
<li><a href="#hal_spi_dma_init-init-spi-dma">17.6 hal_spi_dma_init: Init SPI DMA</a><ul></ul></li>
<li><a href="#hal_spi_transfer-execute-spi-transfer">17.7 hal_spi_transfer: Execute SPI Transfer</a><ul></ul></li>
<li><a href="#hal_spi_dma_trans-execute-spi-transfer-with-dma">17.8 hal_spi_dma_trans: Execute SPI Transfer with DMA</a><ul></ul></li>
<li><a href="#lli_list_init-init-dma-linked-list">17.9 lli_list_init: Init DMA Linked List</a><ul></ul></li>
<li><a href="#bl_spi0_dma_int_handler_tx-transmit-dma-interrupt-handler">17.10 bl_spi0_dma_int_handler_tx: Transmit DMA Interrupt Handler</a><ul></ul></li>
<li><a href="#bl_spi0_dma_int_handler_rx-receive-dma-interrupt-handler">17.11 bl_spi0_dma_int_handler_rx: Receive DMA Interrupt Handler</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>10 Feb 2021</em></p>
<p>Here's the source code for BL602 accessing BME280 over SPI: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/customer_app/sdk_app_spi/sdk_app_spi/demo.c"><code>sdk_app_spi/demo.c</code></a></p>
<p>In this article we'll study the source code and look into these issues with BL602 SPI...</p>
<ol>
<li>
<p>The pins for <strong>Serial Data In</strong> and <strong>Serial Data Out</strong> seem to be flipped, when observed with a Logic Analyser. </p>
<p>This contradicts the BL602 Reference Manual.</p>
</li>
<li>
<p>To talk to BME280, we must configure BL602 for <strong>SPI Polarity 0, Phase 1</strong>.</p>
<p>Though the Logic Analyser shows that it looks like SPI Phase 0.</p>
</li>
<li>
<p>BL602's <strong>SPI Chip Select Pin</strong> doesn't work with BME280's SPI protocol.</p>
<p>We'll control the SPI Chip Select Pin ourselves.</p>
</li>
<li>
<p>Setting <strong>Serial Data Out to Pin 0</strong> will switch on the WiFi LED.</p>
<p>We'll switch to a different pin for Serial Data Out.</p>
</li>
</ol>
<p>Also we'll learn to <strong>troubleshoot BL602 SPI with a Logic Analyser</strong>.</p>
<p><img src="https://lupyuen.github.io/images/spi-title.jpg" alt="PineCone BL602 RISC-V Board connected to BME280 SPI Sensor" /></p>
<p><em>PineCone BL602 RISC-V Board connected to BME280 SPI Sensor</em></p>
<h1 id="times-are-a-changin" class="section-header"><a href="#times-are-a-changin">1 Times Are a-Changin'</a></h1>
<p>Humans evolve... So do the terms that we use!</p>
<p>This article will become obsolete quickly unless we adopt the <a href="https://www.oshwa.org/a-resolution-to-redefine-spi-signal-names"><strong>new names for SPI Pins</strong></a>...</p>
<ul>
<li>
<p>We'll say <strong>&quot;Serial Data In (SDI)&quot;</strong> <em>(instead of &quot;MISO&quot;)</em></p>
</li>
<li>
<p>And we'll say <strong>&quot;Serial Data Out (SDO)&quot;</strong> <em>(instead of &quot;MOSI&quot;)</em></p>
</li>
<li>
<p>We'll refer to BL602 as the <strong>&quot;SPI Controller&quot;</strong></p>
</li>
<li>
<p>And BME280 as the <strong>&quot;SPI Peripheral&quot;</strong></p>
</li>
</ul>
<p>Note that Serial Data In and Serial Data Out are flipped across the SPI Controller and the SPI Peripheral...</p>
<ul>
<li>
<p><strong>Serial Data In on BL602</strong> connects to <strong>Serial Data Out on BME280</strong></p>
</li>
<li>
<p>And <strong>Serial Data Out on BL602</strong> connects to <strong>Serial Data In on BME280</strong></p>
</li>
</ul>
<p>(Yep it works like the Transmit / Receive pins for a UART port)</p>
<h1 id="bl602-hardware-abstraction-layer-for-spi" class="section-header"><a href="#bl602-hardware-abstraction-layer-for-spi">2 BL602 Hardware Abstraction Layer for SPI</a></h1>
<p>The BL602 IoT SDK contains an <strong>SPI Hardware Abstraction Layer (HAL)</strong> that we may call in our C programs to transfer data over SPI...</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/components/hal_drv/bl602_hal/hal_spi.c"><strong>BL602 SPI HAL: <code>bl602_hal/hal_spi.c</code></strong></a></li>
</ul>
<p>However there are a couple of concerns over the BL602 SPI HAL...</p>
<ol>
<li>
<p><strong>BL602 SPI HAL doesn't support all BL602 SPI features</strong>.</p>
<p>It supports SPI Transfers via <strong>Direct Memory Access (DMA)</strong>. Which is good for blasting pixels to Display Controllers (like ST7789).</p>
<p>But it <strong>doesn't support byte-by-byte SPI Transfer</strong>, like the <a href="https://github.com/pine64/ArduinoCore-bouffalo/blob/main/libraries/SPI/src/SPI.cpp"><strong>Arduino SPI HAL for BL602</strong></a>.</p>
</li>
<li>
<p><strong>BL602 SPI HAL was designed to work with <a href="https://github.com/alibaba/AliOS-Things">AliOS Things</a></strong> operating system and its Virtual File System.</p>
<p>It uses the AliOS Device Tree for configuring the SPI Port. Which might be overkill for some embedded programs.</p>
<p>I have added an SPI HAL function <a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/components/hal_drv/bl602_hal/hal_spi.c#L838-L886"><strong><code>spi_init</code></strong></a> that lets us <strong>call the SPI HAL without AliOS Things</strong> and its Device Tree.</p>
</li>
<li>
<p><strong>BL602 SPI HAL works only with FreeRTOS</strong>.</p>
<p>Unlike the BL602 HALs for GPIO, PWM and I2C, there's no Low Level HAL that works on all operating systems.</p>
<p>But we may port the SPI HAL to other operating systems by emulating a few FreeRTOS functions for Event Groups.  (More about this later)</p>
</li>
</ol>
<p>Hence we can still <strong>write SPI programs for BL602 without AliOS</strong>. And I'll highlight the SPI features that have special limitations.</p>
<p>We shall test BL602 SPI with this BL602 Command-Line Firmware that I have created: <a href="https://github.com/lupyuen/bl_iot_sdk/tree/spi/customer_app/sdk_app_spi"><code>sdk_app_spi</code></a></p>
<p>The firmware will work on <strong>all BL602 boards,</strong> including PineCone and Pinenut.</p>
<p><img src="https://lupyuen.github.io/images/spi-connect.jpg" alt="PineCone BL602 connected to SparkFun BME280 Sensor over SPI" /></p>
<p><em>PineCone BL602 connected to <a href="https://www.sparkfun.com/products/13676">SparkFun BME280 Sensor</a>  over SPI</em></p>
<h1 id="connect-bl602-to-bme280-spi-sensor" class="section-header"><a href="#connect-bl602-to-bme280-spi-sensor">3 Connect BL602 to BME280 SPI Sensor</a></h1>
<p>Let's connect BL602 to the <a href="https://learn.sparkfun.com/tutorials/sparkfun-bme280-breakout-hookup-guide"><strong>Bosch BME280 Sensor for Temperature, Humidity and Air Pressure</strong></a></p>
<p>(The steps in this article will work for BMP280 too)</p>
<p>BME280 supports two interfaces: SPI (6 pins) and I2C (4 pins). We shall connect to the <strong>SPI side of BME280</strong>.</p>
<p><em>Don't use any pins on the I2C side! (Because the <code>3V3</code> pin selects SPI or I2C)</em></p>
<p>Connect BL602 to BME280 (the SPI side with 6 pins) according to the pic above...</p>
<table><thead><tr><th align="center">BL602 Pin</th><th align="center">BME280 SPI</th><th align="left">Wire Colour</th></tr></thead><tbody>
<tr><td align="center"><strong><code>GPIO 1</code></strong></td><td align="center"><code>SDO</code></td><td align="left">Green</td></tr>
<tr><td align="center"><strong><code>GPIO 2</code></strong></td><td align="center">Do Not <br> Connect</td><td align="left">Do Not <br> Connect</td></tr>
<tr><td align="center"><strong><code>GPIO 3</code></strong></td><td align="center"><code>SCK</code></td><td align="left">Yellow</td></tr>
<tr><td align="center"><strong><code>GPIO 4</code></strong></td><td align="center"><code>SDI</code></td><td align="left">Blue</td></tr>
<tr><td align="center"><strong><code>GPIO 14</code></strong></td><td align="center"><code>CS</code></td><td align="left">Orange</td></tr>
<tr><td align="center"><strong><code>3V3</code></strong></td><td align="center"><code>3.3V</code></td><td align="left">Red</td></tr>
<tr><td align="center"><strong><code>GND</code></strong></td><td align="center"><code>GND</code></td><td align="left">Black</td></tr>
</tbody></table>
<p>(For BME280: SDO = MISO and SDI = MOSI)</p>
<p>We'll talk about GPIO 2 in a while.</p>
<h2 id="selecting-spi-pins" class="section-header"><a href="#selecting-spi-pins">3.1 Selecting SPI Pins</a></h2>
<p>We're NOT using the <a href="https://wiki.pine64.org/wiki/Nutcracker#Pinenut-12S_Module_information">Recommended SPI Pins for PineCone and Pinenut</a>: GPIO 0, 11, 14, 17.</p>
<p>And we're NOT using the <a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/bl602/device_tree/bl_factory_params_IoTKitA_40M.dts#L237-L259">Default SPI Pins for BL602 Device Tree</a>: GPIO 0, 1, 2, 3.</p>
<p><em>Why did we choose these pins for SPI?</em></p>
<ul>
<li>
<p><strong>GPIO 0</strong> is connected to the <strong>PineCone's WiFi LED</strong> (Is this documented somewhere?)</p>
</li>
<li>
<p><strong>GPIO 11, 14, 17</strong> are connected to <strong>PineCone's RGB LED</strong></p>
</li>
</ul>
<p>We won't use these PineCone LED Pins for SPI because...</p>
<ol>
<li>
<p>Somebody else will probably use the LED Pins to control the LEDs. Contention ensues!</p>
</li>
<li>
<p>Lights switching on for no reason is just plain... Spooky</p>
</li>
</ol>
<p>(Sorry my mistake... I shouldn't be using Pin 14 for Chip Select. Beware of contention!)</p>
<h2 id="spi-protocol-for-bme280" class="section-header"><a href="#spi-protocol-for-bme280">3.2 SPI Protocol for BME280</a></h2>
<p><em>What shall we accomplish with BL602 and BME280?</em></p>
<ol>
<li>
<p>BME280 has a <strong>Chip ID Register, at Register ID <code>0xD0</code></strong></p>
</li>
<li>
<p>Reading the Chip ID Register will give us the <strong>Chip ID value <code>0x60</code></strong> </p>
<p>(<code>0x60</code> identifies the chip as BME280. For BMP280 the Chip ID is <code>0x58</code>)</p>
</li>
</ol>
<p><em>What's the SPI Data that will be transferred between BL602 and BME280?</em></p>
<p>Here's how BL602 and BME280 will talk over SPI...</p>
<ol>
<li>
<p>BL602 transmits byte <strong><code>0xD0</code></strong> to BME280 on <strong>Serial Data Out</strong> <em>(formerly MOSI)</em></p>
</li>
<li>
<p>BME280 returns byte <strong><code>0x60</code></strong> to BL602 on <strong>Serial Data In</strong> <em>(formerly MISO)</em></p>
</li>
</ol>
<p>The <strong>SPI Chip Select Pin (CS)</strong> and <strong>SPI Clock Pin (SCK)</strong> will frame and synchronise the data transfer...</p>
<p><img src="https://lupyuen.github.io/images/spi-analyse9a.png" alt="BL602 talks to BME280 over SPI" /></p>
<p><em>BL602 talks to BME280 over SPI</em></p>
<h1 id="initialise-spi-port" class="section-header"><a href="#initialise-spi-port">4 Initialise SPI Port</a></h1>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/customer_app/sdk_app_spi/sdk_app_spi/demo.c#L45-L100"><code>sdk_app_spi/demo.c</code></a></p>
<pre><code class="language-c">/// Use SPI Port Number 0
#define SPI_PORT   0

/// Use GPIO 14 as SPI Chip Select Pin
#define SPI_CS_PIN 14

/// SPI Port
static spi_dev_t spi;

/// Init the SPI Port
static void test_spi_init(char *buf, int len, int argc, char **argv)
{
    //  Configure the SPI Port
    //  Note: The Chip Select Pin below (2) must NOT be the same as SPI_CS_PIN (14). 
    //  Because the SPI Pin Function will override the GPIO Pin Function!

    //  TODO: The pins for Serial Data In and Serial Data Out seem to be flipped,
    //  when observed with a Logic Analyser. This contradicts the 
    //  BL602 Reference Manual. Why ???

    //  TODO: We must set Polarity=0, Phase=1. Though the Logic Analyser shows
    //  that it looks like Phase=0. Why ???

    //  TODO: Setting Serial Data Out to Pin 0 will switch on the WiFi LED.
    //  Why ???

    int rc = spi_init(
        &amp;spi,        //  SPI Device
        SPI_PORT,    //  SPI Port
        0,           //  SPI Mode: 0 for Controller (formerly Master), 1 for Peripheral (formerly Slave)
        1,           //  SPI Polar Phase: 0 (CPOL=0, CPHA=0), 1 (CPOL=0, CPHA=1), 2 (CPOL=1, CPHA=0) or 3 (CPOL=1, CPHA=1)
        200 * 1000,  //  SPI Frequency (200 kHz)
        2,   //  Transmit DMA Channel
        3,   //  Receive DMA Channel
        3,   //  (Yellow) SPI Clock Pin 
        2,   //  (Unused) SPI Chip Select Pin (Unused because we control GPIO 14 ourselves as Chip Select Pin. This must NOT be set to 14, SPI will override our GPIO!)
        1,   //  (Green)  SPI Serial Data In Pin  (formerly MISO)
        4    //  (Blue)   SPI Serial Data Out Pin (formerly MOSI)
    );
    assert(rc == 0);

    //  Configure Chip Select pin as a GPIO Pin
    GLB_GPIO_Type pins[1];
    pins[0] = SPI_CS_PIN;
    BL_Err_Type rc2 = GLB_GPIO_Func_Init(GPIO_FUN_SWGPIO, pins, sizeof(pins) / sizeof(pins[0]));
    assert(rc2 == SUCCESS);

    //  Configure Chip Select pin as a GPIO Output Pin (instead of GPIO Input)
    rc = bl_gpio_enable_output(SPI_CS_PIN, 0, 0);
    assert(rc == 0);

    //  Set Chip Select pin to High, to deactivate BME280
    printf(&quot;Set CS pin %d to high\r\n&quot;, SPI_CS_PIN);
    rc = bl_gpio_output_set(SPI_CS_PIN, 1);
    assert(rc == 0);
}
</code></pre>
<h1 id="transmit-spi-data" class="section-header"><a href="#transmit-spi-data">5 Transmit SPI Data</a></h1>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/customer_app/sdk_app_spi/sdk_app_spi/demo.c#L110-L156"><code>sdk_app_spi/demo.c</code></a></p>
<pre><code class="language-c">/// Start the SPI data transfer
static void test_spi_transfer(char *buf, int len, int argc, char **argv)
{
    //  Clear the buffers
    memset(&amp;tx_buf1, 0, sizeof(tx_buf1));
    memset(&amp;rx_buf1, 0, sizeof(rx_buf1));
    memset(&amp;tx_buf2, 0, sizeof(tx_buf2));
    memset(&amp;rx_buf2, 0, sizeof(rx_buf2));

    //  Prepare 2 SPI Transfers
    static spi_ioc_transfer_t transfers[2];
    memset(transfers, 0, sizeof(transfers));    

    //  First SPI Transfer: Transmit Register ID (0xD0) to BME280
    tx_buf1[0] = 0xd0;  //  Read BME280 Chip ID Register (0xD0). Read/Write Bit (High Bit) is 1 for Read.
    transfers[0].tx_buf = (uint32_t) tx_buf1;  //  Transmit Buffer (Register ID)
    transfers[0].rx_buf = (uint32_t) rx_buf1;  //  Receive Buffer
    transfers[0].len    = sizeof(tx_buf1);     //  How many bytes

    //  Second SPI Transfer: Receive Chip ID (0x60) from BME280
    tx_buf2[0] = 0xff;  //  Unused. Read/Write Bit (High Bit) is 1 for Read.
    transfers[1].tx_buf = (uint32_t) tx_buf2;  //  Transmit Buffer
    transfers[1].rx_buf = (uint32_t) rx_buf2;  //  Receive Buffer (Chip ID)
    transfers[1].len    = sizeof(tx_buf2);     //  How many bytes

    //  Set Chip Select pin to Low, to activate BME280
    printf(&quot;Set CS pin %d to low\r\n&quot;, SPI_CS_PIN);
    int rc = bl_gpio_output_set(SPI_CS_PIN, 0);
    assert(rc == 0);

    //  Execute the two SPI Transfers with the DMA Controller
    rc = hal_spi_transfer(
        &amp;spi,       //  SPI Device
        transfers,  //  SPI Transfers
        sizeof(transfers) / sizeof(transfers[0])  //  How many transfers (Number of requests, not bytes)
    );
    assert(rc == 0);

    //  DMA Controller will transmit and receive the SPI data in the background.
    //  hal_spi_transfer will wait for the two SPI Transfers to complete before returning.
    //  Now that we're done with the two SPI Transfers...

    //  Set Chip Select pin to High, to deactivate BME280
    rc = bl_gpio_output_set(SPI_CS_PIN, 1);
    assert(rc == 0);
    printf(&quot;Set CS pin %d to high\r\n&quot;, SPI_CS_PIN);
}
</code></pre>
<h1 id="receive-spi-data" class="section-header"><a href="#receive-spi-data">6 Receive SPI Data</a></h1>
<p>TODO</p>
<h1 id="control-our-own-chip-select-pin" class="section-header"><a href="#control-our-own-chip-select-pin">7 Control our own Chip Select Pin</a></h1>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/customer_app/sdk_app_spi/sdk_app_spi/demo.c#L86-L99"><code>sdk_app_spi/demo.c</code></a></p>
<pre><code class="language-c">/// Init the SPI Port
static void test_spi_init(...) {
    ...
    //  Configure Chip Select pin as a GPIO Pin
    GLB_GPIO_Type pins[1];
    pins[0] = SPI_CS_PIN;
    BL_Err_Type rc2 = GLB_GPIO_Func_Init(GPIO_FUN_SWGPIO, pins, sizeof(pins) / sizeof(pins[0]));
    assert(rc2 == SUCCESS);

    //  Configure Chip Select pin as a GPIO Output Pin (instead of GPIO Input)
    rc = bl_gpio_enable_output(SPI_CS_PIN, 0, 0);
    assert(rc == 0);

    //  Set Chip Select pin to High, to deactivate BME280
    printf(&quot;Set CS pin %d to high\r\n&quot;, SPI_CS_PIN);
    rc = bl_gpio_output_set(SPI_CS_PIN, 1);
    assert(rc == 0);
</code></pre>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/customer_app/sdk_app_spi/sdk_app_spi/demo.c#L135-L155"><code>sdk_app_spi/demo.c</code></a></p>
<pre><code class="language-c">/// Start the SPI data transfer
static void test_spi_transfer(...) {    
    ...
    //  Set Chip Select pin to Low, to activate BME280
    printf(&quot;Set CS pin %d to low\r\n&quot;, SPI_CS_PIN);
    int rc = bl_gpio_output_set(SPI_CS_PIN, 0);
    assert(rc == 0);

    //  Execute the two SPI Transfers with the DMA Controller
    rc = hal_spi_transfer(
        &amp;spi,       //  SPI Device
        transfers,  //  SPI Transfers
        sizeof(transfers) / sizeof(transfers[0])  //  How many transfers (Number of requests, not bytes)
    );
    assert(rc == 0);

    //  DMA Controller will transmit and receive the SPI data in the background.
    //  hal_spi_transfer will wait for the two SPI Transfers to complete before returning.
    //  Now that we're done with the two SPI Transfers...

    //  Set Chip Select pin to High, to deactivate BME280
    rc = bl_gpio_output_set(SPI_CS_PIN, 1);
    assert(rc == 0);
    printf(&quot;Set CS pin %d to high\r\n&quot;, SPI_CS_PIN);
</code></pre>
<h1 id="show-the-results" class="section-header"><a href="#show-the-results">8 Show the Results</a></h1>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/customer_app/sdk_app_spi/sdk_app_spi/demo.c#L158-L182"><code>sdk_app_spi/demo.c</code></a></p>
<pre><code class="language-c">/// Show the SPI data received and the interrupt counters
static void test_spi_result(char *buf, int len, int argc, char **argv)
{
    //  Show the received data
    printf(&quot;SPI Transfer #1: Received Data 0x%p:\r\n&quot;, rx_buf1);
    for (int i = 0; i &lt; sizeof(rx_buf1); i++) {
        printf(&quot;  %02x\r\n&quot;, rx_buf1[i]);
    }
    printf(&quot;SPI Transfer #2: Received Data 0x%p:\r\n&quot;, rx_buf2);
    for (int i = 0; i &lt; sizeof(rx_buf2); i++) {
        printf(&quot;  %02x\r\n&quot;, rx_buf2[i]);
    }

    //  Show the Interrupt Counters, Status and Error Codes defined in components/hal_drv/bl602_hal/hal_spi.c
    extern int g_tx_counter, g_rx_counter;
    extern uint32_t g_tx_status, g_tx_tc, g_tx_error, g_rx_status, g_rx_tc, g_rx_error;
    printf(&quot;Tx Interrupts: %d\r\n&quot;,   g_tx_counter);
    printf(&quot;Tx Status:     0x%x\r\n&quot;, g_tx_status);
    printf(&quot;Tx Term Count: 0x%x\r\n&quot;, g_tx_tc);
    printf(&quot;Tx Error:      0x%x\r\n&quot;, g_tx_error);
    printf(&quot;Rx Interrupts: %d\r\n&quot;,   g_rx_counter);
    printf(&quot;Rx Status:     0x%x\r\n&quot;, g_rx_status);
    printf(&quot;Rx Term Count: 0x%x\r\n&quot;, g_rx_tc);
    printf(&quot;Rx Error:      0x%x\r\n&quot;, g_rx_error);
}
</code></pre>
<h1 id="build-and-run-the-firmware" class="section-header"><a href="#build-and-run-the-firmware">9 Build and Run the Firmware</a></h1>
<p>TODO</p>
<pre><code class="language-text"># help
====Build-in Commands====
====Support 4 cmds once, seperate by ; ====
help                     : print this
p                        : print memory
m                        : modify memory
echo                     : echo for command
exit                     : close CLI
devname                  : print device name
sysver                   : system version
reboot                   : reboot system
poweroff                 : poweroff system
reset                    : system reset
time                     : system time
ota                      : system ota
ps                      : thread dump
ls                       : file list
hexdump                  : dump file
cat                      : cat file

====User Commands====
spi_init                 : Init SPI port
spi_transfer             : Transfer SPI data
spi_result               : Show SPI data received
blogset                  : blog pri set level
blogdump                 : blog info dump
bl_sys_time_now          : sys time now

# spi_init
port0 eventloop init = 42010b48
[HAL] [SPI] Init :
port=0, mode=0, polar_phase = 1, freq=200000, tx_dma_ch=2, rx_dma_ch=3, pin_clk=3, pin_cs=2, pin_mosi=1, pin_miso=4
set rwspeed = 200000
hal_gpio_init: cs:2, clk:3, mosi:1, miso: 4
hal_gpio_init: SPI controller mode
hal_spi_init.
Set CS pin 14 to high

# spi_transfer
Set CS pin 14 to low
hal_spi_transfr = 2
transfer xfer[0].len = 1
Tx DMA src=0x4200d1b8, dest=0x4000a288, size=1, si=1, di=0, i=1
Rx DMA src=0x4000a28c, dest=0x4200d1b0, size=1, si=0, di=1, i=1
recv all event group.
transfer xfer[1].len = 1
Tx DMA src=0x4200d1bc, dest=0x4000a288, size=1, si=1, di=0, i=1
Rx DMA src=0x4000a28c, dest=0x4200d1b4, size=1, si=0, di=1, i=1
recv all event group.
Set CS pin 14 to high

# spi_result
SPI Transfer #1: Received Data 0x0x4200d1b0:
  ff
SPI Transfer #2: Received Data 0x0x4200d1b4:
  60
Tx Interrupts: 2
Tx Status:     0x0
Tx Term Count: 0x0
Tx Error:      0x0
Rx Interrupts: 2
Rx Status:     0x0
Rx Term Count: 0x0
Rx Error:      0x0
</code></pre>
<h1 id="spi-data-pins-are-flipped" class="section-header"><a href="#spi-data-pins-are-flipped">10 SPI Data Pins are flipped</a></h1>
<p>TODO</p>
<h1 id="spi-polarity-and-phase" class="section-header"><a href="#spi-polarity-and-phase">11 SPI Polarity and Phase</a></h1>
<p>TODO</p>
<h1 id="pin-0-controls-wifi-led" class="section-header"><a href="#pin-0-controls-wifi-led">12 Pin 0 controls WiFi LED</a></h1>
<p>TODO</p>
<h1 id="port-bl602-spi-hal-to-other-operating-systems" class="section-header"><a href="#port-bl602-spi-hal-to-other-operating-systems">13 Port BL602 SPI HAL to other Operating Systems</a></h1>
<p>TODO</p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">14 What's Next</a></h1>
<p>TODO</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here...</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/spi.md"><code>lupyuen.github.io/src/spi.md</code></a></p>
<h1 id="appendix-test-bme280-with-bus-pirate" class="section-header"><a href="#appendix-test-bme280-with-bus-pirate">15 Appendix: Test BME280 with Bus Pirate</a></h1>
<p>TODO</p>
<h1 id="appendix-troubleshoot-bl602-spi-with-logic-analyser" class="section-header"><a href="#appendix-troubleshoot-bl602-spi-with-logic-analyser">16 Appendix: Troubleshoot BL602 SPI with Logic Analyser</a></h1>
<p>TODO</p>
<h1 id="appendix-inside-bl602-spi-hal" class="section-header"><a href="#appendix-inside-bl602-spi-hal">17 Appendix: Inside BL602 SPI HAL</a></h1>
<p>TODO</p>
<h2 id="definitions" class="section-header"><a href="#definitions">17.1 Definitions</a></h2>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/components/hal_drv/bl602_hal/hal_spi.c#L57-L58"><code>bl602_hal/hal_spi.c</code></a></p>
<pre><code class="language-c">#define HAL_SPI_DEBUG       (1)  ////  TODO: Change to 0 for production to disable logging
#define HAL_SPI_HARDCS      (1)  ////  TODO: When set to 0, this is supposed to control Chip Select Pin as GPIO (instead of SPI). But this doesn't work, because the pin has been configured for SPI Port, which overrides GPIO.
</code></pre>
<h2 id="spi_init-init-spi-port" class="section-header"><a href="#spi_init-init-spi-port">17.2 spi_init: Init SPI Port</a></h2>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/components/hal_drv/bl602_hal/hal_spi.c#L838-L886"><code>bl602_hal/hal_spi.c</code></a></p>
<pre><code class="language-c">//  Global single instance of SPI Data. We supports only one instance of SPI Device.
static spi_priv_data_t g_spi_data;

//  TODO: Init the SPI Device for DMA without calling AOS and Device Tree. Return non-zero in case of error. Supports only one instance of SPI Device.
//  Based on vfs_spi_init_fullname.
int spi_init(spi_dev_t *spi, uint8_t port,
    uint8_t mode, uint8_t polar_phase, uint32_t freq, uint8_t tx_dma_ch, uint8_t rx_dma_ch,
    uint8_t pin_clk, uint8_t pin_cs, uint8_t pin_mosi, uint8_t pin_miso)
{
    assert(spi != NULL);

    //  Use the global single instance of SPI Data
    g_hal_buf = &amp;g_spi_data;
    memset(g_hal_buf, 0, sizeof(spi_priv_data_t));

    //  Create the Event Group for DMA Interrupt Handler to notify Foreground Task
    g_hal_buf-&gt;hwspi[port].spi_dma_event_group = xEventGroupCreate();
    blog_info(&quot;port%d eventloop init = %08lx\r\n&quot;, port,
        (uint32_t)g_hal_buf-&gt;hwspi[port].spi_dma_event_group);
    if (NULL == g_hal_buf-&gt;hwspi[port].spi_dma_event_group) {
        return -ENOMEM;
    }

    //  Init the SPI Device
    memset(spi, 0, sizeof(spi_dev_t));
    spi-&gt;port = port;
    spi-&gt;config.mode = mode;
    spi-&gt;config.freq  = 0;  //  Will validate and set frequency in hal_spi_set_rwspeed
    g_hal_buf-&gt;hwspi[port].ssp_id      = port;
    g_hal_buf-&gt;hwspi[port].mode        = mode;
    g_hal_buf-&gt;hwspi[port].polar_phase = polar_phase;
    g_hal_buf-&gt;hwspi[port].freq        = 0;  //  Will validate and set frequency in hal_spi_set_rwspeed
    g_hal_buf-&gt;hwspi[port].tx_dma_ch   = tx_dma_ch;
    g_hal_buf-&gt;hwspi[port].rx_dma_ch   = rx_dma_ch;
    g_hal_buf-&gt;hwspi[port].pin_clk     = pin_clk;
    g_hal_buf-&gt;hwspi[port].pin_cs      = pin_cs;
    g_hal_buf-&gt;hwspi[port].pin_mosi    = pin_mosi;
    g_hal_buf-&gt;hwspi[port].pin_miso    = pin_miso;

    //  SPI Device points to global single instance of SPI Data
    spi-&gt;priv = g_hal_buf;
    blog_info(&quot;[HAL] [SPI] Init :\r\nport=%d, mode=%d, polar_phase = %d, freq=%ld, tx_dma_ch=%d, rx_dma_ch=%d, pin_clk=%d, pin_cs=%d, pin_mosi=%d, pin_miso=%d\r\n&quot;,
        port, mode, polar_phase, freq, tx_dma_ch, rx_dma_ch, pin_clk, pin_cs, pin_mosi, pin_miso);

    //  Init the SPI speed, pins and DMA
    int rc = hal_spi_set_rwspeed(spi, freq);
    assert(rc == 0);
    return rc;
}
</code></pre>
<h2 id="hal_spi_set_rwspeed-set-spi-speed" class="section-header"><a href="#hal_spi_set_rwspeed-set-spi-speed">17.3 hal_spi_set_rwspeed: Set SPI Speed</a></h2>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/components/hal_drv/bl602_hal/hal_spi.c#L430-L480"><code>bl602_hal/hal_spi.c</code></a></p>
<pre><code class="language-c">int hal_spi_set_rwspeed(spi_dev_t *spi_dev, uint32_t speed)
{
    spi_priv_data_t *data;
    int i;
    uint8_t real_flag = 0;
    uint32_t real_speed = 0;

#if (HAL_SPI_DEBUG)
    blog_info(&quot;set rwspeed = %ld\r\n&quot;, speed);
#endif
    if (spi_dev-&gt;config.freq == speed) {
        blog_info(&quot;speed not change.\r\n&quot;);
        return 0;
    }

    for (i = 0; i &lt; 256; i++) {
        if (speed == (40000000/(i+1))) {
            real_speed = speed;
            real_flag = 1;
        } else if (speed &lt; (40000000/(i+1))) {
            continue;
        } else {
            break;
        }
    }

    if (real_flag != 1) {
        if (i == 0) {
            blog_error(&quot;The max speed is 40000000 Hz, please set it smaller.&quot;);
            return -1;
        } else if (i == 256) {
            blog_error(&quot;The min speed is 156250 Hz, please set it bigger.&quot;);
            return -1;
        } else {
            if ( ((40000000/(i+1)) - speed) &gt; (speed - (40000000/i)) ) {
                real_speed = (40000000/(i+1));
                blog_info(&quot;not support speed: %ld, change real_speed = %ld\r\n&quot;, speed, real_speed);
            } else {
                real_speed = (40000000/i);
                blog_info(&quot;not support speed: %ld, change real_speed = %ld\r\n&quot;, speed, real_speed);
            }
        }
    }

    data = (spi_priv_data_t *)spi_dev-&gt;priv;
    data-&gt;hwspi[spi_dev-&gt;port].freq = real_speed;
    spi_dev-&gt;config.freq = real_speed;

    hal_spi_init(spi_dev);
    return 0;
}
</code></pre>
<h2 id="hal_spi_init-init-spi-pins-and-dma" class="section-header"><a href="#hal_spi_init-init-spi-pins-and-dma">17.4 hal_spi_init: Init SPI Pins and DMA</a></h2>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/components/hal_drv/bl602_hal/hal_spi.c#L360-L384"><code>bl602_hal/hal_spi.c</code></a></p>
<pre><code class="language-c">int32_t hal_spi_init(spi_dev_t *spi)
{
    int i;
    spi_priv_data_t *data;

    if (!spi) {
        blog_error(&quot;arg err.\r\n&quot;);
    }

    data = (spi_priv_data_t *)spi-&gt;priv;
    if (data == NULL) {
        return -1;
    }

    for (i = 0; i &lt; SPI_NUM_MAX; i++) {
        hal_gpio_init(&amp;data-&gt;hwspi[i]);
        hal_spi_dma_init(&amp;data-&gt;hwspi[i]);
    }

#if (HAL_SPI_DEBUG)
    blog_info(&quot;hal_spi_init.\r\n&quot;);
#endif

    return 0;
}
</code></pre>
<h2 id="hal_gpio_init-init-spi-pins" class="section-header"><a href="#hal_gpio_init-init-spi-pins">17.5 hal_gpio_init: Init SPI Pins</a></h2>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/components/hal_drv/bl602_hal/hal_spi.c#L98-L124"><code>bl602_hal/hal_spi.c</code></a></p>
<pre><code class="language-c">static void hal_gpio_init(spi_hw_t *arg)
{
    GLB_GPIO_Type gpiopins[4];

    if (!arg) {
        blog_error(&quot;arg err.\r\n&quot;);
        return;
    }
    blog_info(&quot;hal_gpio_init: cs:%d, clk:%d, mosi:%d, miso: %d\r\n&quot;, arg-&gt;pin_cs, arg-&gt;pin_clk, arg-&gt;pin_mosi, arg-&gt;pin_miso);

    gpiopins[0] = arg-&gt;pin_cs;
    gpiopins[1] = arg-&gt;pin_clk;
    gpiopins[2] = arg-&gt;pin_mosi;
    gpiopins[3] = arg-&gt;pin_miso;
    
    GLB_GPIO_Func_Init(GPIO_FUN_SPI,gpiopins,sizeof(gpiopins)/sizeof(gpiopins[0]));

    if (arg-&gt;mode == 0) {
        blog_info(&quot;hal_gpio_init: SPI controller mode\r\n&quot;);
        GLB_Set_SPI_0_ACT_MOD_Sel(GLB_SPI_PAD_ACT_AS_MASTER);
    } else {
        blog_info(&quot;hal_gpio_init: SPI peripheral mode\r\n&quot;);
        GLB_Set_SPI_0_ACT_MOD_Sel(GLB_SPI_PAD_ACT_AS_SLAVE);
    }

    return;
}
</code></pre>
<h2 id="hal_spi_dma_init-init-spi-dma" class="section-header"><a href="#hal_spi_dma_init-init-spi-dma">17.6 hal_spi_dma_init: Init SPI DMA</a></h2>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/components/hal_drv/bl602_hal/hal_spi.c#L207-L288"><code>bl602_hal/hal_spi.c</code></a></p>
<pre><code class="language-c">static void hal_spi_dma_init(spi_hw_t *arg)
{
    spi_hw_t *hw_arg = arg;
    SPI_CFG_Type spicfg;
    SPI_ClockCfg_Type clockcfg;
    SPI_FifoCfg_Type fifocfg;
    SPI_ID_Type spi_id;
    uint8_t clk_div;
    
    spi_id = hw_arg-&gt;ssp_id;

    /* clock */
    /*1  ---&gt;  40 Mhz
     *2  ---&gt;  20 Mhz
     *5  ---&gt;  8  Mhz
     *6  ---&gt;  6.66 Mhz
     *10 ---&gt;  4 Mhz
     * */
    clk_div = (uint8_t)(40000000 / hw_arg-&gt;freq);
    GLB_Set_SPI_CLK(ENABLE,0);
    clockcfg.startLen = clk_div;
    clockcfg.stopLen = clk_div;
    clockcfg.dataPhase0Len = clk_div;
    clockcfg.dataPhase1Len = clk_div;
    clockcfg.intervalLen = clk_div;
    SPI_ClockConfig(spi_id, &amp;clockcfg);

    /* spi config */
    spicfg.deglitchEnable = DISABLE;
    spicfg.continuousEnable = ENABLE;
    spicfg.byteSequence = SPI_BYTE_INVERSE_BYTE0_FIRST,
    spicfg.bitSequence = SPI_BIT_INVERSE_MSB_FIRST,
    spicfg.frameSize = SPI_FRAME_SIZE_8;

    if (hw_arg-&gt;polar_phase == 0) {
        spicfg.clkPhaseInv = SPI_CLK_PHASE_INVERSE_0;
        spicfg.clkPolarity = SPI_CLK_POLARITY_LOW;
    } else if (hw_arg-&gt;polar_phase == 1) {
        spicfg.clkPhaseInv = SPI_CLK_PHASE_INVERSE_1;
        spicfg.clkPolarity = SPI_CLK_POLARITY_LOW;
    } else if (hw_arg-&gt;polar_phase == 2) {
        spicfg.clkPhaseInv = SPI_CLK_PHASE_INVERSE_0;
        spicfg.clkPolarity = SPI_CLK_POLARITY_HIGH;
    } else if (hw_arg-&gt;polar_phase == 3) {
        spicfg.clkPhaseInv = SPI_CLK_PHASE_INVERSE_1;
        spicfg.clkPolarity = SPI_CLK_POLARITY_HIGH;
    } else {
        blog_error(&quot;node support polar_phase \r\n&quot;);
    }
    SPI_Init(0,&amp;spicfg);  //// TODO: In future when there are multiple SPI ports, this should be SPI_Init(spi_id, &amp;spicfg)

    if (hw_arg-&gt;mode == 0)
    {
        SPI_Disable(spi_id, SPI_WORK_MODE_MASTER);
    } else {
        SPI_Disable(spi_id, SPI_WORK_MODE_SLAVE);
    }

    SPI_IntMask(spi_id,SPI_INT_ALL,MASK);

    /* fifo */
    fifocfg.txFifoThreshold = 1;
    fifocfg.rxFifoThreshold = 1;
    fifocfg.txFifoDmaEnable = ENABLE;
    fifocfg.rxFifoDmaEnable = ENABLE;
    SPI_FifoConfig(spi_id,&amp;fifocfg);

    DMA_Disable();
    DMA_IntMask(hw_arg-&gt;tx_dma_ch, DMA_INT_ALL, MASK);
    DMA_IntMask(hw_arg-&gt;tx_dma_ch, DMA_INT_TCOMPLETED, UNMASK);
    DMA_IntMask(hw_arg-&gt;tx_dma_ch, DMA_INT_ERR, UNMASK);

    DMA_IntMask(hw_arg-&gt;rx_dma_ch, DMA_INT_ALL, MASK);
    DMA_IntMask(hw_arg-&gt;rx_dma_ch, DMA_INT_TCOMPLETED, UNMASK); 
    DMA_IntMask(hw_arg-&gt;rx_dma_ch, DMA_INT_ERR, UNMASK);

    bl_irq_enable(DMA_ALL_IRQn);
    bl_dma_irq_register(hw_arg-&gt;tx_dma_ch, bl_spi0_dma_int_handler_tx, NULL, NULL);
    bl_dma_irq_register(hw_arg-&gt;rx_dma_ch, bl_spi0_dma_int_handler_rx, NULL, NULL);

    return;
}
</code></pre>
<h2 id="hal_spi_transfer-execute-spi-transfer" class="section-header"><a href="#hal_spi_transfer-execute-spi-transfer">17.7 hal_spi_transfer: Execute SPI Transfer</a></h2>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/components/hal_drv/bl602_hal/hal_spi.c#L482-L522"><code>bl602_hal/hal_spi.c</code></a></p>
<pre><code class="language-c">int hal_spi_transfer(spi_dev_t *spi_dev, void *xfer, uint8_t size)
{
    uint16_t i;
    spi_ioc_transfer_t * s_xfer;
    spi_priv_data_t *priv_data;

    if ((!spi_dev) || (!xfer)) {
        blog_error(&quot;arg err.\r\n&quot;);
        return -1;
    }

    priv_data = (spi_priv_data_t *)spi_dev-&gt;priv;
    if (priv_data == NULL) {
        blog_error(&quot;priv_data NULL.\r\n&quot;);
        return -1;
    }

    s_xfer = (spi_ioc_transfer_t *)xfer;

#if (HAL_SPI_DEBUG)
    blog_info(&quot;hal_spi_transfer = %d\r\n&quot;, size);
#endif

#if (0 == HAL_SPI_HARDCS)
    blog_info(&quot;Set CS pin %d to low\r\n&quot;, priv_data-&gt;hwspi[spi_dev-&gt;port].pin_cs);
    bl_gpio_output_set(priv_data-&gt;hwspi[spi_dev-&gt;port].pin_cs, 0);
#endif
    for (i = 0; i &lt; size; i++) {
#if (HAL_SPI_DEBUG)
        blog_info(&quot;transfer xfer[%d].len = %ld\r\n&quot;, i, s_xfer[i].len);
#endif
        hal_spi_dma_trans(&amp;priv_data-&gt;hwspi[spi_dev-&gt;port],
                (uint8_t *)s_xfer[i].tx_buf, (uint8_t *)s_xfer[i].rx_buf, s_xfer[i].len);
    }
#if (0 == HAL_SPI_HARDCS)
    bl_gpio_output_set(priv_data-&gt;hwspi[spi_dev-&gt;port].pin_cs, 1);
    blog_info(&quot;Set CS pin %d to high\r\n&quot;, priv_data-&gt;hwspi[spi_dev-&gt;port].pin_cs);
#endif

    return 0;
}
</code></pre>
<h2 id="hal_spi_dma_trans-execute-spi-transfer-with-dma" class="section-header"><a href="#hal_spi_dma_trans-execute-spi-transfer-with-dma">17.8 hal_spi_dma_trans: Execute SPI Transfer with DMA</a></h2>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/components/hal_drv/bl602_hal/hal_spi.c#L290-L358"><code>bl602_hal/hal_spi.c</code></a></p>
<pre><code class="language-c">static void hal_spi_dma_trans(spi_hw_t *arg, uint8_t *TxData, uint8_t *RxData, uint32_t Len)
{
    EventBits_t uxBits;
    DMA_LLI_Cfg_Type txllicfg;
    DMA_LLI_Cfg_Type rxllicfg;
    DMA_LLI_Ctrl_Type *ptxlli;
    DMA_LLI_Ctrl_Type *prxlli;
    int ret;

    if (!arg) {
        blog_error(&quot;arg err.\r\n&quot;);
        return;
    }

    txllicfg.dir = DMA_TRNS_M2P;
    txllicfg.srcPeriph = DMA_REQ_NONE; 
    txllicfg.dstPeriph = DMA_REQ_SPI_TX;

    rxllicfg.dir = DMA_TRNS_P2M;
    rxllicfg.srcPeriph = DMA_REQ_SPI_RX;
    rxllicfg.dstPeriph = DMA_REQ_NONE;


    xEventGroupClearBits(arg-&gt;spi_dma_event_group, EVT_GROUP_SPI_DMA_TR);

    DMA_Channel_Disable(arg-&gt;tx_dma_ch);
    DMA_Channel_Disable(arg-&gt;rx_dma_ch);
    bl_dma_int_clear(arg-&gt;tx_dma_ch);
    bl_dma_int_clear(arg-&gt;rx_dma_ch);
    DMA_Enable();

    if (arg-&gt;mode == 0) {
        SPI_Enable(arg-&gt;ssp_id, SPI_WORK_MODE_MASTER);
    } else {
        SPI_Enable(arg-&gt;ssp_id, SPI_WORK_MODE_SLAVE);
    }

    ret = lli_list_init(&amp;ptxlli, &amp;prxlli, TxData, RxData, Len);
    if (ret &lt; 0) {
        blog_error(&quot;init lli failed. \r\n&quot;);

        return;
    }

    DMA_LLI_Init(arg-&gt;tx_dma_ch, &amp;txllicfg);
    DMA_LLI_Init(arg-&gt;rx_dma_ch, &amp;rxllicfg);
    DMA_LLI_Update(arg-&gt;tx_dma_ch,(uint32_t)ptxlli);
    DMA_LLI_Update(arg-&gt;rx_dma_ch,(uint32_t)prxlli);
    DMA_Channel_Enable(arg-&gt;tx_dma_ch);
    DMA_Channel_Enable(arg-&gt;rx_dma_ch);

    ////  TODO: SPI Transfer may hang here, waiting for FreeRTOS Event Group 
    ////  if it isn't notified by DMA Interrupt Handler.  To troubleshoot,
    ////  comment out ALL lines below until end of function.
    ////  Also comment out the second bl_gpio_output_set in hal_spi_transfer.
    ////  And comment out the second bl_gpio_output_set in test_spi_transfer.
    uxBits = xEventGroupWaitBits(arg-&gt;spi_dma_event_group,
                                     EVT_GROUP_SPI_DMA_TR,
                                     pdTRUE,
                                     pdTRUE,
                                     portMAX_DELAY);

    if ((uxBits &amp; EVT_GROUP_SPI_DMA_TR) == EVT_GROUP_SPI_DMA_TR) {
        blog_info(&quot;recv all event group.\r\n&quot;);
    }

    vPortFree(ptxlli);
    vPortFree(prxlli);
}
</code></pre>
<h2 id="lli_list_init-init-dma-linked-list" class="section-header"><a href="#lli_list_init-init-dma-linked-list">17.9 lli_list_init: Init DMA Linked List</a></h2>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/components/hal_drv/bl602_hal/hal_spi.c#L126-L205"><code>bl602_hal/hal_spi.c</code></a></p>
<pre><code class="language-c">static int lli_list_init(DMA_LLI_Ctrl_Type **pptxlli, DMA_LLI_Ctrl_Type **pprxlli, uint8_t *ptx_data, uint8_t *prx_data, uint32_t length)
{
    uint32_t i = 0;
    uint32_t count;
    uint32_t remainder;
    struct DMA_Control_Reg dmactrl;


    count = length / LLI_BUFF_SIZE;
    remainder = length % LLI_BUFF_SIZE;

    if (remainder != 0) {
        count = count + 1;
    }

    dmactrl.SBSize = DMA_BURST_SIZE_1;
    dmactrl.DBSize = DMA_BURST_SIZE_1;
    dmactrl.SWidth = DMA_TRNS_WIDTH_8BITS;
    dmactrl.DWidth = DMA_TRNS_WIDTH_8BITS;
    dmactrl.Prot = 0;
    dmactrl.SLargerD = 0;

    *pptxlli = pvPortMalloc(sizeof(DMA_LLI_Ctrl_Type) * count);
    if (*pptxlli == NULL) {
        blog_error(&quot;malloc lli failed. \r\n&quot;);

        return -1;
    }

    *pprxlli = pvPortMalloc(sizeof(DMA_LLI_Ctrl_Type) * count);
    if (*pprxlli == NULL) {
        blog_error(&quot;malloc lli failed.&quot;);
        vPortFree(*pptxlli);

        return -1;
    }

    for (i = 0; i &lt; count; i++) {
        if (remainder == 0) {
            dmactrl.TransferSize = LLI_BUFF_SIZE;
        } else {
            if (i == count - 1) {
                dmactrl.TransferSize = remainder;
            } else {
                dmactrl.TransferSize = LLI_BUFF_SIZE;
            }
        }

        dmactrl.SI = DMA_MINC_ENABLE;
        dmactrl.DI = DMA_MINC_DISABLE;
            
        if (i == count - 1) {
            dmactrl.I = 1;
        } else {
            dmactrl.I = 0;
        }

        (*pptxlli)[i].srcDmaAddr = (uint32_t)(ptx_data + i * LLI_BUFF_SIZE);
        (*pptxlli)[i].destDmaAddr = (uint32_t)(SPI_BASE+SPI_FIFO_WDATA_OFFSET);
        (*pptxlli)[i].dmaCtrl = dmactrl;
        blog_info(&quot;Tx DMA src=0x%x, dest=0x%x, size=%d, si=%d, di=%d, i=%d\r\n&quot;, (unsigned) (*pptxlli)[i].srcDmaAddr, (unsigned) (*pptxlli)[i].destDmaAddr, dmactrl.TransferSize, dmactrl.SI, dmactrl.DI, dmactrl.I);

        dmactrl.SI = DMA_MINC_DISABLE;
        dmactrl.DI = DMA_MINC_ENABLE;
        (*pprxlli)[i].srcDmaAddr = (uint32_t)(SPI_BASE+SPI_FIFO_RDATA_OFFSET);
        (*pprxlli)[i].destDmaAddr = (uint32_t)(prx_data + i * LLI_BUFF_SIZE);
        (*pprxlli)[i].dmaCtrl = dmactrl;
        blog_info(&quot;Rx DMA src=0x%x, dest=0x%x, size=%d, si=%d, di=%d, i=%d\r\n&quot;, (unsigned) (*pprxlli)[i].srcDmaAddr, (unsigned) (*pprxlli)[i].destDmaAddr, dmactrl.TransferSize, dmactrl.SI, dmactrl.DI, dmactrl.I);

        if (i != 0) {
            (*pptxlli)[i-1].nextLLI = (uint32_t)&amp;(*pptxlli)[i];
            (*pprxlli)[i-1].nextLLI = (uint32_t)&amp;(*pprxlli)[i];
        }

        (*pptxlli)[i].nextLLI = 0;
        (*pprxlli)[i].nextLLI = 0;
    }

    return 0;
}
</code></pre>
<h2 id="bl_spi0_dma_int_handler_tx-transmit-dma-interrupt-handler" class="section-header"><a href="#bl_spi0_dma_int_handler_tx-transmit-dma-interrupt-handler">17.10 bl_spi0_dma_int_handler_tx: Transmit DMA Interrupt Handler</a></h2>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/components/hal_drv/bl602_hal/hal_spi.c#L769-L808"><code>bl602_hal/hal_spi.c</code></a></p>
<pre><code class="language-c">////  TODO: Interrupt Counters for Transmit and Receive
int g_tx_counter;
int g_rx_counter;

////  TODO: Status, Terminal Counts and Error Codes for Transmit and Receive
uint32_t g_tx_status;  //  Transmit Status (from 0x4000c000)
uint32_t g_tx_tc;      //  Transmit Terminal Count (from 0x4000c004)
uint32_t g_tx_error;   //  Transmit Error Code (from 0x4000c00c)
uint32_t g_rx_status;  //  Receive Status (from 0x4000c000)
uint32_t g_rx_tc;      //  Receive Terminal Count (0x4000c004)
uint32_t g_rx_error;   //  Receive Error Code (0x4000c00c)

void bl_spi0_dma_int_handler_tx(void)
{
    g_tx_counter++;  //  Increment the Transmit Interrupt Counter
    g_tx_status = *(uint32_t *) 0x4000c000;  //  Set the Transmit Status
    g_tx_tc     = *(uint32_t *) 0x4000c004;  //  Set the Transmit Terminal Count
    if (g_tx_error == 0) { g_tx_error = *(uint32_t *) 0x4000c00c; }  //  Set the Transmit Error Code

    BaseType_t xResult = pdFAIL;
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    if (NULL != g_hal_buf) {
        bl_dma_int_clear(g_hal_buf-&gt;hwspi[0].tx_dma_ch);

        if (g_hal_buf-&gt;hwspi[0].spi_dma_event_group != NULL) {
            xResult = xEventGroupSetBitsFromISR(g_hal_buf-&gt;hwspi[0].spi_dma_event_group,
                                                EVT_GROUP_SPI_DMA_TX,
                                                &amp;xHigherPriorityTaskWoken);
        }

        if(xResult != pdFAIL) {
            portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
        }
    } else {
        blog_error(&quot;bl_spi0_dma_int_handler_tx no clear isr.\r\n&quot;);
    }

    return;
}
</code></pre>
<h2 id="bl_spi0_dma_int_handler_rx-receive-dma-interrupt-handler" class="section-header"><a href="#bl_spi0_dma_int_handler_rx-receive-dma-interrupt-handler">17.11 bl_spi0_dma_int_handler_rx: Receive DMA Interrupt Handler</a></h2>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/spi/components/hal_drv/bl602_hal/hal_spi.c#L810-L836"><code>bl602_hal/hal_spi.c</code></a></p>
<pre><code class="language-c">void bl_spi0_dma_int_handler_rx(void)
{
    g_rx_counter++;  //  Increment the Receive Interrupt Counter
    g_rx_status = *(uint32_t *) 0x4000c000;  //  Set the Receive Status
    g_rx_tc     = *(uint32_t *) 0x4000c004;  //  Set the Receive Terminal Count
    if (g_rx_error == 0) { g_rx_error = *(uint32_t *) 0x4000c00c; }  //  Set the Receive Error Code

    BaseType_t xResult = pdFAIL;
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    if (NULL != g_hal_buf) {
        bl_dma_int_clear(g_hal_buf-&gt;hwspi[0].rx_dma_ch);

        if (g_hal_buf-&gt;hwspi[0].spi_dma_event_group != NULL) {
            xResult = xEventGroupSetBitsFromISR(g_hal_buf-&gt;hwspi[0].spi_dma_event_group,
                                                EVT_GROUP_SPI_DMA_RX,
                                                &amp;xHigherPriorityTaskWoken);
        }

        if(xResult != pdFAIL) {
            portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
        }
    } else {
        blog_error(&quot;bl_spi0_dma_int_handler_rx no clear isr.\r\n&quot;);
    }
    return;
}
</code></pre>

    
</body>
</html>