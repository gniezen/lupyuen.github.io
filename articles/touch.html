<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>NuttX Touch Panel Driver for PineDio Stack BL604</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="NuttX Touch Panel Driver for PineDio Stack BL604" 
    data-rh="true">
<meta property="og:description" 
    content="How we created a Apache NuttX RTOS Driver for Hynitron CST816S I2C Touch Panel... For PineDio Stack BL604 RISC-V Board"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/touch-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">NuttX Touch Panel Driver for PineDio Stack BL604</h1>
    <nav id="TOC"><ul>
<li><a href="#cst816s-touch-panel">1 CST816S Touch Panel</a><ul>
<li><a href="#cst816s-pins">1.1 CST816S Pins</a><ul></ul></li></ul></li>
<li><a href="#nuttx-touchscreen-drivers">2 NuttX Touchscreen Drivers</a><ul>
<li><a href="#touch-data">2.1 Touch Data</a><ul></ul></li>
<li><a href="#read-touch-data">2.2 Read Touch Data</a><ul></ul></li></ul></li>
<li><a href="#load-the-driver">3 Load The Driver</a><ul></ul></li>
<li><a href="#initialise-driver">4 Initialise Driver</a><ul></ul></li>
<li><a href="#gpio-interrupt">5 GPIO Interrupt</a><ul>
<li><a href="#test-gpio-interrupt">5.1 Test GPIO Interrupt</a><ul></ul></li></ul></li>
<li><a href="#fetch-touch-data">6 Fetch Touch Data</a><ul>
<li><a href="#get-i2c-touch-data">6.1 Get I2C Touch Data</a><ul></ul></li>
<li><a href="#is-data-ready">6.2 Is Data Ready?</a><ul></ul></li></ul></li>
<li><a href="#run-the-driver">7 Run The Driver</a><ul>
<li><a href="#read-touch-data-1">7.1 Read Touch Data</a><ul></ul></li>
<li><a href="#trigger-gpio-interrupt">7.2 Trigger GPIO Interrupt</a><ul></ul></li>
<li><a href="#touch-down-event">7.3 Touch Down Event</a><ul></ul></li>
<li><a href="#touch-down-event-again">7.4 Touch Down Event Again</a><ul></ul></li>
<li><a href="#touch-up-event">7.5 Touch Up Event</a><ul></ul></li>
<li><a href="#screen-calibration-result">7.6 Screen Calibration Result</a><ul></ul></li></ul></li>
<li><a href="#screen-is-sideways">8 Screen Is Sideways</a><ul></ul></li>
<li><a href="#i2c-quirks">9 I2C Quirks</a><ul>
<li><a href="#i2c-sub-address">9.1 I2C Sub Address</a><ul></ul></li>
<li><a href="#i2c-logging">9.2 I2C Logging</a><ul></ul></li></ul></li>
<li><a href="#whats-next">10 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">11 Notes</a><ul></ul></li>
<li><a href="#appendix-install-driver">12 Appendix: Install Driver</a><ul></ul></li>
<li><a href="#appendix-gpio-interrupt">13 Appendix: GPIO Interrupt</a><ul></ul></li></ul></nav><p>üìù <em>24 Apr 2022</em></p>
<p><img src="https://lupyuen.github.io/images/touch-title.jpg" alt="Touch Panel Calibration for Pine64 PineDio Stack BL604 RISC-V Board" /></p>
<p><em>Touch Panel Calibration for Pine64 PineDio Stack BL604 RISC-V Board</em></p>
<p><a href="https://lupyuen.github.io/articles/pinedio2"><strong>PineDio Stack BL604</strong></a> is Pine64‚Äôs newest microcontroller board, based on <a href="https://lupyuen.github.io/articles/pinecone"><strong>Bouffalo Lab‚Äôs BL604</strong></a> RISC-V + WiFi + Bluetooth LE SoC.</p>
<p>(Available any day now!)</p>
<p>PineDio Stack is packed <strong>chock-full of features</strong>‚Ä¶</p>
<ul>
<li>
<p>ST7789 <strong>Colour LCD Display</strong></p>
<p>(240 x 240 pixels)</p>
</li>
<li>
<p>CST816S <strong>Touch Panel</strong></p>
<p>(Connected on I2C)</p>
</li>
<li>
<p>Semtech SX1262 <strong>LoRa Transceiver</strong></p>
<p>(Works with LoRaWAN wireless networks)</p>
</li>
<li>
<p>AT6558 <strong>GPS / GNSS Receiver</strong></p>
</li>
<li>
<p>SGM40561 <strong>Power Management Unit</strong></p>
</li>
<li>
<p><strong>Heart Rate Sensor, Accelerometer, Compass, Vibrator</strong></p>
</li>
<li>
<p><strong>SPI Flash, JTAG Debugging Port, Push Button</strong></p>
</li>
<li>
<p><strong>2.4 GHz WiFi, Bluetooth LE</strong></p>
<p>(Thanks to BL604)</p>
</li>
</ul>
<p>Which makes it an awesome gadget for <strong>IoT Education</strong>!</p>
<ul>
<li><a href="https://www.youtube.com/shorts/2Nzjrlp5lcE"><strong>Watch the demo on YouTube</strong></a></li>
</ul>
<p>Today we‚Äôll talk about the <strong>Hynitron CST816S Touch Panel Driver</strong> for Apache NuttX RTOS‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/cst816s-nuttx"><strong>lupyuen/cst816s-nuttx</strong></a></li>
</ul>
<p>Which was inspired by JF‚Äôs CST816S Driver for PineDio Stack‚Ä¶ (Thanks JF!)</p>
<ul>
<li><a href="https://codeberg.org/JF002/pinedio-stack-selftest/src/branch/master/drivers/cst816s.c"><strong>pinedio-stack-selftest/drivers/cst816s.c</strong></a></li>
</ul>
<p>Let‚Äôs go inside the driver‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/touch-inside.jpg" alt="Touch Panel is connected in the middle, between the connectors for the Heart Rate Sensor (bottom left) and ST7789 Display (top left)" /></p>
</blockquote>
<blockquote>
<p><em>Touch Panel is connected in the middle, between the connectors for the Heart Rate Sensor (bottom left) and ST7789 Display (top left)</em></p>
</blockquote>
<h1 id="cst816s-touch-panel"><a href="#cst816s-touch-panel">1 CST816S Touch Panel</a></h1>
<p><em>What is CST816S? Where is it used?</em></p>
<p>Inside PineDio Stack is <strong>CST816S</strong>, an <strong>I2C Capacitive Touch Panel</strong> by Hynitron‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinedio-stack-nuttx/blob/main/CST816S_DS_V1.3.pdf"><strong>Hynitron CST816S Datasheet</strong></a></li>
</ul>
<p>We don‚Äôt have the detailed docs for CST816S, but we have a <strong>Reference Driver</strong> for the Touch Panel‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/hynitron_i2c_cst0xxse"><strong>Hynitron Reference Driver</strong></a></li>
</ul>
<p>This is the same Touch Panel used in Pine64‚Äôs <strong>PineTime Smartwatch</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/building-a-rust-driver-for-pinetimes-touch-controller"><strong>‚ÄúBuilding a Rust Driver for PineTime‚Äôs Touch Controller‚Äù</strong></a></li>
</ul>
<p>Which explains why we have so many drivers available for CST816S: <a href="https://www.arduino.cc/reference/en/libraries/cst816s/"><strong>Arduino</strong></a>,  <a href="https://github.com/InfiniTimeOrg/InfiniTime/blob/develop/src/drivers/Cst816s.cpp"><strong>FreeRTOS</strong></a>, <a href="https://doc.riot-os.org/group__drivers__cst816s.html"><strong>RIOT OS</strong></a>, <a href="https://github.com/tstellanova/cst816s"><strong>Rust</strong></a>, <a href="https://najnesnaj.github.io/pinetime-zephyr/drivers/cst816s.html"><strong>Zephyr OS</strong></a>, ‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/touch-sleep.png" alt="CST816S Operating Modes" /></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/lupyuen/pinedio-stack-nuttx/blob/main/CST816S_DS_V1.3.pdf">(From CST816S Datasheet)</a></p>
</blockquote>
<p><em>So it works like any other I2C Device?</em></p>
<p>CST816S is a peculiar I2C Device‚Ä¶ It won‚Äôt respond to I2C Commands unless we <strong>tap the screen and wake it up</strong>!</p>
<p>That‚Äôs because it tries to conserve power: It powers off the I2C Interface when it‚Äôs not in use. (Pic above)</p>
<p>So be careful when scanning for CST816S at its <strong>I2C Address <code>0x15</code></strong>. It might seem elusive until we tap the screen.</p>
<p>The I2C Address of CST816S is defined in <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L102-L107">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_INPUT_CST816S
/* I2C Address of CST816S Touch Controller */
#define CST816S_DEVICE_ADDRESS 0x15
#include &lt;nuttx/input/cst816s.h&gt;
#endif /* CONFIG_INPUT_CST816S */</code></pre></div>
<blockquote>
<p><img src="https://lupyuen.github.io/images/pinedio2-touch.png" alt="PineDio Stack Touch Panel" /></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/lupyuen/pinedio-stack-nuttx/blob/main/pinedio_stack_v1_0-2021_09_15-a.pdf">(From PineDio Stack Schematic)</a></p>
</blockquote>
<h2 id="cst816s-pins"><a href="#cst816s-pins">1.1 CST816S Pins</a></h2>
<p><em>How is CST816S wired to PineDio Stack?</em></p>
<p>According to the schematic above, CST816S is wired to PineDio Stack like so‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">BL604 Pin</th><th style="text-align: left">CST816S Pin</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>GPIO 1</code></strong></td><td style="text-align: left"><code>SDA</code></td></tr>
<tr><td style="text-align: center"><strong><code>GPIO 2</code></strong></td><td style="text-align: left"><code>SCL</code></td></tr>
<tr><td style="text-align: center"><strong><code>GPIO 9</code></strong></td><td style="text-align: left"><code>Interrupt</code></td></tr>
<tr><td style="text-align: center"><strong><code>GPIO 18</code></strong></td><td style="text-align: left"><code>Reset</code></td></tr>
</tbody></table>
</div>
<p>(We won‚Äôt use the <strong>Reset</strong> pin in our driver)</p>
<p>The <strong>CST816S Pins</strong> are defined in <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L92-L131">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* I2C Configuration */
#define BOARD_I2C_SCL (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | GPIO_PIN2)
#define BOARD_I2C_SDA (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | GPIO_PIN1)
...
#ifdef CONFIG_INPUT_CST816S
/* CST816S Touch Controller for PineDio Stack: GPIO Interrupt */
#define BOARD_TOUCH_INT (GPIO_INPUT | GPIO_FLOAT | GPIO_FUNC_SWGPIO | GPIO_PIN9)
#endif  /* CONFIG_INPUT_CST816S */</code></pre></div>
<p><em>What‚Äôs the Interrupt Pin?</em></p>
<p>When we touch the screen, CST816S triggers a <strong>GPIO Interrupt</strong> and activates the I2C Interface (for a short while).</p>
<p>Note that CST816S <strong>doesn‚Äôt trigger an interrupt</strong> when the screen is <strong>no longer touched</strong>.</p>
<p>We‚Äôll handle this in our CST816S Driver.</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/touch-device.png" alt="NuttX Touchscreen Device" /></p>
</blockquote>
<h1 id="nuttx-touchscreen-drivers"><a href="#nuttx-touchscreen-drivers">2 NuttX Touchscreen Drivers</a></h1>
<p><em>How do Touchscreen Drivers work on NuttX?</em></p>
<ul>
<li>
<p>At NuttX Startup, Touchscreen Drivers register themselves as ‚Äú<strong>/dev/input0</strong>‚Äù</p>
<p>(Pic above)</p>
</li>
<li>
<p>NuttX Apps will open ‚Äú<strong>/dev/input0</strong>‚Äù and call <strong><code>read()</code></strong> to fetch <strong>Touch Data Samples</strong> from the driver</p>
<p>(More about this in the next section)</p>
</li>
<li>
<p>NuttX Apps may call <strong><code>poll()</code></strong> to wait for available data</p>
<p>(Which blocks on a NuttX Semaphore until the data is available)</p>
</li>
</ul>
<p>Touchscreen Drivers are documented here‚Ä¶</p>
<ul>
<li><a href="https://nuttx.apache.org/docs/latest/components/drivers/character/touchscreen.html"><strong>NuttX Touchscreen Drivers</strong></a></li>
</ul>
<p>We learnt more by inspecting these Touchscreen Drivers‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/drivers/input/cypress_mbr3108.c"><strong>NuttX I2C Driver for Cypress MBR3108</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/drivers/input/max11802.c"><strong>NuttX SPI Driver for Maxim MAX11802</strong></a></p>
</li>
</ul>
<p>The MBR3108 Driver looks structurally similar to our CST816S Driver (since both are I2C). So we copied the code as we built our CST816S Driver.</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/drivers/input/max11802.c#L824-L952">(We copied the MAX11802 Driver for reading Touch Data Samples)</a></p>
<p>Let‚Äôs talk about the data format‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch-code3a.png" alt="NuttX Touch Data" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/include/nuttx/input/touchscreen.h#L113-L148">(Source)</a></p>
<h2 id="touch-data"><a href="#touch-data">2.1 Touch Data</a></h2>
<p><em>How are Touch Data Samples represented in NuttX?</em></p>
<p>NuttX defines a standard data format for <strong>Touch Data Samples</strong> that are returned by Touchscreen Drivers‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* The typical touchscreen driver is a read-only, input character device
 * driver.the driver write() method is not supported and any attempt to
 * open the driver in any mode other than read-only will fail.
 *
 * Data read from the touchscreen device consists only of touch events and
 * touch sample data.  This is reflected by struct touch_sample_s.  This
 * structure is returned by either the driver read method.
 *
 * On some devices, multiple touchpoints may be supported. So this top level
 * data structure is a struct touch_sample_s that &quot;contains&quot; a set of touch
 * points.  Each touch point is managed individually using an ID that
 * identifies a touch from first contact until the end of the contact.
 */
struct touch_sample_s
{
  int npoints;                   /* The number of touch points in point[] */
  struct touch_point_s point[1]; /* Actual dimension is npoints */
};</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/include/nuttx/input/touchscreen.h#L130-L148">(Source)</a></p>
<p>For our driver, we‚Äôll return only <strong>one Touch Point</strong>.</p>
<p>Here‚Äôs the NuttX Definition of a <strong>Touch Point</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* This structure contains information about a single touch point.
 * Positional units are device specific.
 */
struct touch_point_s
{
  uint8_t  id;        /* Unique identifies contact; Same in all reports for the contact */
  uint8_t  flags;     /* See TOUCH_* definitions above */
  int16_t  x;         /* X coordinate of the touch point (uncalibrated) */
  int16_t  y;         /* Y coordinate of the touch point (uncalibrated) */
  int16_t  h;         /* Height of touch point (uncalibrated) */
  int16_t  w;         /* Width of touch point (uncalibrated) */
  uint16_t gesture;   /* Gesture of touchscreen contact */
  uint16_t pressure;  /* Touch pressure */
  uint64_t timestamp; /* Touch event time stamp, in microseconds */
};</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/include/nuttx/input/touchscreen.h#L109-L128">(Source)</a></p>
<p>Our driver returns the first 4 fields‚Ä¶</p>
<ul>
<li>
<p><strong>id</strong>: Always 0, since we detect one Touch Point</p>
</li>
<li>
<p><strong>flags</strong>: We return a combination of these flags‚Ä¶</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/include/nuttx/input/touchscreen.h#L94"><strong>TOUCH_ID_VALID</strong></a>: Touch Point ID is always valid</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/include/nuttx/input/touchscreen.h#L91"><strong>TOUCH_DOWN</strong></a> or <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/include/nuttx/input/touchscreen.h#L93"><strong>TOUCH_UP</strong></a>: Touch Down or Up</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/include/nuttx/input/touchscreen.h#L95"><strong>TOUCH_POS_VALID</strong></a>: If Touch Coordinates are valid</p>
<p>(Touch Coordinates are valid for Touch Down, not Touch Up)</p>
</li>
<li>
<p><strong>x</strong>: X Coordinate of the Touch Point (0 to 239)</p>
</li>
<li>
<p><strong>y</strong>: Y Coordinate of the Touch Point (0 to 239)</p>
</li>
</ul>
<p>And sets the remaining fields to 0.</p>
<p><em>What about Touch Gestures? Like swiping and scrolling?</em></p>
<p><strong>Touch Gestures</strong> are supported in the CST816S Driver for PineTime InfiniTime. <a href="https://github.com/InfiniTimeOrg/InfiniTime/blob/develop/src/drivers/Cst816s.cpp#L80-L94">(See this)</a></p>
<p>Someday we might support Touch Gestures in our NuttX Driver.</p>
<h2 id="read-touch-data"><a href="#read-touch-data">2.2 Read Touch Data</a></h2>
<p>NuttX Apps will open ‚Äú<strong>/dev/input0</strong>‚Äù and call <strong><code>read()</code></strong> repeatedly to fetch <strong>Touch Data Samples</strong> from the driver‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Open &quot;/dev/input0&quot;
int fd = open(&quot;/dev/input0&quot;, O_RDONLY | O_NONBLOCK);

//  Read one sample
struct touch_sample_s sample;
int nbytes = read(fd, &amp;sample, sizeof(struct touch_sample_s));</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/tp.c#L62-L132">(Source)</a></p>
<p>This populates a <strong>touch_sample_s</strong> struct, which we‚Äôve seen earlier.</p>
<p>The code above comes from the <a href="https://github.com/lupyuen/lvgltest-nuttx"><strong>LVGL Test App</strong></a>, which we‚Äôll run later to test our driver.</p>
<p>(Calling <strong><code>read()</code></strong> repeatedly might be bad for performance, instead we should call <strong><code>poll()</code></strong> to block until touch data is available)</p>
<h1 id="load-the-driver"><a href="#load-the-driver">3 Load The Driver</a></h1>
<p>Before we cover the internals of our driver, let‚Äôs <strong>load the CST816S Driver</strong> at NuttX Startup: <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L829-L846">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_INPUT_CST816S
//  I2C Address of CST816S Touch Controller
#define CST816S_DEVICE_ADDRESS 0x15
#include &lt;nuttx/input/cst816s.h&gt;
#endif  //  CONFIG_INPUT_CST816S
...
#ifdef CONFIG_INPUT_CST816S
int bl602_bringup(void) {
  ...
  //  Init I2C bus for CST816S
  struct i2c_master_s *cst816s_i2c_bus = bl602_i2cbus_initialize(0);
  if (!cst816s_i2c_bus) {
    _err(&quot;ERROR: Failed to get I2C%d interface\n&quot;, 0);
  }

  //  Register the CST816S driver
  ret = cst816s_register(
    &quot;/dev/input0&quot;,          //  Device Path
    cst816s_i2c_bus,        //  I2C Bus
    CST816S_DEVICE_ADDRESS  //  I2C Address
  );
  if (ret &lt; 0) {
    _err(&quot;ERROR: Failed to register CST816S\n&quot;);
  }
#endif  //  CONFIG_INPUT_CST816S</code></pre></div>
<p>This initialises our CST816S Driver and registers it at ‚Äú<strong>/dev/input0</strong>‚Äù.</p>
<p><strong>cst816s_register</strong> comes from our CST816S Driver, let‚Äôs dive in‚Ä¶</p>
<h1 id="initialise-driver"><a href="#initialise-driver">4 Initialise Driver</a></h1>
<p>At NuttX Startup, we call <strong>cst816s_register</strong> to initialise our CST816S Driver. The function is defined below: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L638-L706">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Initialise the CST816S Driver
int cst816s_register(FAR const char *devpath, FAR struct i2c_master_s *i2c_dev, uint8_t i2c_devaddr) {

  //  Allocate the Device Struct
  struct cst816s_dev_s *priv = kmm_zalloc(
    sizeof(struct cst816s_dev_s)
  );
  if (!priv) {
    ierr(&quot;Memory allocation failed\n&quot;);
    return -ENOMEM;
  }</code></pre></div>
<p>We begin by allocating the <strong>Device Struct</strong> that will remember the state of our driver.</p>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L73-L90">(Device Struct <strong>cst816s_dev_s</strong> is defined here)</a></p>
<p>We populate the Device Struct and initialise the <strong>Poll Semaphore</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Init the Device Struct
  priv-&gt;addr = i2c_devaddr;  //  I2C Address
  priv-&gt;i2c  = i2c_dev;      //  I2C Bus

  //  Init the Poll Semaphore
  nxsem_init(&amp;priv-&gt;devsem, 0, 1);</code></pre></div>
<p>(Which will be used for blocking callers to <strong><code>poll()</code></strong>)</p>
<p>Next we <strong>register the driver</strong> with NuttX at ‚Äú<strong>/dev/input0</strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Register the driver at &quot;/dev/input0&quot;
  int ret = register_driver(
    devpath,             //  Device Path
    &amp;g_cst816s_fileops,  //  File Operations
    0666,                //  Permissions
    priv                 //  Device Struct
  );
  if (ret &lt; 0) {
    kmm_free(priv);
    ierr(&quot;Driver registration failed\n&quot;);
    return ret;
  }</code></pre></div>
<p>(We‚Äôll see <strong>g_cst816s_fileops</strong> later)</p>
<p>Remember that CST816S will trigger <strong>GPIO Interrupts</strong> when we touch the screen.</p>
<p>We attach our <strong>Interrupt Handler</strong> that will handle the GPIO Interrupts‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Attach our GPIO Interrupt Handler
  ret = bl602_irq_attach(
    BOARD_TOUCH_INT,      //  GPIO 9
    cst816s_isr_handler,  //  Interrupt Handler
    priv                  //  Device Struct
  );
  if (ret &lt; 0) {
    kmm_free(priv);
    ierr(&quot;Attach interrupt failed\n&quot;);
    return ret;
  }</code></pre></div>
<p>(We‚Äôll see <strong>bl602_irq_attach</strong> in the next section)</p>
<p><a href="https://lupyuen.github.io/articles/touch#cst816s-pins">(We‚Äôve seen <strong>BOARD_TOUCH_INT</strong> earlier)</a></p>
<p>At startup we normally <strong>disable the GPIO Interrupt</strong> and enable it later at <strong><code>open()</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Disable the GPIO Interrupt
  ret = bl602_irq_enable(false);
  if (ret &lt; 0) {
    kmm_free(priv);
    ierr(&quot;Disable interrupt failed\n&quot;);
    return ret;
  }
  iinfo(&quot;Driver registered\n&quot;);</code></pre></div>
<p>(We‚Äôll see <strong>bl602_irq_enable</strong> in the next section)</p>
<p>For our testing, we <strong>enable the GPIO Interrupt</strong> at startup‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  For Testing: Enable the GPIO Interrupt at startup
#define TEST_CST816S_INTERRUPT
#ifdef TEST_CST816S_INTERRUPT
  bl602_irq_enable(true);
#endif  //  TEST_CST816S_INTERRUPT

  return 0;
}</code></pre></div>
<p>And that‚Äôs how we initialise our CST816S Driver at startup!</p>
<p><em>What‚Äôs g_cst816s_fileops?</em></p>
<p><strong>g_cst816s_fileops</strong> defines the <strong>NuttX File Operations</strong> <em>(open, close, read, poll)</em> that will be supported by our driver: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L109-L123">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  File Operations exposed to NuttX Apps
static const struct file_operations g_cst816s_fileops = {
  cst816s_open,   //  open
  cst816s_close,  //  close
  cst816s_read,   //  read
  NULL,           //  write
  NULL,           //  seek
  NULL,           //  ioctl
  cst816s_poll    //  poll
#ifndef CONFIG_DISABLE_PSEUDOFS_OPERATIONS
  , NULL          //  unlink
#endif
};</code></pre></div>
<p>We‚Äôll see the File Operations in a while.</p>
<p><img src="https://lupyuen.github.io/images/touch-code2a.png" alt="Initialise the CST816S Driver at startup" /></p>
<h1 id="gpio-interrupt"><a href="#gpio-interrupt">5 GPIO Interrupt</a></h1>
<p>CST816S will trigger <strong>GPIO Interrupts</strong> when we touch the screen.</p>
<p>Earlier we called these functions at startup to handle GPIO Interrupts‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/touch#appendix-gpio-interrupt"><strong>bl602_irq_attach</strong></a>: Attach our GPIO Interrupt Handler</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/touch#appendix-gpio-interrupt"><strong>bl602_irq_enable</strong></a>: Enable GPIO Interrupt</p>
</li>
</ul>
<p><a href="https://lupyuen.github.io/articles/touch#appendix-gpio-interrupt">(More about the functions in the Appendix)</a></p>
<p><em>What happens when a GPIO Interrupt is triggered on touch?</em></p>
<p>Our <strong>GPIO Interrupt Handler</strong> does the following‚Ä¶</p>
<ul>
<li>
<p>Set the <strong>Pending Flag</strong> to true</p>
<p>(We‚Äôll see why in a while)</p>
</li>
<li>
<p>Notify all callers to <strong><code>poll()</code></strong> that the Touch Data is ready</p>
<p>(So they will be unblocked and can proceed to read the data)</p>
</li>
</ul>
<p>Below is <strong>cst816s_isr_handler</strong>, our GPIO Interrupt Handler: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L611-L632">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Handle GPIO Interrupt triggered by touch
static int cst816s_isr_handler(int _irq, FAR void *_context, FAR void *arg) {
  //  Get the Device Struct from the handler argument
  FAR struct cst816s_dev_s *priv = (FAR struct cst816s_dev_s *) arg;

  //  Enter a Critical Section
  irqstate_t flags = enter_critical_section();

  //  Set the Pending Flag to true
  priv-&gt;int_pending = true;

  //  Leave the Critical Section
  leave_critical_section(flags);

  //  Notify all poll() callers that data is ready
  cst816s_poll_notify(priv);
  return 0;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L493-L519">(<strong>cst816s_poll_notify</strong> is defined here)</a></p>
<p>We use a <strong>Critical Section</strong> to protect the Pending Flag from being modified by multiple threads.</p>
<h2 id="test-gpio-interrupt"><a href="#test-gpio-interrupt">5.1 Test GPIO Interrupt</a></h2>
<p><em>Our GPIO Interrupt Handler‚Ä¶ Does it really work?</em></p>
<p>Let‚Äôs test it! Follow these steps to <strong>build, flash and run NuttX</strong> on PineDio Stack (with CST816S logging enabled)‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#build-nuttx"><strong>‚ÄúBuild NuttX‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#appendix-nuttx-logging"><strong>‚ÄúNuttX Logging‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#flash-pinedio-stack"><strong>‚ÄúFlash PineDio Stack‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#boot-pinedio-stack"><strong>‚ÄúBoot PineDio Stack‚Äù</strong></a></p>
</li>
</ul>
<p>In the NuttX Shell, enter this command to <strong>list all devices</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>ls /dev</code></pre></div>
<p>We should see our CST816S Driver loaded at ‚Äú<strong>/dev/input0</strong>‚Äù‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/touch-device.png" alt="NuttX Touchscreen Device" /></p>
</blockquote>
<p>Tap the screen on PineDio Stack. We should see the <strong>GPIO Interrupt</strong> handled by our driver‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_expander_interrupt: Interrupt! callback=0x2305e9de, arg=0x42020a60
bl602_expander_interrupt: Call callback=0x2305e9de, arg=0x42020a60
cst816s_poll_notify:</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx#test-gpio-interrupt">(See the Complete Log)</a></p>
<p>Yep our CST816S Driver correctly handles the GPIO Interrupt!</p>
<p><img src="https://lupyuen.github.io/images/touch-run1a.png" alt="GPIO Interrupt" /></p>
<h1 id="fetch-touch-data"><a href="#fetch-touch-data">6 Fetch Touch Data</a></h1>
<p>We‚Äôve handled the GPIO Interrupt, now comes the exciting part of our CST816S Driver‚Ä¶ Fetching the <strong>Touch Data over I2C</strong>!</p>
<p><em>Why bother with GPIO Interrupts anyway? Can‚Äôt we read the data directly over I2C?</em></p>
<p>Ah but the Touch Panel <strong>won‚Äôt respond to I2C Commands</strong> until the screen is tapped! (Which triggers the GPIO Interrupt)</p>
<p>That‚Äôs why we need to <strong>monitor for GPIO Interrupts</strong> (via the Pending Flag) and determine whether the Touch Panel‚Äôs I2C Interface is active.</p>
<p><em>What can we read from CST816S over I2C?</em></p>
<p>Here‚Äôs the Touch Data that we can read from <strong>I2C Registers <code>0x02</code> to <code>0x06</code></strong> on CST816S‚Ä¶</p>
<ul>
<li>
<p><strong>Touch Points:</strong> Number of Touch Points (always 1)</p>
<p>(Bits 0-3 of Register <code>0x02</code>)</p>
</li>
<li>
<p><strong>Touch Event:</strong> <code>0</code> = Touch Down, <code>1</code> = Touch Up, <code>2</code> = Contact</p>
<p>(Bits 6-7 of Register <code>0x03</code>)</p>
</li>
<li>
<p><strong>X Coordinate:</strong> 0 to 239</p>
<p>(High Byte: Bits 0-3 of Register <code>0x03</code>)</p>
<p>(Low Byte: Bits 0-7 of Register <code>0x04</code>)</p>
</li>
<li>
<p><strong>Y Coordinate:</strong> 0 to 239</p>
<p>(High Byte: Bits 0-3 of Register <code>0x05</code>)</p>
<p>(Low Byte: Bits 0-7 of Register <code>0x06</code>)</p>
</li>
<li>
<p><strong>Touch ID:</strong> Identifies the Touch Point (always 0)</p>
<p>(Bits 4-7 of Register <code>0x05</code>)</p>
</li>
</ul>
<p><a href="https://github.com/lupyuen/hynitron_i2c_cst0xxse/blob/master/cst0xx_core.c#L407-L466">(Derived from Hynitron‚Äôs Reference Driver)</a></p>
<p><strong>Touch Gestures</strong> (like swiping and scrolling) might also be supported, according to the CST816S Driver for PineTime InfiniTime. <a href="https://github.com/InfiniTimeOrg/InfiniTime/blob/develop/src/drivers/Cst816s.cpp#L80-L94">(See this)</a></p>
<p><em>Any gotchas for the Touch Data?</em></p>
<p>If the Touch Event is <strong><code>0</code> (Touch Down)</strong>, all Touch Data is hunky dory.</p>
<p>But if the Touch Event is <strong><code>1</code> (Touch Up)</strong>, all the other fields are <strong>invalid</strong>!</p>
<p>Our driver fixes this by remembering and returning the <strong>last valid Touch Data</strong>.</p>
<p><em>What about Touch Event <code>2</code> (Contact)?</em></p>
<p>We haven‚Äôt seen this during our testing. Thus our driver ignores the event.</p>
<p>Let‚Äôs check out our driver code‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch-code4a.png" alt="Getting I2C Touch Data" /></p>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L213-L302">(Source)</a></p>
<h2 id="get-i2c-touch-data"><a href="#get-i2c-touch-data">6.1 Get I2C Touch Data</a></h2>
<p>This is how we read the <strong>Touch Data over I2C</strong> in our driver: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L213-L302">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Read I2C Register 0x00 onwards
#define CST816S_REG_TOUCHDATA 0x00

//  Read Touch Data over I2C
static int cst816s_get_touch_data(FAR struct cst816s_dev_s *dev, FAR void *buf) {

  //  Read the Raw Touch Data over I2C
  uint8_t readbuf[7];
  int ret = cst816s_i2c_read(
    dev,                    //  Device Struct
    CST816S_REG_TOUCHDATA,  //  Read I2C Register 0x00 onwards
    readbuf,                //  Buffer for Touch Data
    sizeof(readbuf)         //  Read 7 bytes
  );
  if (ret &lt; 0) {
    iinfo(&quot;Read touch data failed\n&quot;);
    return ret;
  }</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L136-L220">(<strong>cst816s_i2c_read</strong> is defined here)</a></p>
<p>The function begins by reading <strong>I2C Registers <code>0x00</code> to <code>0x06</code></strong>.</p>
<p>Then it <strong>decodes the Touch Data</strong> (as described in the last section)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Interpret the Raw Touch Data
  uint8_t id = readbuf[5] &gt;&gt; 4;
  uint8_t touchpoints = readbuf[2] &amp; 0x0f;
  uint8_t xhigh = readbuf[3] &amp; 0x0f;
  uint8_t xlow  = readbuf[4];
  uint8_t yhigh = readbuf[5] &amp; 0x0f;
  uint8_t ylow  = readbuf[6];
  uint8_t event = readbuf[3] &gt;&gt; 6;  //  0 = Touch Down, 1 = Touch Up, 2 = Contact */
  uint16_t x  = (xhigh &lt;&lt; 8) | xlow;
  uint16_t y  = (yhigh &lt;&lt; 8) | ylow;</code></pre></div>
<p>For <strong>Touch Up Events</strong>: The Touch Coordinates are invalid, so we substitute the data from the <strong>last Touch Down Event</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  If touch coordinates are invalid,
  //  return the last valid coordinates
  bool valid = true;
  if (x &gt;= 240 || y &gt;= 240) {
    //  Quit if we have no last valid coordinates
    if (last_event == 0xff) { return -EINVAL; }

    //  Otherwise substitute the last valid coordinates
    valid = false;
    id = last_id;
    x  = last_x;
    y  = last_y;
  }</code></pre></div>
<p>We remember the <strong>Touch Event</strong> and the Touch Data‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Remember the last valid touch data
  last_event = event;
  last_id    = id;
  last_x     = x;
  last_y     = y;</code></pre></div>
<p>NuttX expects the Touch Data to be returned as a <strong>touch_sample_s</strong> struct. <a href="https://lupyuen.github.io/articles/touch#touch-data">(See this)</a></p>
<p>We <strong>assign the Touch Data</strong> to the struct‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Set the Touch Data fields
  struct touch_sample_s data;
  memset(&amp;data, 0, sizeof(data));
  data.npoints     = 1;   //  Number of Touch Points
  data.point[0].id = id;  //  Touch ID
  data.point[0].x  = x;   //  X Coordinate
  data.point[0].y  = y;   //  Y Coordinate</code></pre></div>
<p>Now we tell NuttX whether it‚Äôs a <strong>Touch Down Event</strong> (with valid or invalid coordinates)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Set the Touch Flags for...
  //  Touch Down Event
  if (event == 0) {
    if (valid) {
      //  Touch coordinates were valid
      data.point[0].flags  = TOUCH_DOWN | TOUCH_ID_VALID | TOUCH_POS_VALID;
    } else {
      //  Touch coordinates were invalid
      data.point[0].flags  = TOUCH_DOWN | TOUCH_ID_VALID;
    }</code></pre></div>
<p>Or a <strong>Touch Up Event</strong> (with valid or invalid coordinates)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Touch Up Event
  } else if (event == 1) {
    if (valid) {
      //  Touch coordinates were valid
      data.point[0].flags  = TOUCH_UP | TOUCH_ID_VALID | TOUCH_POS_VALID;
    } else {
      //  Touch coordinates were invalid
      data.point[0].flags  = TOUCH_UP | TOUCH_ID_VALID;
    }</code></pre></div>
<p>We ignore all <strong>Contact Events</strong> (because we‚Äôve never seen one)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Reject Contact Event
  } else {
    return -EINVAL;
  }</code></pre></div>
<p>Finally we <strong>return the struct</strong> to the caller‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Return the touch data
  memcpy(buf, &amp;data, sizeof(data));
  return sizeof(data);
}</code></pre></div>
<p>That‚Äôs how we read and decode the Touch Data from CST816S over I2C!</p>
<p><img src="https://lupyuen.github.io/images/touch-code5a.png" alt="Returning I2C Touch Data" /></p>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L213-L302">(Source)</a></p>
<h2 id="is-data-ready"><a href="#is-data-ready">6.2 Is Data Ready?</a></h2>
<p><em>Who calls cst816s_get_touch_data to fetch the Touch Data over I2C?</em></p>
<p><strong>cst816s_get_touch_data</strong> is called by the <strong><code>read()</code></strong> File Operation of our driver: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L334-L388">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Implements the read() File Operation for the driver
static ssize_t cst816s_read(FAR struct file *filep, FAR char *buffer, size_t buflen) {
  ...
  //  Wait for semaphore to prevent concurrent reads
  int ret = nxsem_wait(&amp;priv-&gt;devsem);

  //  Read the touch data, only if 
  //  screen has been touched or if 
  //  we&#39;re waiting for touch up
  ret = -EINVAL;
  if ((priv-&gt;int_pending || last_event == 0) 
    &amp;&amp; buflen &gt;= outlen) {
    ret = cst816s_get_touch_data(priv, buffer);
  }

  //  Clear the Pending Flag with critical section
  flags = enter_critical_section();
  priv-&gt;int_pending = false;
  leave_critical_section(flags);

  //  Release semaphore and allow next read
  nxsem_post(&amp;priv-&gt;devsem);</code></pre></div>
<p>(Which means that this code will run when a NuttX App reads <em>‚Äú/dev/input0‚Äù</em>)</p>
<p>Note that we <strong>fetch the Touch Data</strong> over I2C only if‚Ä¶</p>
<ul>
<li>
<p>Screen has <strong>just been touched</strong></p>
<p>(Indicated by the Pending Flag <strong>int_pending</strong>)</p>
</li>
<li>
<p>Or if the <strong>last event was Touch Down</strong></p>
<p>(And we‚Äôre waiting for Touch Up)</p>
</li>
</ul>
<p><em>Why check the Pending Flag?</em></p>
<p>Recall that the Pending Flag is set when the <strong>screen is touched</strong>. (Which triggers a GPIO Interrupt)</p>
<p>The Pending Flag tells us when the Touch Panel‚Äôs I2C Interface is active. And there‚Äôs <strong>valid Touch Data</strong> to be fetched.</p>
<p>Thus this check <strong>prevents unnecessary I2C Reads</strong>, until the Touch Data is available for reading.</p>
<p><em>Why check if the last event was Touch Down?</em></p>
<p>When we‚Äôre no longer touching the screen, the Touch Panel <strong>doesn‚Äôt trigger a GPIO Interrupt</strong>.</p>
<p>Thus to catch the <strong>Touch Up Event</strong>, we must allow the Touch Data to be fetched over I2C.  And we stop fetching thereafter. (Until the screen is touched again)</p>
<p>This causes a few redundant I2C Reads, but it shouldn‚Äôt affect performance.</p>
<p>(Unless we touch the screen for a very long time!)</p>
<h1 id="run-the-driver"><a href="#run-the-driver">7 Run The Driver</a></h1>
<p>For our final demo today, let‚Äôs run our CST816S Driver and test the Touch Panel!</p>
<p>Follow these steps to <strong>build, flash and run NuttX</strong> on PineDio Stack (with CST816S logging enabled)‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#build-nuttx"><strong>‚ÄúBuild NuttX‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#appendix-nuttx-logging"><strong>‚ÄúNuttX Logging‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#flash-pinedio-stack"><strong>‚ÄúFlash PineDio Stack‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#boot-pinedio-stack"><strong>‚ÄúBoot PineDio Stack‚Äù</strong></a></p>
</li>
</ul>
<p>In the NuttX Shell, enter this command to run the <a href="https://github.com/lupyuen/lvgltest-nuttx"><strong>LVGL Test App</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>lvgltest</code></pre></div>
<p>We should see the <strong>Touch Calibration</strong> screen‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch-title.jpg" alt="Touch Panel Calibration for Pine64 PineDio Stack BL604 RISC-V Board" /></p>
<p>When prompted, <strong>tap the 4 corners</strong> of the screen‚Ä¶</p>
<ul>
<li>
<p><a href="https://www.youtube.com/shorts/2Nzjrlp5lcE"><strong>Watch the demo on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/cst816s-nuttx#test-touch-data"><strong>See the Debug Log</strong></a></p>
</li>
</ul>
<p>Yep our CST816S Driver responds correctly to touch! üéâ</p>
<p><em>The touchscreen looks laggy?</em></p>
<p>TODO</p>
<p>PineDio Stack Touch Screen feels laggy on Apache #NuttX RTOS right now ‚Ä¶ 2 things we can fix: 1Ô∏è‚É£ Increase SPI Frequency 2Ô∏è‚É£ Switch to SPI DMA eventually</p>
<p>Let‚Äôs study the log‚Ä¶</p>
<h2 id="read-touch-data-1"><a href="#read-touch-data-1">7.1 Read Touch Data</a></h2>
<p>TODO</p>
<p>The LVGL Test App calls <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L328-L382"><code>cst816s_read()</code></a> repeatedly on the CST816S Driver to get Touch Data‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>bool tp_read(struct _lv_indev_drv_t *indev_drv, lv_indev_data_t *data)
{
  ...
  /* Read one sample */

  nbytes = read(fd, &amp;sample, sizeof(struct touch_sample_s));</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/tp.c#L115-L132">(Source)</a></p>
<p>Since the screen hasn‚Äôt been touched and we have no Touch Data yet, our driver returns an error <code>-EINVAL</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>static ssize_t cst816s_read(FAR struct file *filep, FAR char *buffer,
                            size_t buflen)
{
  ...
  int ret = -EINVAL;

  /* Read the touch data, only if screen has been touched or if we&#39;re waiting for touch up */
  if ((priv-&gt;int_pending || last_event == 0) &amp;&amp; buflen &gt;= outlen)
    {
      ret = cst816s_get_touch_data(priv, buffer);
    }</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L336-L370">(Source)</a></p>
<p><code>int_pending</code> becomes true when a GPIO Interrupt gets triggered later.</p>
<p><code>last_event</code> becomes 0 when we get a Touch Down event later.</p>
<p><em>Why do we check <code>int_pending</code>?</em></p>
<p>To reduce contention on the I2C Bus, we only read the Touch Data over I2C when the screen has been touched. We‚Äôll see this in a while.</p>
<p>(But the LVGL Test App really shouldn‚Äôt call <code>read()</code> repeatedly. It ought to call <code>poll()</code> and block until Touch Data is available)</p>
<p><em>Why do we we check <code>last_event</code>?</em></p>
<p>The Touch Controller triggers a GPIO Interrupt only upon Touch Down, not on Touch Up.</p>
<p>So after Touch Down, we allow  <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L328-L382"><code>cst816s_read()</code></a> to call <code>cst816s_get_touch_data()</code> to fetch the Touch Data repeatedly, until we see the Touch Up Event. We‚Äôll see this in a while.</p>
<p>TODO7</p>
<p><img src="https://lupyuen.github.io/images/touch-code6a.png" alt="" /></p>
<h2 id="trigger-gpio-interrupt"><a href="#trigger-gpio-interrupt">7.2 Trigger GPIO Interrupt</a></h2>
<p>TODO</p>
<p>We touch the screen and trigger a GPIO Interrupt‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_expander_interrupt: Interrupt! callback=0x2305e596, arg=0x42020a70
bl602_expander_interrupt: Call callback=0x2305e596, arg=0x42020a70
cst816s_poll_notify:</code></pre></div>
<p>The Interrupt Handler in our driver sets <code>int_pending</code> to true‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>static int cst816s_isr_handler(int _irq, FAR void *_context, FAR void *arg)
{
  FAR struct cst816s_dev_s *priv = (FAR struct cst816s_dev_s *)arg;
  irqstate_t flags;

  DEBUGASSERT(priv != NULL);

  flags = enter_critical_section();
  priv-&gt;int_pending = true;
  leave_critical_section(flags);

  cst816s_poll_notify(priv);
  return 0;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L598-L611">(Source)</a></p>
<p>And calls <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L472-L498"><code>cst816s_poll_notify()</code></a> to unblock all <code>poll()</code> callers and notify them that Touch Data is available.</p>
<p>(But LVGL Test App doesn‚Äôt <code>poll()</code> our driver, so this doesn‚Äôt effect anything)</p>
<h2 id="touch-down-event"><a href="#touch-down-event">7.3 Touch Down Event</a></h2>
<p>TODO</p>
<p>Remember that the LVGL Test App keeps calling <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L328-L382"><code>cst816s_read()</code></a> repeatedly to get Touch Data.</p>
<p>Now that <code>int_pending</code> is true, our driver proceeds to call <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L222-L326"><code>cst816s_get_touch_data()</code></a> and fetch the Touch Data over I2C‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_transfer: i2c tbl602_i2c_recvdata: count=7, temp=0x500
bl602_i2c_recvdata: count=3, temp=0x1700de
ransfer success
cst816s_get_touch_data: DOWN: id=0,touch=0, x=222, y=23
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       222
cst816s_get_touch_data:   y:       23</code></pre></div>
<p>The Touch Data that was read from CST816S over I2C‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>cst816s_get_touch_data: DOWN: id=0,touch=0, x=222, y=23</code></pre></div>
<p>Gets returned directly to the LVGL Test App as a Touch Down Event‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       222
cst816s_get_touch_data:   y:       23</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L222-L326"><code>cst816s_get_touch_data()</code></a> sets <code>last_event</code> to 0 because it‚Äôs a Touch Down Event.</p>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L372-L382"><code>cst816s_read()</code></a> sets <code>int_pending</code> to false.</p>
<p>TODO9</p>
<p><img src="https://lupyuen.github.io/images/touch-run2a.png" alt="" /></p>
<h2 id="touch-down-event-again"><a href="#touch-down-event-again">7.4 Touch Down Event Again</a></h2>
<p>TODO</p>
<p>LVGL Test App is still calling <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L328-L382"><code>cst816s_read()</code></a> repeatedly to get Touch Data.</p>
<p>Now that <code>last_event</code> is 0 (Touch Down), our driver proceeds to call <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L222-L326"><code>cst816s_get_touch_data()</code></a> and fetch the Touch Data over I2C‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_transfer: i2c tbl602_i2c_recvdata: count=7, temp=0x500
bl602_i2c_recvdata: count=3, temp=0x1700de
ransfer success
cst816s_get_touch_data: DOWN: id=0, ouch=0, x=222, y=23
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       222
cst816s_get_touch_data:   y:       23

cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_transfer: i2c tbl602_i2c_recvdata: count=7, temp=0x500
bl602_i2c_recvdata: count=3, temp=0x1700de
ransfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=222, y=23
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       222
cst816s_get_touch_data:   y:       23</code></pre></div>
<p>This happens twice because we haven‚Äôt received a Touch Up Event.</p>
<h2 id="touch-up-event"><a href="#touch-up-event">7.5 Touch Up Event</a></h2>
<p>TODO</p>
<p>When our finger is no longer touching the screen, <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L222-L326"><code>cst816s_get_touch_data()</code></a> receives a Touch Up Event‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: Invalid touch data: id=9, touch=2, x=639, y=1688
cst816s_get_touch_data: UP: id=0, touch=2, x=222, y=23
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   0c
cst816s_get_touch_data:   x:       222
cst816s_get_touch_data:   y:       23</code></pre></div>
<p>For Touch Up Events the Touch Coordinates are invalid‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>cst816s_get_touch_data: Invalid touch data: id=9, touch=2, x=639, y=1688</code></pre></div>
<p>The driver patches the Touch Coordinates with the data from the last Touch Down Event‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>cst816s_get_touch_data: UP: id=0, touch=2, x=222, y=23
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   0c
cst816s_get_touch_data:   x:       222
cst816s_get_touch_data:   y:       23</code></pre></div>
<p>And returns the valid coordinates to the LVGL Test App. The patching is done here‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>static int cst816s_get_touch_data(FAR struct cst816s_dev_s *dev, FAR void *buf) {
...
  /* If touch coordinates are invalid, return the last valid coordinates. */

  bool valid = true;
  if (x &gt;= 240 || y &gt;= 240)
    {
      iwarn(&quot;Invalid touch data: id=%d, touch=%d, x=%d, y=%d\n&quot;, id, touchpoints, x, y);
      if (last_event == 0xff)  /* Quit if we have no last valid coordinates. */
        {
          ierr(&quot;Can&#39;t return touch data: id=%d, touch=%d, x=%d, y=%d\n&quot;, id, touchpoints, x, y);
          return -EINVAL;
        }
      valid = false;
      id = last_id;
      x  = last_x;
      y  = last_y;
    }

  /* Remember the last valid touch data. */

  last_event = event;
  last_id    = id;
  last_x     = x;
  last_y     = y;

  /* Set the touch data fields. */

  memset(&amp;data, 0, sizeof(data));
  data.npoints     = 1;
  data.point[0].id = id;
  data.point[0].x  = x;
  data.point[0].y  = y;</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L258-L282">(Source)</a></p>
<p><code>last_event</code> is now set to 1 (Touch Up). </p>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L328-L382"><code>cst816s_read()</code></a> will no longer call <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L222-L326"><code>cst816s_get_touch_data()</code></a> to fetch the Touch Data, until the screen is touched again.</p>
<p>TODO10</p>
<p><img src="https://lupyuen.github.io/images/touch-run4a.png" alt="" /></p>
<h2 id="screen-calibration-result"><a href="#screen-calibration-result">7.6 Screen Calibration Result</a></h2>
<p>TODO</p>
<p>When we have touched the 4 screen corners, the LVGL Test App displays the Screen Calibration result‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>tp_cal result
offset x:23, y:24
range x:194, y:198
invert x/y:1, x:0, y:1</code></pre></div>
<p>Which will be used to tweak the Touch Coordinates in the apps.</p>
<h1 id="screen-is-sideways"><a href="#screen-is-sideways">8 Screen Is Sideways</a></h1>
<p>TODO</p>
<p>According to the Touch Data from the LVGL Test App, our screen is rotated sideways‚Ä¶</p>
<ul>
<li>
<p>Top Left: x=181, y=12</p>
</li>
<li>
<p>Top Right: x=230, y=212</p>
</li>
<li>
<p>Bottom Left: x=9, y=10</p>
</li>
<li>
<p>Bottom Right: x=19, y=202</p>
</li>
</ul>
<p>So be careful when mapping the touch coordinates.</p>
<p>We can rotate the display in the ST7789 Driver. But first we need to agree which way is ‚Äúup‚Äù‚Ä¶</p>
<p>TODO1</p>
<p><img src="https://lupyuen.github.io/images/touch-button.jpg" alt="" /></p>
<h1 id="i2c-quirks"><a href="#i2c-quirks">9 I2C Quirks</a></h1>
<p><em>Is there anything peculiar about I2C on BL602 and BL604?</em></p>
<p>TODO: Register ID as Sub Address</p>
<p>TODO: Warning</p>
<h2 id="i2c-sub-address"><a href="#i2c-sub-address">9.1 I2C Sub Address</a></h2>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L136-L220">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/****************************************************************************
 * Name: cst816s_i2c_read
 *
 * Description:
 *   Read from I2C device.
 *
 ****************************************************************************/

static int cst816s_i2c_read(FAR struct cst816s_dev_s *dev, uint8_t reg,
                            uint8_t *buf, size_t buflen)
{
  iinfo(&quot;\n&quot;); ////
  struct i2c_msg_s msgv[2] =
  {
    {
      .frequency = CONFIG_CST816S_I2C_FREQUENCY,
      .addr      = dev-&gt;addr,
#ifdef CONFIG_BL602_I2C0
      .flags     = I2C_M_NOSTART,  /* BL602 must send Register ID as Sub Address */
#else
      .flags     = 0,  /* Otherwise send Register ID normally */
#endif /* CONFIG_BL602_I2C0 */
      .buffer    = &amp;reg,
      .length    = 1
    },
    {
      .frequency = CONFIG_CST816S_I2C_FREQUENCY,
      .addr      = dev-&gt;addr,
      .flags     = I2C_M_READ,
      .buffer    = buf,
      .length    = buflen
    }
  };

  int ret = -EIO;
  int retries;

  /* CST816S will respond with NACK to address when in low-power mode. Host
   * needs to retry address selection multiple times to get CST816S to
   * wake-up.
   */

  for (retries = 0; retries &lt; CST816S_I2C_RETRIES; retries++)
    {
      ret = I2C_TRANSFER(dev-&gt;i2c, msgv, 2);
      if (ret == -ENXIO)
        {
          /* -ENXIO is returned when getting NACK from response.
           * Keep trying.
           */

          iwarn(&quot;I2C NACK\n&quot;); ////
          continue;
        }
      else if (ret &gt;= 0)
        {
          /* Success! */

          return 0;
        }
      else
        {
          /* Some other error. Try to reset I2C bus and keep trying. */

          iwarn(&quot;I2C error\n&quot;); ////
#ifdef CONFIG_I2C_RESET
          if (retries == CST816S_I2C_RETRIES - 1)
            {
              break;
            }

          ret = I2C_RESET(dev-&gt;i2c);
          if (ret &lt; 0)
            {
              iinfo(&quot;I2C_RESET failed: %d\n&quot;, ret);
              return ret;
            }
#endif
        }
    }

  /* Failed to read sensor. */

  return ret;
}</code></pre></div><h2 id="i2c-logging"><a href="#i2c-logging">9.2 I2C Logging</a></h2>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L222-L326"><code>cst816s_get_touch_data()</code></a> won‚Äôt return any valid Touch Data unless we enable I2C Logging. Could be an I2C Timing Issue or Race Condition.</p>
<p>With I2C Logging Enabled: We get the Touch Down Event (with valid Touch Data)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; lvgltest
tp_init: Opening /dev/input0
cst816s_open:

bl602_expander_interrupt: Interrupt! callback=0x2305e596, arg=0x42020a70
bl602_expander_interrupt: Call callback=0x2305e596, arg=0x42020a70
cst816s_poll_notify:

cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_transfer: i2c tbl602_i2c_recvdata: count=7, temp=0x500
bl602_i2c_recvdata: count=3, temp=0x1700de
Transfer success
cst816s_get_touch_data: DOWN: id=0,touch=0, x=222, y=23
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       222
cst816s_get_touch_data:   y:       23</code></pre></div>
<p>With I2C Logging Disabled: We only get the Touch Up Event (with invalid Touch Data)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; lvgltest
tp_init: Opening /dev/input0
cst816s_open:

bl602_expander_interrupt: Interrupt! callback=0x2305e55e, arg=0x42020a70
bl602_expander_interrupt: Call callback=0x2305e55e, arg=0x42020a70
cst816s_poll_notify:

cst816s_get_touch_data:
cst816s_i2c_read:
cst816s_get_touch_data: Invalid touch data: id=9, touch=2, x=639, y=1688
cst816s_get_touch_data: Can&#39;t return touch data: id=9, touch=2, x=639, y=1688

bl602_expander_interrupt: Interrupt! callback=0x2305e55e, arg=0x42020a70
bl602_expander_interrupt: Call callback=0x2305e55e, arg=0x42020a70
cst816s_poll_notify:

cst816s_get_touch_data:
cst816s_i2c_read:
cst816s_get_touch_data: Invalid touch data: id=9, touch=2, x=639, y=1688
cst816s_get_touch_data: Can&#39;t return touch data: id=9, touch=2, x=639, y=1688</code></pre></div>
<p>This happens before and after we have reduced the number of I2C Transfers (by checking GPIO Interrupts via <code>int_pending</code>).</p>
<p>The workaround is to call <code>i2cwarn()</code> in the <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_i2c.c">BL602 I2C Driver</a> to force this specific log to be printed‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>static int bl602_i2c_transfer(struct i2c_master_s *dev,
                              struct i2c_msg_s *   msgs,
                              int                      count) {
      ...
      if (priv-&gt;i2cstate == EV_I2C_END_INT)
        {
          i2cinfo(&quot;i2c transfer success\n&quot;);
#ifdef CONFIG_INPUT_CST816S
          /* Workaround for CST816S. See https://github.com/lupyuen/cst816s-nuttx#i2c-logging */

          i2cwarn(&quot;i2c transfer success\n&quot;);
#endif /* CONFIG_INPUT_CST816S */
        }</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_i2c.c#L753-L761">(Source)</a></p>
<p>After patching the workaround, we get the Touch Down Event (with valid Touch Data)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; lvgltest
tp_init: Opening /dev/input0
cst816s_open:

bl602_expander_interrupt: Interrupt! callback=0x2305e55e, arg=0x42020a70
bl602_expander_interrupt: Call callback=0x2305e55e, arg=0x42020a70
cst816s_poll_notify:

cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=200, y=26
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       200
cst816s_get_touch_data:   y:       26</code></pre></div>
<p>LoRaWAN Test App <code>lorawan_test</code> also tested OK with the patch.</p>
<p><strong>TODO:</strong> Investigate the internals of the <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_i2c.c">BL602 I2C Driver</a>. Look for I2C Timing Issues or Race Conditions.</p>
<p><strong>TODO:</strong> Probe the I2C Bus with a Logic Analyser. Watch for I2C Hardware issues.</p>
<p><strong>TODO:</strong> Why must we disable logging? Eventually we must disable <code>CONFIG_DEBUG_INFO</code> (Informational Debug Output) because the LoRaWAN Test App <code>lorawan_test</code> fails when <code>CONFIG_DEBUG_INFO</code> is enabled (due to LoRaWAN Timers)</p>
<p><strong>TODO:</strong> LoRaWAN Test App, LoRaWAN Library, SX1262 Library, NimBLE Porting Layer, SPI Test Driver should have their own flags for logging</p>
<p><strong>TODO:</strong> Move CST816S Interrupt Handler to <a href="https://github.com/lupyuen/bl602_expander">BL602 GPIO Expander</a></p>
<p><strong>TODO:</strong> Implement SPI DMA on NuttX so that the touchscreen feels less laggy</p>
<p><strong>TODO:</strong> <a href="https://docs.lvgl.io/7.11/get-started/quick-overview.html#button-with-label">Add a button</a> and a message box to the <a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L110-L198">LVGL Test App <code>lvgltest</code></a> to demo the touchscreen</p>
<h1 id="whats-next"><a href="#whats-next">10 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>I hope this article has provided everything you need to get started on creating <strong>your own IoT App</strong>.</p>
<p>Lemme know what you‚Äôre building with PineDio Stack!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/touch.md"><code>lupyuen.github.io/src/touch.md</code></a></p>
<h1 id="notes"><a href="#notes">11 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1514049092388745219">this Twitter Thread</a></li>
</ol>
<h1 id="appendix-install-driver"><a href="#appendix-install-driver">12 Appendix: Install Driver</a></h1>
<p>TODO</p>
<p>To add this repo to your NuttX project‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>pushd nuttx/nuttx/drivers/input
git submodule add https://github.com/lupyuen/cst816s-nuttx cst816s
ln -s cst816s/cst816s.c .
popd

pushd nuttx/nuttx/include/nuttx/input
ln -s ../../../drivers/input/cst816s/cst816s.h .
popd</code></pre></div>
<p>Next update the Makefile and Kconfig‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/incubator-nuttx/commit/5dbf67df8f36cdba2eb0034dac0ff8ed0f8e73e1">See the modified Makefile and Kconfig</a></li>
</ul>
<p>Then update the NuttX Build Config‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># TODO: Change this to the path of our &quot;incubator-nuttx&quot; folder
cd nuttx/nuttx

# Preserve the Build Config
cp .config ../config

# Erase the Build Config and Kconfig files
make distclean

# For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

# For PineDio Stack BL604: Configure the build for BL604
./tools/configure.sh bl602evb:pinedio

# For ESP32: Configure the build for ESP32.
# TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

# Restore the Build Config
cp ../config .config

# Edit the Build Config
make menuconfig </code></pre></div>
<p>In menuconfig, enable the Hynitron CST816S Driver under ‚ÄúDevice Drivers ‚Üí Input Device Support‚Äù.</p>
<p>Edit the function <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_i2c.c#L671-L773"><code>bl602_i2c_transfer</code></a> and apply this workaround patch‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/cst816s-nuttx#i2c-logging">‚ÄúI2C Logging‚Äù</a></li>
</ul>
<p>We need to enable warnings for the I2C driver. Follow the instructions in the next section‚Ä¶</p>
<h1 id="appendix-gpio-interrupt"><a href="#appendix-gpio-interrupt">13 Appendix: GPIO Interrupt</a></h1>
<p>TODO</p>
<p>CST816S will trigger <strong>GPIO Interrupts</strong> when we touch the screen.</p>
<p>Earlier we called these functions at startup to handle GPIO Interrupts‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L731-L772"><strong>bl602_irq_attach</strong></a>: Attach our GPIO Interrupt Handler</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L774-L804"><strong>bl602_irq_enable</strong></a>: Enable GPIO Interrupt</p>
</li>
</ul>
<p><code>bl602_irq_attach</code> is defined below‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Attach Interrupt Handler to GPIO Interrupt for Touch Controller
//  Based on https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L477-L505
static int bl602_irq_attach(gpio_pinset_t pinset, FAR isr_handler *callback, FAR void *arg)
{
  int ret = 0;
  uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;
  FAR struct bl602_gpint_dev_s *dev = NULL;  //  TODO

  DEBUGASSERT(callback != NULL);

  /* Configure the pin that will be used as interrupt input */

  #warning Check GLB_GPIO_INT_TRIG_NEG_PULSE  //  TODO
  bl602_expander_set_intmod(gpio_pin, 1, GLB_GPIO_INT_TRIG_NEG_PULSE);
  ret = bl602_configgpio(pinset);
  if (ret &lt; 0)
    {
      gpioerr(&quot;Failed to configure GPIO pin %d\n&quot;, gpio_pin);
      return ret;
    }

  /* Make sure the interrupt is disabled */

  bl602_expander_pinset = pinset;
  bl602_expander_callback = callback;
  bl602_expander_arg = arg;
  bl602_expander_intmask(gpio_pin, 1);

  irq_attach(BL602_IRQ_GPIO_INT0, bl602_expander_interrupt, dev);
  bl602_expander_intmask(gpio_pin, 0);

  gpioinfo(&quot;Attach %p\n&quot;, callback);

  return 0;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L686-L727">(Source)</a></p>
<p>Note that we‚Äôre calling <code>bl602_expander</code> to handle interrupts. There doesn‚Äôt seem to be a way to do this with the current BL602 GPIO Driver (<code>bl602evb/bl602_gpio.c</code>).</p>
<p>We are building <code>bl602_expander</code> here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602_expander">lupyuen/bl602_expander</a></li>
</ul>
<p>TODO: bl602_irq_enable</p>
<div class="example-wrap"><pre class="language-c"><code>/****************************************************************************
 * Name: bl602_irq_enable
 *
 * Description:
 *   Enable or disable GPIO Interrupt for Touch Controller.
 *   Based on https://github.com/lupyuen/incubator-nuttx/blob/touch/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L507-L535
 *
 ****************************************************************************/

static int bl602_irq_enable(bool enable)
{
  if (enable)
    {
      if (bl602_expander_callback != NULL)
        {
          gpioinfo(&quot;Enable interrupt\n&quot;);
          up_enable_irq(BL602_IRQ_GPIO_INT0);
        }
      else
        {
          gpiowarn(&quot;No callback attached\n&quot;);
        }
    }
  else
    {
      gpioinfo(&quot;Disable interrupt\n&quot;);
      up_disable_irq(BL602_IRQ_GPIO_INT0);
    }

  return 0;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L774-L804">(Source)</a></p>
<p>To test interrupts we uncomment <code>#define TEST_CST816S_INTERRUPT</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>int cst816s_register(FAR const char *devpath,
                     FAR struct i2c_master_s *i2c_dev,
                     uint8_t i2c_devaddr)
{
...
//  Uncomment this to test interrupts (tap the screen)
#define TEST_CST816S_INTERRUPT
#ifdef TEST_CST816S_INTERRUPT
#warning Testing CST816S interrupt
  bl602_irq_enable(true);
#endif /* TEST_CST816S_INTERRUPT */</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L593-L661">(Source)</a></p>
<p>There‚Äôs bug with BL602 GPIO Interrupts that we have fixed for our driver‚Ä¶</p>
<p>https://github.com/apache/incubator-nuttx/issues/5810#issuecomment-1098633538</p>
<p><img src="https://lupyuen.github.io/images/touch-title2.jpg" alt="Touch Panel Calibration for Pine64 PineDio Stack BL604 RISC-V Board" /></p>
<p><em>Touch Panel Calibration for Pine64 PineDio Stack BL604 RISC-V Board</em></p>

    
</body>
</html>