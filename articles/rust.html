<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Run Rust RISC-V Firmware with BL602 IoT SDK</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Run Rust RISC-V Firmware with BL602 IoT SDK" 
    data-rh="true">
<meta property="og:description" 
    content="How we build, flash and run Rust firmware on BL602 RISC-V SoC... With the BL602 IoT SDK"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/rust-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Run Rust RISC-V Firmware with BL602 IoT SDK</h1>
    <nav id="TOC"><ul>
<li><a href="#bl602-blinky-in-c">1 BL602 Blinky in C</a><ul></ul></li>
<li><a href="#bl602-blinky-in-rust">2 BL602 Blinky in Rust</a><ul></ul></li>
<li><a href="#import-bl602-iot-sdk-into-rust">3 Import BL602 IoT SDK into Rust</a><ul></ul></li>
<li><a href="#rust-on-bl602-iot-sdk">4 Rust on BL602 IoT SDK</a><ul></ul></li>
<li><a href="#build-the-bl602-rust-firmware">5 Build the BL602 Rust Firmware</a><ul></ul></li>
<li><a href="#run-the-bl602-rust-firmware">6 Run the BL602 Rust Firmware</a><ul></ul></li>
<li><a href="#rust-targets">7 Rust Targets</a><ul></ul></li>
<li><a href="#custom-rust-target-for-bl602">8 Custom Rust Target for BL602</a><ul></ul></li>
<li><a href="#rust-on-bl602-two-more-ways">9 Rust On BL602: Two More Ways</a><ul></ul></li>
<li><a href="#apache-nuttx-on-bl602">10 Apache NuttX on BL602</a><ul></ul></li>
<li><a href="#whats-next">11 What's Next</a><ul></ul></li>
<li><a href="#notes">12 Notes</a><ul></ul></li></ul></nav><p>üìù <em>22 Apr 2021</em></p>
<p>In the past 14 articles we've done so much with BL602 IoT SDK: LoRa wireless transceivers, SPI LCD displays, UART e-ink displays, I2C sensors, ...</p>
<p><em>Can we do this in Rust? (Instead of C)</em></p>
<p><em>And flash our Rust firmware to BL602 over UART? (Instead of JTAG)</em></p>
<p>Let's run some Rust code on top of BL602 IoT SDK, and understand how that's possible.</p>
<p>Today we won't be talking about the merits (and demerits) of Embedded Rust, we'll save that for the future.</p>
<p>But if you have the tiniest interest in coding Rust firmware for BL602... Then read on!</p>
<p><img src="https://lupyuen.github.io/images/rust-title.jpg" alt="PineCone BL602 RISC-V Board" /></p>
<p><em>PineCone BL602 RISC-V Board</em></p>
<h1 id="bl602-blinky-in-c" class="section-header"><a href="#bl602-blinky-in-c">1 BL602 Blinky in C</a></h1>
<p>Before we do Rust, let's look at the C code that blinks the LED on BL602 (by toggling the GPIO output): <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_blinky/sdk_app_blinky/demo.c"><code>sdk_app_blinky/demo.c</code></a></p>
<pre><code class="language-c">#include &lt;bl_gpio.h&gt;     //  For BL602 GPIO Hardware Abstraction Layer
#include &quot;nimble_npl.h&quot;  //  For NimBLE Porting Layer (mulitasking functions)

/// PineCone Blue LED is connected on BL602 GPIO 11
/// TODO: Change the LED GPIO Pin Number for your BL602 board
#define LED_GPIO 11

/// Blink the BL602 LED
void blinky(char *buf, int len, int argc, char **argv) {
    //  Show a message on the serial console
    puts(&quot;Hello from Blinky!&quot;);

    //  Configure the LED GPIO for output (instead of input)
    int rc = bl_gpio_enable_output(
        LED_GPIO,  //  GPIO pin number
        0,         //  No GPIO pullup
        0          //  No GPIO pulldown
    );
    assert(rc == 0);  //  Halt on error

    //  Blink the LED 5 times
    for (int i = 0; i &lt; 10; i++) {

        //  Toggle the LED GPIO between 0 (on) and 1 (off)
        rc = bl_gpio_output_set(  //  Set the GPIO output (from BL602 GPIO HAL)
            LED_GPIO,             //  GPIO pin number
            i % 2                 //  0 for low, 1 for high
        );
        assert(rc == 0);  //  Halt on error

        //  Sleep 1 second
        time_delay(                   //  Sleep by number of ticks (from NimBLE Porting Layer)
            time_ms_to_ticks32(1000)  //  Convert 1,000 milliseconds to ticks (from NimBLE Porting Layer)
        );
    }

    //  Return to the BL602 command-line interface
}
</code></pre>
<p>Here we call two <strong>GPIO Functions</strong> from the BL602 IoT SDK (specifically, the BL602 <strong>GPIO Hardware Abstraction Layer</strong>)...</p>
<ul>
<li>
<p><strong><code>bl_gpio_enable_output</code></strong>: Configure a GPIO Pin for output (instead of input)</p>
</li>
<li>
<p><strong><code>bl_gpio_output_set</code></strong>: Set the GPIO Pin output to high or low</p>
</li>
</ul>
<p>Instead of calling the <strong>Multitasking Functions</strong> in FreeRTOS, we call the <strong>NimBLE Porting Layer</strong> (which wraps FreeRTOS into a simpler API)...</p>
<ul>
<li>
<p><strong><code>time_delay</code></strong>: Put the current FreeRTOS task to sleep (for a number of system ticks)</p>
</li>
<li>
<p><strong><code>time_ms_to_ticks32</code></strong>: Convert milliseconds to FreeRTOS system ticks</p>
</li>
</ul>
<p>Now let's code-switch to Rust.</p>
<h1 id="bl602-blinky-in-rust" class="section-header"><a href="#bl602-blinky-in-rust">2 BL602 Blinky in Rust</a></h1>
<p>Here's our BL602 Blinky Firmware, coded in Rust: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/rust/src/lib.rs#L1-L8"><code>rust/src/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">//!  Main Rust Application for BL602 Firmware</span>
<span class="attribute">#![<span class="ident">no_std</span>]</span>  <span class="comment">//  Use the Rust Core Library instead of the Rust Standard Library, which is not compatible with embedded systems</span>

<span class="comment">//  Import the Rust Core Library</span>
<span class="kw">use</span> <span class="ident">core</span>::{
    <span class="ident">panic</span>::<span class="ident">PanicInfo</span>,  <span class="comment">//  For `PanicInfo` type used by `panic` function</span>
    <span class="ident">str</span>::<span class="ident">FromStr</span>,      <span class="comment">//  For converting `str` to `String`</span>
};</pre></div>
<p>First we tell the Rust Compiler to use the <strong>Rust Core Library</strong>.</p>
<p>(Instead of the Rust Standard Library, which is too heavy for microcontrollers)</p>
<p>We import <code>PanicInfo</code> and <code>FromStr</code> to handle Errors and String Conversion. (We'll see later)</p>
<p>Our Rust Blinky Function looks similar to the C version: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/rust/src/lib.rs#L10-L44"><code>rust/src/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// `rust_main` will be called by the BL602 command-line interface</span>
<span class="attribute">#[<span class="ident">no_mangle</span>]</span>              <span class="comment">//  Don&#39;t mangle the name `rust_main`</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">rust_main</span>(  <span class="comment">//  Declare `extern &quot;C&quot;` because it will be called by BL602 firmware</span>
    <span class="ident">_buf</span>:  <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>,        <span class="comment">//  Command line (char *)</span>
    <span class="ident">_len</span>:  <span class="ident">i32</span>,              <span class="comment">//  Length of command line (int)</span>
    <span class="ident">_argc</span>: <span class="ident">i32</span>,              <span class="comment">//  Number of command line args (int)</span>
    <span class="ident">_argv</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>  <span class="comment">//  Array of command line args (char **)</span>
) {
    <span class="comment">//  Show a message on the serial console</span>
    <span class="ident">puts</span>(<span class="string">&quot;Hello from Rust!&quot;</span>);

    <span class="comment">//  PineCone Blue LED is connected on BL602 GPIO 11</span>
    <span class="kw">const</span> <span class="ident">LED_GPIO</span>: <span class="ident">u8</span> <span class="op">=</span> <span class="number">11</span>;  <span class="comment">//  `u8` is 8-bit unsigned integer</span>

    <span class="comment">//  Configure the LED GPIO for output (instead of input)</span>
    <span class="ident">bl_gpio_enable_output</span>(<span class="ident">LED_GPIO</span>, <span class="number">0</span>, <span class="number">0</span>)      <span class="comment">//  No pullup, no pulldown</span>
        .<span class="ident">expect</span>(<span class="string">&quot;GPIO enable output failed&quot;</span>);  <span class="comment">//  Halt on error</span></pre></div>
<p>When <strong>code-switching from C to Rust</strong> we consciously...</p>
<ol>
<li>
<p><strong>Rename the Types:</strong> &quot;<code>int</code>&quot; in C becomes &quot;<code>i32</code>&quot; in Rust (32-bit signed integer)</p>
</li>
<li>
<p><strong>Flip the Declarations:</strong> &quot;<code>typename varname</code>&quot; in C becomes &quot;<code>varname: typename</code>&quot; in Rust</p>
</li>
<li>
<p><strong>Change Assertions to Expect:</strong> &quot;<code>assert</code>&quot; in C becomes &quot;<code>expect</code>&quot; in Rust. (More about this later)</p>
</li>
</ol>
<p>The rest of the Rust function looks similar to C...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
    <span class="comment">//  Blink the LED 5 times</span>
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">10</span> {  <span class="comment">//  Iterates 10 times from 0 to 9 (`..` excludes 10)</span>

        <span class="comment">//  Toggle the LED GPIO between 0 (on) and 1 (off)</span>
        <span class="ident">bl_gpio_output_set</span>(  <span class="comment">//  Set the GPIO output (from BL602 GPIO HAL)</span>
            <span class="ident">LED_GPIO</span>,        <span class="comment">//  GPIO pin number</span>
            <span class="ident">i</span> <span class="op">%</span> <span class="number">2</span>            <span class="comment">//  0 for low, 1 for high</span>
        ).<span class="ident">expect</span>(<span class="string">&quot;GPIO output failed&quot;</span>);  <span class="comment">//  Halt on error</span>

        <span class="comment">//  Sleep 1 second</span>
        <span class="ident">time_delay</span>(                   <span class="comment">//  Sleep by number of ticks (from NimBLE Porting Layer)</span>
            <span class="ident">time_ms_to_ticks32</span>(<span class="number">1000</span>)  <span class="comment">//  Convert 1,000 milliseconds to ticks (from NimBLE Porting Layer)</span>
        );
    }

    <span class="comment">//  Return to the BL602 command-line interface</span>
}</pre></div>
<p>(Yep the <code>for</code> loop looks a little different in Rust)</p>
<p>For Embedded Rust we need to include a <strong>Panic Handler</strong> that will handle errors (like Expect / Assertion Failures): <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/rust/src/lib.rs#L46-L57"><code>rust/src/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// This function is called on panic, like an assertion failure</span>
<span class="attribute">#[<span class="ident">panic_handler</span>]</span>
<span class="kw">fn</span> <span class="ident">panic</span>(<span class="ident">_info</span>: <span class="kw-2">&amp;</span><span class="ident">PanicInfo</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="op">!</span> {  <span class="comment">//  `!` means that panic handler will never return</span>
    <span class="comment">//  TODO: Implement the complete panic handler like this:</span>
    <span class="comment">//  https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/rust/app/src/lib.rs#L115-L146</span>

    <span class="comment">//  For now we display a message</span>
    <span class="ident">puts</span>(<span class="string">&quot;TODO: Rust panic&quot;</span>); 

	<span class="comment">//  Loop forever, do not pass go, do not collect $200</span>
    <span class="kw">loop</span> {}
}</pre></div>
<p>We're not done with Rust yet! Let's find out how we import the BL602 IoT SDK (and NimBLE Porting Library) into Rust.</p>
<p>Here's our code switching from C to Rust so far...</p>
<p><img src="https://lupyuen.github.io/images/rust-codeswitch.png" alt="Code Switching from C to Rust" /></p>
<h1 id="import-bl602-iot-sdk-into-rust" class="section-header"><a href="#import-bl602-iot-sdk-into-rust">3 Import BL602 IoT SDK into Rust</a></h1>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/rust/src/lib.rs#L118-L141"><code>rust/src/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Set the GPIO pin output to high or low.</span>
<span class="doccomment">/// TODO: Auto-generate this wrapper with `bindgen` from the C declaration:</span>
<span class="doccomment">/// `int bl_gpio_output_set(uint8_t pin, uint8_t value)`</span>
<span class="kw">fn</span> <span class="ident">bl_gpio_output_set</span>(
    <span class="ident">pin</span>:   <span class="ident">u8</span>,  <span class="comment">//  GPIO pin number (uint8_t)</span>
    <span class="ident">value</span>: <span class="ident">u8</span>   <span class="comment">//  0 for low, 1 to high</span>
) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">i32</span><span class="op">&gt;</span> {  <span class="comment">//  Returns an error code (int)</span></pre></div>
<p>TODO</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
    <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {        <span class="comment">//  Import C Function</span>
        <span class="doccomment">/// Set the GPIO pin output to high or low (from BL602 GPIO HAL)</span>
        <span class="kw">fn</span> <span class="ident">bl_gpio_output_set</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">value</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span>;
    }</pre></div>
<p>TODO</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
    <span class="comment">//  Call the C function</span>
    <span class="kw">let</span> <span class="ident">res</span> <span class="op">=</span> <span class="kw">unsafe</span> {  <span class="comment">//  Flag this code as unsafe because we&#39;re calling a C function</span>
        <span class="ident">bl_gpio_output_set</span>(<span class="ident">pin</span>, <span class="ident">value</span>)
    };</pre></div>
<p>TODO</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
    <span class="comment">//  Check the result code</span>
    <span class="kw">match</span> <span class="ident">res</span> {
        <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Ok</span>(()),   <span class="comment">//  If no error, return OK</span>
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Err</span>(<span class="ident">res</span>)  <span class="comment">//  Else return the result code as an error</span>
    }
}</pre></div>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/rust/src/lib.rs#L64-L90"><code>rust/src/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Print a message to the serial console.</span>
<span class="doccomment">/// TODO: Auto-generate this wrapper with `bindgen` from the C declaration</span>
<span class="kw">fn</span> <span class="ident">puts</span>(<span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span> {  <span class="comment">//  `&amp;str` is a reference to a string slice, similar to `char *` in C</span>

    <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {  <span class="comment">//  Import C Function</span>
        <span class="doccomment">/// Print a message to the serial console (from C stdio library)</span>
        <span class="kw">fn</span> <span class="ident">puts</span>(<span class="ident">s</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span>;
    }

    <span class="comment">//  Convert `str` to `String`, which similar to `char [64]` in C</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s_with_null</span> <span class="op">=</span> <span class="ident">String</span>::<span class="ident">from_str</span>(<span class="ident">s</span>)  <span class="comment">//  `mut` because we will modify it</span>
        .<span class="ident">expect</span>(<span class="string">&quot;puts conversion failed&quot;</span>);     <span class="comment">//  If it exceeds 64 chars, halt with an error</span>
    
    <span class="comment">//  Terminate the string with null, since we will be passing to C</span>
    <span class="ident">s_with_null</span>.<span class="ident">push</span>(<span class="string">&#39;\0&#39;</span>)
        .<span class="ident">expect</span>(<span class="string">&quot;puts overflow&quot;</span>);  <span class="comment">//  If we exceed 64 chars, halt with an error</span>

    <span class="comment">//  Convert the null-terminated string to a pointer</span>
    <span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">s_with_null</span>.<span class="ident">as_str</span>().<span class="ident">as_ptr</span>();

    <span class="comment">//  Call the C function</span>
    <span class="kw">unsafe</span> {  <span class="comment">//  Flag this code as unsafe because we&#39;re calling a C function</span>
        <span class="ident">puts</span>(<span class="ident">p</span>)
    }

    <span class="comment">//  No semicolon `;` here, so the value returned by the C function will be passed to our caller</span>
}</pre></div>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/rust/src/lib.rs#L179-L180"><code>rust/src/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Limit Strings to 64 chars, similar to `char[64]` in C</span>
<span class="kw">type</span> <span class="ident">String</span> <span class="op">=</span> <span class="ident">heapless</span>::<span class="ident">String</span>::<span class="op">&lt;</span><span class="ident">heapless</span>::<span class="ident">consts</span>::<span class="ident">U64</span><span class="op">&gt;</span>;</pre></div>
<h1 id="rust-on-bl602-iot-sdk" class="section-header"><a href="#rust-on-bl602-iot-sdk">4 Rust on BL602 IoT SDK</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/rust-arch.png" alt="Rust on BL602 IoT SDK" /></p>
<p>Strictly speaking this isn't Embedded Rust, because we're not running Rust directly on Bare Metal (BL602 Hardware). </p>
<p>Instead we're running Rust on top of an Embedded Operating System (BL602 IoT SDK + FreeRTOS). It's similar to running Rust on Linux / macOS / Windows.</p>
<p>We'll talk later about Embedded Rust on Bare Metal BL602.</p>
<h1 id="build-the-bl602-rust-firmware" class="section-header"><a href="#build-the-bl602-rust-firmware">5 Build the BL602 Rust Firmware</a></h1>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/run.sh#L10-L23"><code>run.sh</code></a></p>
<pre><code class="language-bash">#  Name of app
export APP_NAME=sdk_app_rust

#  Build for BL602
export CONFIG_CHIP_NAME=BL602

#  Where BL602 IoT SDK is located
export BL60X_SDK_PATH=$PWD/../..

#  Where blflash is located
export BLFLASH_PATH=$PWD/../../../blflash

#  Where GCC is located
export GCC_PATH=$PWD/../../../xpack-riscv-none-embed-gcc
</code></pre>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/run.sh#L29-L33"><code>run.sh</code></a></p>
<pre><code class="language-bash">#  Rust target: Custom target for llvm-abiname=ilp32f
#  https://docs.rust-embedded.org/embedonomicon/compiler-support.html#built-in-target
#  https://docs.rust-embedded.org/embedonomicon/custom-target.html
rust_build_target=$PWD/riscv32imacf-unknown-none-elf.json
rust_build_target_folder=riscv32imacf-unknown-none-elf
</code></pre>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/run.sh#L61-L71"><code>run.sh</code></a></p>
<pre><code class="language-bash">#  Remove the Stub Library if it exists:
#  build_out/rust-app/librust-app.a
if [ -e $rust_app_dest ]; then
    rm $rust_app_dest
fi

#  Remove the Rust Library if it exists:
#  rust/target/riscv32imacf-unknown-none-elf/debug/libapp.a
if [ -e $rust_app_build ]; then
    rm $rust_app_build
fi
</code></pre>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/run.sh#L77-L78"><code>run.sh</code></a></p>
<pre><code class="language-bash">#  Build the firmware with the Stub Library
make
</code></pre>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/run.sh#L84-L88"><code>run.sh</code></a></p>
<pre><code class="language-bash">#  Build the Rust Library
pushd rust
rustup default nightly
cargo build $rust_build_options
popd
</code></pre>
<p>TODO</p>
<pre><code class="language-bash">cargo build \
    --target riscv32imacf-unknown-none-elf.json \
    -Z build-std=core
</code></pre>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/run.sh#L90-L94"><code>run.sh</code></a></p>
<pre><code class="language-bash">#  Replace the Stub Library by the compiled Rust Library
#  Stub Library: build_out/rust-app/librust-app.a
#  Rust Library: rust/target/riscv32imacf-unknown-none-elf/debug/libapp.a
ls -l $rust_app_build
cp $rust_app_build $rust_app_dest
</code></pre>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/run.sh#L100-L101"><code>run.sh</code></a></p>
<pre><code class="language-bash">#  Link the Rust Library to the firmware
make
</code></pre>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/run.sh#L110-L124"><code>run.sh</code></a></p>
<pre><code class="language-bash">#  Copy firmware to blflash
cp build_out/$APP_NAME.bin $BLFLASH_PATH

#  Flash the firmware
pushd $BLFLASH_PATH
cargo run flash $APP_NAME.bin \
    --port /dev/tty.usbserial-14* \
    --initial-baud-rate 230400 \
    --baud-rate 230400
sleep 5
popd
</code></pre>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/run.sh#L130-L131"><code>run.sh</code></a></p>
<pre><code class="language-bash">#  Run the firmware
open -a CoolTerm
</code></pre>
<h1 id="run-the-bl602-rust-firmware" class="section-header"><a href="#run-the-bl602-rust-firmware">6 Run the BL602 Rust Firmware</a></h1>
<p>TODO</p>
<pre><code class="language-text"># help
====Build-in Commands====
====Support 4 cmds once, seperate by ; ====
help                     : print this
p                        : print memory
m                        : modify memory
echo                     : echo for command
exit                     : close CLI
devname                  : print device name
sysver                   : system version
reboot                   : reboot system
poweroff                 : poweroff system
reset                    : system reset
time                     : system time
ota                      : system ota
ps                       : thread dump
ls                       : file list
hexdump                  : dump file
cat                      : cat file

====User Commands====
rust_main                : Run Rust code
blogset                  : blog pri set level
blogdump                 : blog info dump
bl_sys_time_now          : sys time now

# rust_main
Hello from Rust!

# rust_main
Hello from Rust!

# rust_main
Hello from Rust!
</code></pre>
<h1 id="rust-targets" class="section-header"><a href="#rust-targets">7 Rust Targets</a></h1>
<p>TODO</p>
<pre><code class="language-bash">cargo build \
    --target riscv32imac-unknown-none-elf
</code></pre>
<p>TODO</p>
<pre><code class="language-bash">rustc --print target-list
</code></pre>
<p><a href="https://docs.rust-embedded.org/embedonomicon/compiler-support.html#built-in-target">Built-In Rust Target</a></p>
<p>TODO</p>
<pre><code class="language-text">riscv32gc-unknown-linux-gnu
riscv32gc-unknown-linux-musl
riscv32i-unknown-none-elf
riscv32imac-unknown-none-elf
riscv32imc-unknown-none-elf
riscv64gc-unknown-linux-gnu
riscv64gc-unknown-linux-musl
riscv64gc-unknown-none-elf
riscv64imac-unknown-none-elf
</code></pre>
<p>TODO</p>
<pre><code class="language-text">can't link soft-float modules with single-float modules
</code></pre>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/rust-target.png" alt="BL602 Target is riscv32-imacfx" /></p>
<p>riscv32-imacfx</p>
<p><a href="https://en.wikipedia.org/wiki/RISC-V#ISA_base_and_extensions">RISC-V ISA Base and Extensions</a></p>
<p><img src="https://lupyuen.github.io/images/rust-riscv.png" alt="RISC-V ISA Base and Extensions" /></p>
<pre><code class="language-bash">gcc -march=rv32imfc -mabi=ilp32f ...
</code></pre>
<h1 id="custom-rust-target-for-bl602" class="section-header"><a href="#custom-rust-target-for-bl602">8 Custom Rust Target for BL602</a></h1>
<p>TODO</p>
<p><a href="https://docs.rust-embedded.org/embedonomicon/custom-target.html">Custom Rust Target</a></p>
<p>Building with our Custom Rust Target...</p>
<pre><code class="language-bash">cargo build \
    --target riscv32imacf-unknown-none-elf.json \
    -Z build-std=core
</code></pre>
<p>Changes to the Built-In Rust Target...</p>
<pre><code class="language-text">&quot;features&quot;: &quot;+m,+a,+c,+f&quot;,
</code></pre>
<p>And</p>
<pre><code class="language-text">&quot;llvm-abiname&quot;: &quot;ilp32f&quot;,
</code></pre>
<p>Dumping the Built-In Rust Target...</p>
<pre><code class="language-bash">rustc +nightly \
    -Z unstable-options \
    --print target-spec-json \
    --target riscv32imac-unknown-none-elf
</code></pre>
<p>This produces <a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/riscv32imac-unknown-none-elf.json">riscv32imac-unknown-none-elf.json</a></p>
<p>Here's our Custom Rust Target:</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/rust/customer_app/sdk_app_rust/riscv32imacf-unknown-none-elf.json">From <code>riscv32imacf-unknown-none-elf.json</code></a></p>
<pre><code class="language-json">{
  &quot;arch&quot;: &quot;riscv32&quot;,
  &quot;cpu&quot;: &quot;generic-rv32&quot;,
  &quot;data-layout&quot;: &quot;e-m:e-p:32:32-i64:64-n32-S128&quot;,
  &quot;eh-frame-header&quot;: false,
  &quot;emit-debug-gdb-scripts&quot;: false,
  &quot;executables&quot;: true,
  &quot;features&quot;: &quot;+m,+a,+c,+f&quot;,
  &quot;is-builtin&quot;: true,
  &quot;linker&quot;: &quot;rust-lld&quot;,
  &quot;linker-flavor&quot;: &quot;ld.lld&quot;,
  &quot;llvm-abiname&quot;: &quot;ilp32f&quot;,
  &quot;llvm-target&quot;: &quot;riscv32&quot;,
  &quot;max-atomic-width&quot;: 32,
  &quot;panic-strategy&quot;: &quot;abort&quot;,
  &quot;relocation-model&quot;: &quot;static&quot;,
  &quot;target-pointer-width&quot;: &quot;32&quot;,
  &quot;unsupported-abis&quot;: [
    &quot;cdecl&quot;,
    &quot;stdcall&quot;,
    &quot;stdcall-unwind&quot;,
    &quot;fastcall&quot;,
    &quot;vectorcall&quot;,
    &quot;thiscall&quot;,
    &quot;thiscall-unwind&quot;,
    &quot;aapcs&quot;,
    &quot;win64&quot;,
    &quot;sysv64&quot;,
    &quot;ptx-kernel&quot;,
    &quot;msp430-interrupt&quot;,
    &quot;x86-interrupt&quot;,
    &quot;amdgpu-kernel&quot;
  ]
}
</code></pre>
<h1 id="rust-on-bl602-two-more-ways" class="section-header"><a href="#rust-on-bl602-two-more-ways">9 Rust On BL602: Two More Ways</a></h1>
<p>TODO</p>
<p><a href="https://github.com/sipeed/bl602-rust-guide"><code>sipeed/bl602-rust-guide</code></a></p>
<p><a href="https://github.com/9names/bl602-rust-example"><code>9names/bl602-rust-example</code></a></p>
<p><a href="https://github.com/9names/bl602-rom-wrapper"><code>9names/bl602-rom-wrapper</code></a></p>
<h1 id="apache-nuttx-on-bl602" class="section-header"><a href="#apache-nuttx-on-bl602">10 Apache NuttX on BL602</a></h1>
<p>TODO</p>
<p><a href="https://github.com/bouffalolab/incubator-nuttx/tree/master/arch/risc-v/src/bl602">NuttX on BL602</a></p>
<p><a href="https://www.reddit.com/r/rust/comments/mbgujl/rust_integration_on_nuttx/">Rust on NuttX</a></p>
<p><em>What about Rust on Apache Mynewt?</em></p>
<p>TODO</p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">11 What's Next</a></h1>
<p>TODO</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read &quot;The RISC-V BL602 Book&quot;</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here...</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/rust.md"><code>lupyuen.github.io/src/rust.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">12 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1383219945308184578">this Twitter Thread</a></li>
</ol>
<p><img src="https://lupyuen.github.io/images/rust-crab.jpg" alt="PineCone BL602 RISC-V Board" /></p>

    
</body>
</html>