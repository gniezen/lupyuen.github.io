<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>NuttX RTOS for PinePhone: Display Driver in Zig</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="NuttX RTOS for PinePhone: Display Driver in Zig" 
    data-rh="true">
<meta property="og:description" 
    content="Let's build a PinePhone Display Driver in Zig... That will run on Apache NuttX RTOS"
    data-rh="true">
<meta name="description" 
    content="Let's build a PinePhone Display Driver in Zig... That will run on Apache NuttX RTOS">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/dsi2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">NuttX RTOS for PinePhone: Display Driver in Zig</h1>
    <nav id="TOC"><ul>
<li><a href="#pinephone-lcd-display">1 PinePhone LCD Display</a><ul></ul></li>
<li><a href="#long-packet-for-mipi-dsi">2 Long Packet for MIPI DSI</a><ul></ul></li>
<li><a href="#compose-long-packet">3 Compose Long Packet</a><ul>
<li><a href="#packet-header">3.1 Packet Header</a><ul></ul></li>
<li><a href="#packet-payload">3.2 Packet Payload</a><ul></ul></li>
<li><a href="#packet-footer">3.3 Packet Footer</a><ul></ul></li>
<li><a href="#combine-header-payload-and-footer">3.4 Combine Header, Payload and Footer</a><ul></ul></li></ul></li>
<li><a href="#error-correction-code">4 Error Correction Code</a><ul></ul></li>
<li><a href="#compose-short-packet">5 Compose Short Packet</a><ul></ul></li>
<li><a href="#test-pinephone-mipi-dsi-driver-with-qemu">6 Test PinePhone MIPI DSI Driver with QEMU</a><ul></ul></li>
<li><a href="#test-case-for-pinephone-mipi-dsi-driver">7 Test Case for PinePhone MIPI DSI Driver</a><ul></ul></li>
<li><a href="#initialise-st7703-lcd-controller-in-zig">8 Initialise ST7703 LCD Controller in Zig</a><ul></ul></li>
<li><a href="#test-zig-display-driver-for-pinephone">9 Test Zig Display Driver for PinePhone</a><ul></ul></li>
<li><a href="#whats-next">10 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-zig-on-pinephone">11 Appendix: Zig on PinePhone</a><ul></ul></li>
<li><a href="#appendix-cyclic-redundancy-check">12 Appendix: Cyclic Redundancy Check</a><ul></ul></li></ul></nav><p>üìù <em>17 Oct 2022</em></p>
<p><img src="https://lupyuen.github.io/images/dsi2-title.jpg" alt="Apache NuttX RTOS rendering something on PinePhone‚Äôs LCD Display" /></p>
<p>In our last article we talked about <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a> (pic above) and its <a href="https://lupyuen.github.io/articles/dsi#xingbangda-xbd599-lcd-panel"><strong>LCD Display</strong></a>, connected via the (super complicated) <a href="https://lupyuen.github.io/articles/dsi#connector-for-mipi-dsi"><strong>MIPI Display Serial Interface</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></li>
</ul>
<p>Today we shall create a <strong>PinePhone Display Driver in Zig</strong>‚Ä¶ That will run on our fresh new port of <a href="https://lupyuen.github.io/articles/uboot"><strong>Apache NuttX RTOS</strong></a> for PinePhone.</p>
<p>If we‚Äôre not familiar with Zig: No worries! This article will explain the tricky Zig parts with C.</p>
<p><em>Why build the Display Driver in Zig? Instead of C?</em></p>
<p>Sadly some parts of PinePhone‚Äôs <a href="https://lupyuen.github.io/articles/dsi#sitronix-st7703-lcd-controller"><strong>ST7703 LCD Controller</strong></a> and <a href="https://lupyuen.github.io/articles/dsi#initialise-mipi-dsi"><strong>Allwinner A64 SoC</strong></a> are poorly documented. (Sigh)</p>
<p>Thus we‚Äôre building a <strong>Quick Prototype</strong> in Zig to be sure we‚Äôre setting the Hardware Registers correctly.</p>
<p>And while rushing through the reckless coding, it‚Äôs great to have Zig cover our backs and catch <a href="https://ziglang.org/documentation/master/#Undefined-Behavior"><strong>Common Runtime Problems</strong></a>.</p>
<p>Like Null Pointers, Underflow, Overflow, Array Out Of Bounds, ‚Ä¶</p>
<p><em>Will our final driver be in Zig or C?</em></p>
<p>Maybe Zig, maybe C?</p>
<p>It‚Äôs awfully nice to use Zig to simplify the complicated driver code. Zig‚Äôs <a href="https://ziglang.org/documentation/master/#Undefined-Behavior"><strong>Runtime Safety Checks</strong></a> are extremely helpful too.</p>
<p>But this driver goes into the <strong>NuttX RTOS Kernel</strong>. So most folks would expect the final driver to be delivered in C?</p>
<p>In any case, Zig and C look highly similar. Converting the Zig Driver to C should be straightforward.</p>
<p>(Minus the Runtime Safety Checks)</p>
<p>Zig or C? Lemme know what you think! üôè</p>
<p>Let‚Äôs continue the journey from our <strong>NuttX Porting Journal</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>lupyuen/pinephone-nuttx</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/dsi-title.jpg" alt="LCD Display on PinePhone Schematic (Page 2)" /></p>
<p><a href="https://files.pine64.org/doc/PinePhone/PinePhone%20v1.2b%20Released%20Schematic.pdf"><em>LCD Display on PinePhone Schematic (Page 2)</em></a></p>
<h1 id="pinephone-lcd-display"><a href="#pinephone-lcd-display">1 PinePhone LCD Display</a></h1>
<p><em>How is the LCD Display connected inside PinePhone?</em></p>
<p>Inside PinePhone is a <strong>XBD599 LCD Panel</strong> by Xingbangda (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi#xingbangda-xbd599-lcd-panel"><strong>‚ÄúXingbangda XBD599 LCD Panel‚Äù</strong></a></li>
</ul>
<p>The LCD Display is connected to the <a href="https://linux-sunxi.org/A64"><strong>Allwinner A64 SoC</strong></a> via a <strong>MIPI Display Serial Interface (DSI)</strong>.</p>
<p><a href="https://en.wikipedia.org/wiki/MIPI_Alliance">(MIPI is the <strong>Mobile Industry Processor Interface Alliance</strong>)</a></p>
<p><em>What‚Äôs a MIPI Display Serial Interface?</em></p>
<p>Think of it as SPI, but supercharged with <strong>Multiple Data Lanes</strong>!</p>
<p>PinePhone‚Äôs MIPI Display Serial Interface runs on <strong>4 Data Lanes</strong> that will transmit 4 streams of pixel data concurrently.</p>
<p><a href="https://en.wikipedia.org/wiki/Display_Serial_Interface">(More about Display Serial Interface)</a></p>
<p><em>How do we control PinePhone‚Äôs LCD Display?</em></p>
<p>The XBD599 LCD Panel has a <strong>Sitronix ST7703 LCD Controller</strong> inside‚Ä¶</p>
<ul>
<li><a href="https://files.pine64.org/doc/datasheet/pinephone/ST7703_DS_v01_20160128.pdf"><strong>Sitronix ST7703 LCD Controller Datasheet</strong></a></li>
</ul>
<p>Which means our PinePhone Display Driver shall <strong>send commands to the ST7703 LCD Controller</strong> over the MIPI Display Serial Interface.</p>
<p><em>What commands will our Display Driver send to ST7703?</em></p>
<p>At startup, our driver shall send these 20 <strong>Initialisation Commands</strong> to the ST7703 LCD Controller‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi#appendix-initialise-lcd-controller"><strong>‚ÄúInitialise LCD Controller‚Äù</strong></a></li>
</ul>
<p>ST7703 Commands can be a single byte, like for <strong>‚ÄúDisplay On‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>29</code></pre></div>
<p>Or a few bytes, like for <strong>‚ÄúEnable User Command‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>B9 F1 12 83</code></pre></div>
<p>And up to <strong>64 bytes</strong> (for ‚ÄúSet Forward GIP Timing‚Äù)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>E9 82 10 06 05 A2 0A A5 
12 31 23 37 83 04 BC 27 
38 0C 00 03 00 00 00 0C 
00 03 00 00 00 75 75 31 
88 88 88 88 88 88 13 88 
64 64 20 88 88 88 88 88 
88 02 88 00 00 00 00 00 
00 00 00 00 00 00 00 00 </code></pre></div>
<p>We‚Äôll send these 20 commands to ST7703 in a specific packet format‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi-packet.png" alt="MIPI DSI Long Packet (Page 203)" /></p>
<p><a href="https://github.com/sipeed/sipeed2022_autumn_competition/blob/main/assets/BL808_RM_en.pdf"><em>MIPI DSI Long Packet (Page 203)</em></a></p>
<h1 id="long-packet-for-mipi-dsi"><a href="#long-packet-for-mipi-dsi">2 Long Packet for MIPI DSI</a></h1>
<p>To send a command to the ST7703 LCD Controller, we‚Äôll transmit a <a href="https://lupyuen.github.io/articles/dsi#long-packet-for-mipi-dsi"><strong>MIPI DSI Long Packet</strong></a> in this format (pic above)‚Ä¶</p>
<p><strong>Packet Header</strong> (4 bytes):</p>
<ul>
<li>
<p><strong>Data Identifier (DI)</strong> (1 byte):</p>
<p>Virtual Channel Identifier (Bits 6 to 7)</p>
<p>Data Type (Bits 0 to 5)</p>
</li>
<li>
<p><strong>Word Count (WC)</strong> (2 bytes)Ôºö</p>
<p>Number of bytes in the Packet Payload</p>
</li>
<li>
<p><strong>Error Correction Code (ECC)</strong> (1 byte):</p>
<p>Allow single-bit errors to be corrected and 2-bit errors to be detected in the Packet Header</p>
</li>
</ul>
<p><strong>Packet Payload:</strong></p>
<ul>
<li>
<p><strong>Data</strong> (0 to 65,541 bytes):</p>
<p>Number of data bytes should match the Word Count (WC)</p>
</li>
</ul>
<p><strong>Packet Footer:</strong></p>
<ul>
<li>
<p><strong>Checksum (CS)</strong> (2 bytes):</p>
<p>16-bit Cyclic Redundancy Check (CCITT CRC)</p>
</li>
</ul>
<p>Let‚Äôs do this in Zig‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi2-code1.png" alt="Compose Long Packet in Zig" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L47-L111">(Source)</a></p>
<h1 id="compose-long-packet"><a href="#compose-long-packet">3 Compose Long Packet</a></h1>
<p>Now we look at our <strong>Zig Function</strong> that composes a <strong>Long Packet</strong> for MIPI Display Serial Interface: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L47-L111">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Compose MIPI DSI Long Packet.
// See https://lupyuen.github.io/articles/dsi#long-packet-for-mipi-dsi
fn composeLongPacket(
  pkt:     []u8,  // Buffer for the Returned Long Packet
  channel: u8,    // Virtual Channel ID
  cmd:     u8,    // DCS Command
  buf:     [*c]const u8,  // Transmit Buffer
  len:     usize          // Buffer Length
) []const u8 {  // Returns the Long Packet
  ...</code></pre></div>
<p>(<strong><code>u8</code></strong> in Zig is the same as <strong><code>uint8_t</code></strong> in C)</p>
<p>Our Zig Function <strong><code>composeLongPacket</code></strong> accepts the following parameters‚Ä¶</p>
<ul>
<li>
<p><strong><code>pkt</code></strong>: This is the buffer that we‚Äôll use to write the Long Packet and return it.</p>
<p>It‚Äôs declared as ‚Äú<strong><code>[]u8</code></strong>‚Äù which is a Slice of Bytes, roughly similar to ‚Äú<strong><code>uint8_t *</code></strong>‚Äù in C.</p>
<p>(Except that the Buffer Size is also passed in the Slice)</p>
</li>
<li>
<p><strong><code>channel</code></strong>: MIPI Display Serial Interface supports multiple Virtual Channels, we‚Äôll stick to <strong>Virtual Channel 0</strong> for today</p>
</li>
<li>
<p><strong><code>cmd</code></strong>: Refers to the <a href="https://lupyuen.github.io/articles/dsi#display-command-set-for-mipi-dsi"><strong>Display Command Set (DCS)</strong></a> that we‚Äôll send over the MIPI Display Serial Interface.</p>
<p>For Long Packets, we‚Äôll send the <a href="https://lupyuen.github.io/articles/dsi#display-command-set-for-mipi-dsi"><strong>DCS Long Write Command</strong></a>. (Which has Data Type <code>0x39</code>)</p>
<p>(Later we‚Äôll see the DCS Short Write Command)</p>
</li>
<li>
<p><strong><code>buf</code></strong>: This is a C Pointer to the <strong>Transmit Buffer</strong> that will be packed inside the Long Packet. (As Packet Payload)</p>
<p>It‚Äôs declared as ‚Äú<strong><code>[*c]const u8</code></strong>‚Äù, which is the same as ‚Äú<strong><code>const uint8_t *</code></strong>‚Äù in C.</p>
<p>(‚Äú<strong><code>[*c]</code></strong>‚Äù means that Zig will handle it as a C Pointer)</p>
</li>
<li>
<p><strong><code>len</code></strong>: Number of bytes in the <strong>Transmit Buffer</strong></p>
</li>
</ul>
<p>Our Zig Function <strong><code>composeLongPacket</code></strong> returns a Slice of Bytes that will contain the Long Packet.</p>
<p>(Declared as ‚Äú<strong><code>[]const u8</code></strong>‚Äù. Yep the returned Slice will be a Sub-Slice of <strong><code>pkt</code></strong>)</p>
<p><em>Why do we mix Slices and Pointers in the Parameters?</em></p>
<p>The parameters <strong><code>buf</code></strong> and <strong><code>len</code></strong> could have been passed as a Byte Slice in Zig‚Ä¶</p>
<p>Instead we‚Äôre passing as an old-school <strong>C Pointer</strong> so that it‚Äôs compatible with the <strong>C Interface</strong> for our function‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// (Eventual) C Interface for our function
ssize_t mipi_dsi_dcs_write(
  const struct device *dev,  // MIPI DSI Device
  uint8_t     channel,  // Virtual Channel ID
  uint8_t     cmd,      // DCS Command
  const void *buf,      // Transmit Buffer
  size_t      len       // Buffer Length
);</code></pre></div>
<p>This C Interface is identical to the implementation of <strong>MIPI DSI in Zephyr OS</strong>. <a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/include/zephyr/drivers/mipi_dsi.h#L325-L337">(See this)</a></p>
<p>Let‚Äôs compose the Packet Header‚Ä¶</p>
<h2 id="packet-header"><a href="#packet-header">3.1 Packet Header</a></h2>
<p>The <strong>Packet Header</strong> (4 bytes) of our Long Packet will contain‚Ä¶</p>
<ul>
<li>
<p><strong>Data Identifier (DI)</strong> (1 byte):</p>
<p>Virtual Channel Identifier (Bits 6 to 7)</p>
<p>Data Type (Bits 0 to 5)</p>
<p>(Data Type is the DCS Command)</p>
</li>
<li>
<p><strong>Word Count (WC)</strong> (2 bytes)Ôºö</p>
<p>Number of bytes in the Packet Payload</p>
</li>
<li>
<p><strong>Error Correction Code (ECC)</strong> (1 byte):</p>
<p>Allow single-bit errors to be corrected and 2-bit errors to be detected in the Packet Header</p>
</li>
</ul>
<p>This is how we compose the <strong>Packet Header</strong>: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L47-L81">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data Identifier (DI) (1 byte):
  // - Virtual Channel Identifier (Bits 6 to 7)
  // - Data Type (Bits 0 to 5)
  assert(channel &lt; 4);
  assert(cmd &lt; (1 &lt;&lt; 6));
  const vc: u8 = channel;
  const dt: u8 = cmd;
  const di: u8 = (vc &lt;&lt; 6) | dt;</code></pre></div>
<p>First we populate the <strong>Data Indentifier (DI)</strong> with the Virtual Channel and DCS Command.</p>
<p>Then we convert the 16-bit <strong>Word Count (WC)</strong> to bytes‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Word Count (WC) (2 bytes)Ôºö
  // Number of bytes in the Packet Payload
  const wc: u16 = @intCast(u16, len);
  const wcl: u8 = @intCast(u8, wc &amp; 0xff);
  const wch: u8 = @intCast(u8, wc &gt;&gt; 8);</code></pre></div>
<p>(<a href="https://ziglang.org/documentation/master/#intCast"><strong><code>@intCast</code></strong></a> will halt with a Runtime Panic if <strong><code>len</code></strong> is too big to be converted into a 16-bit unsigned integer <strong><code>u16</code></strong>)</p>
<p>Next comes the <strong>Error Correction Code (ECC)</strong>. Which we compute based on the Data Identifier and Word Count‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data Identifier + Word Count (3 bytes): 
  // For computing Error Correction Code (ECC)
  const di_wc = [3]u8 { di, wcl, wch };

  // Compute Error Correction Code (ECC) for
  // Data Identifier + Word Count
  const ecc: u8 = computeEcc(di_wc);</code></pre></div>
<p>(‚Äú<strong><code>[3]u8</code></strong>‚Äù allocates a 3-byte array from the stack)</p>
<p>We‚Äôll cover <strong><code>computeEcc</code></strong> in a while.</p>
<p>Finally we pack everything into our 4-byte <strong>Packet Header</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Packet Header (4 bytes):
  // Data Identifier + Word Count + Error Correction Code
  const header = [4]u8 { 
    di_wc[0],  // Data Identifier
    di_wc[1],  // Word Count (Low Byte)
    di_wc[2],  // Word Count (High Byte)
    ecc        // Error Correction Code
  };</code></pre></div>
<p>Moving on to the Packet Payload‚Ä¶</p>
<h2 id="packet-payload"><a href="#packet-payload">3.2 Packet Payload</a></h2>
<p>Remember that our <strong>Packet Payload</strong> is passed in as C-style <strong><code>buf</code></strong> (Buffer Pointer) and <strong><code>len</code></strong> (Buffer Length)?</p>
<p>This is how we convert the Packet Payload to a <strong>Byte Slice</strong>: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L81-L87">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>  // Packet Payload:
  // Data (0 to 65,541 bytes).
  // Number of data bytes should match the Word Count (WC)
  assert(len &lt;= 65_541);

  // Convert to Byte Slice
  const payload = buf[0..len];</code></pre></div>
<p>We‚Äôll concatenate the Packet Payload with the Header and Footer in a while.</p>
<p>(Packet Header and Footer are also Byte Slices)</p>
<p>From this code it‚Äôs clear that a <a href="https://ziglang.org/documentation/master/#Slices"><strong>Zig Slice</strong></a> is nothing more than a <strong>Pointer</strong> and a <strong>Length</strong>‚Ä¶ It‚Äôs the tidier and safer way to pass buffers in Zig!</p>
<h2 id="packet-footer"><a href="#packet-footer">3.3 Packet Footer</a></h2>
<p>At the end of our Long Packet is the <strong>Packet Footer</strong>: A 16-bit <strong>Cyclic Redundancy Check</strong> (CCITT CRC).</p>
<p>This is how we compute the CRC: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L87-L97">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>  // Checksum (CS) (2 bytes):
  // 16-bit Cyclic Redundancy Check (CRC) of the Payload
  // (not the entire packet)
  const cs: u16 = computeCrc(payload);</code></pre></div>
<p>(<strong><code>computeCrc</code></strong> is explained in the Appendix)</p>
<p>The CRC goes into the 2-byte <strong>Packet Footer</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Convert CRC to 2 bytes
  const csl: u8 = @intCast(u8, cs &amp; 0xff);
  const csh: u8 = @intCast(u8, cs &gt;&gt; 8);

  // Packet Footer (2 bytes):
  // Checksum (CS)
  const footer = [2]u8 { csl, csh };</code></pre></div>
<p>Finally we‚Äôre ready to put the Header, Payload and Footer together!</p>
<h2 id="combine-header-payload-and-footer"><a href="#combine-header-payload-and-footer">3.4 Combine Header, Payload and Footer</a></h2>
<p>Our Long Packet will contain‚Ä¶</p>
<ul>
<li>
<p><strong>Packet Header</strong> (4 bytes)</p>
</li>
<li>
<p><strong>Packet Payload</strong> (<code>len</code> bytes)</p>
</li>
<li>
<p><strong>Packet Footer</strong> (2 bytes)</p>
</li>
</ul>
<p>Let‚Äôs combine the <strong>Header, Payload and Footer</strong>: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L97-L112">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>  // Verify the Packet Buffer Length
  const pktlen = header.len + len + footer.len;
  assert(pktlen &lt;= pkt.len);  // Increase `pkt` size if this fails

  // Copy Header to Packet Buffer
  std.mem.copy(
    u8,                  // Type
    pkt[0..header.len],  // Destination
    &amp;header              // Source (4 bytes)
  );

  // Copy Payload to Packet Buffer
  // (After the Header)
  std.mem.copy(
    u8,                  // Type
    pkt[header.len..],   // Destination
    payload              // Source (`len` bytes)
  );

  // Copy Footer to Packet Buffer
  // (After the Payload)
  std.mem.copy(
    u8,                  // Type
    pkt[(header.len + len)..],  // Destination
    &amp;footer              // Source (2 bytes)
  );</code></pre></div>
<p>(<a href="https://ziglang.org/documentation/master/std/#root;mem.copy"><strong><code>std.mem.copy</code></strong></a> copies one Slice to another. It works like <strong><code>memcpy</code></strong> in C)</p>
<p>And we return the Byte Slice that contains our Long Packet, sized accordingly‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Return the packet
  const result = pkt[0..pktlen];
  return result;
}</code></pre></div>
<p>That‚Äôs how we compose a MIPI DSI Long Packet in Zig!</p>
<p><img src="https://lupyuen.github.io/images/dsi2-ecc.png" alt="MIPI DSI Error Correction Code (Page 209)" /></p>
<p><a href="https://github.com/sipeed/sipeed2022_autumn_competition/blob/main/assets/BL808_RM_en.pdf"><em>MIPI DSI Error Correction Code (Page 209)</em></a></p>
<h1 id="error-correction-code"><a href="#error-correction-code">4 Error Correction Code</a></h1>
<p>Earlier we talked about computing the <strong>Error Correction Code (ECC)</strong> for the Packet Header‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi2#packet-header"><strong>‚ÄúPacket Header‚Äù</strong></a></li>
</ul>
<p>The <strong>8-bit ECC</strong> shall be computed with this (magic) formula: <a href="https://github.com/sipeed/sipeed2022_autumn_competition/blob/main/assets/BL808_RM_en.pdf">(Page 209)</a></p>
<div class="example-wrap"><pre class="language-text"><code>ECC[7] = 0
ECC[6] = 0
ECC[5] = D10^D11^D12^D13^D14^D15^D16^D17^D18^D19^D21^D22^D23
ECC[4] = D4^D5^D6^D7^D8^D9^D16^D17^D18^D19^D20^D22^D23
ECC[3] = D1^D2^D3^D7^D8^D9^D13^D14^D15^D19^D20^D21^D23
ECC[2] = D0^D2^D3^D5^D6^D9^D11^D12^D15^D18^D20^D21^D22
ECC[1] = D0^D1^D3^D4^D6^D8^D10^D12^D14^D17^D20^D21^D22^D23
ECC[0] = D0^D1^D2^D4^D5^D7^D10^D11^D13^D16^D20^D21^D22^D23</code></pre></div>
<p>(‚Äú<strong><code>^</code></strong>‚Äù means Exclusive OR)</p>
<p>(<strong><code>D0</code></strong> to <strong><code>D23</code></strong> refer to the pic above)</p>
<p>This is how we compute the ECC: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L170-L211">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Compute the Error Correction Code (ECC) (1 byte):
/// Allow single-bit errors to be corrected and 2-bit errors to be detected in the Packet Header
/// See &quot;12.3.6.12: Error Correction Code&quot;, Page 208 of BL808 Reference Manual:
/// https://github.com/sipeed/sipeed2022_autumn_competition/blob/main/assets/BL808_RM_en.pdf
fn computeEcc(
  di_wc: [3]u8  // Data Identifier + Word Count (3 bytes)
) u8 {
  ...</code></pre></div>
<p>Our Zig Function <strong><code>computeEcc</code></strong> accepts a 3-byte array, containing the first 3 bytes of the Packet Header.</p>
<p>(‚Äú<strong><code>[3]u8</code></strong>‚Äù is equivalent to ‚Äú<strong><code>uint8_t[3]</code></strong>‚Äù in C)</p>
<p>We combine the 3 bytes into a <strong>24-bit word</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Combine DI and WC into a 24-bit word
  var di_wc_word: u32 = 
    di_wc[0] 
    | (@intCast(u32, di_wc[1]) &lt;&lt; 8)
    | (@intCast(u32, di_wc[2]) &lt;&lt; 16);</code></pre></div>
<p>Then we extract the 24 bits into <strong><code>d[0]</code></strong> to <strong><code>d[23]</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Allocate an array of 24 bits from the stack,
  // initialised to zeros
  var d = std.mem.zeroes([24]u1);

  // Extract the 24 bits from the word
  var i: usize = 0;
  while (i &lt; 24) : (i += 1) {
    d[i] = @intCast(u1, di_wc_word &amp; 1);
    di_wc_word &gt;&gt;= 1;
  }</code></pre></div>
<p>(<a href="https://ziglang.org/documentation/master/std/#root;mem.zeroes"><strong><code>std.mem.zeroes</code></strong></a> allocates an array from the stack, initialised to zeroes)</p>
<p>Note that we‚Äôre working with <strong>Bit Values</strong>‚Ä¶</p>
<ul>
<li>
<p>‚Äú<strong><code>u1</code></strong>‚Äù represents a Single Bit Value</p>
</li>
<li>
<p>‚Äú<strong><code>[24]u1</code></strong>‚Äù is an Array of 24 Bits</p>
</li>
</ul>
<p>We compute the <strong>ECC Bits</strong> according to the Magic Formula‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Allocate an array of 8 bits from the stack,
  // initialised to zeros
  var ecc = std.mem.zeroes([8]u1);

  // Compute the ECC bits
  ecc[7] = 0;
  ecc[6] = 0;
  ecc[5] = d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15] ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[21] ^ d[22] ^ d[23];
  ecc[4] = d[4]  ^ d[5]  ^ d[6]  ^ d[7]  ^ d[8]  ^ d[9]  ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[22] ^ d[23];
  ecc[3] = d[1]  ^ d[2]  ^ d[3]  ^ d[7]  ^ d[8]  ^ d[9]  ^ d[13] ^ d[14] ^ d[15] ^ d[19] ^ d[20] ^ d[21] ^ d[23];
  ecc[2] = d[0]  ^ d[2]  ^ d[3]  ^ d[5]  ^ d[6]  ^ d[9]  ^ d[11] ^ d[12] ^ d[15] ^ d[18] ^ d[20] ^ d[21] ^ d[22];
  ecc[1] = d[0]  ^ d[1]  ^ d[3]  ^ d[4]  ^ d[6]  ^ d[8]  ^ d[10] ^ d[12] ^ d[14] ^ d[17] ^ d[20] ^ d[21] ^ d[22] ^ d[23];
  ecc[0] = d[0]  ^ d[1]  ^ d[2]  ^ d[4]  ^ d[5]  ^ d[7]  ^ d[10] ^ d[11] ^ d[13] ^ d[16] ^ d[20] ^ d[21] ^ d[22] ^ d[23];</code></pre></div>
<p>Finally we <strong>merge the ECC Bits</strong> into a single byte and return it‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Merge the ECC bits
  return @intCast(u8, ecc[0])
    | (@intCast(u8, ecc[1]) &lt;&lt; 1)
    | (@intCast(u8, ecc[2]) &lt;&lt; 2)
    | (@intCast(u8, ecc[3]) &lt;&lt; 3)
    | (@intCast(u8, ecc[4]) &lt;&lt; 4)
    | (@intCast(u8, ecc[5]) &lt;&lt; 5)
    | (@intCast(u8, ecc[6]) &lt;&lt; 6)
    | (@intCast(u8, ecc[7]) &lt;&lt; 7);
}</code></pre></div>
<p>And we‚Äôre done with the Error Correction Code!</p>
<h1 id="compose-short-packet"><a href="#compose-short-packet">5 Compose Short Packet</a></h1>
<p><em>We‚Äôve seen the Long Packet. Is there a Short Packet?</em></p>
<p>Yep! If we‚Äôre transmitting 1 or 2 bytes to the ST7703 LCD Controller, we may send a <strong>MIPI DSI Short Packet</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi#appendix-short-packet-for-mipi-dsi"><strong>‚ÄúShort Packet for MIPI DSI‚Äù</strong></a></li>
</ul>
<p>A MIPI DSI Short Packet (compared with Long Packet)‚Ä¶</p>
<ul>
<li>
<p>Doesn‚Äôt have Packet Payload and Packet Footer (CRC)</p>
</li>
<li>
<p>Instead of Word Count (WC), the Packet Header now has 2 bytes of data</p>
</li>
<li>
<p>DCS Command (Data Type) is‚Ä¶</p>
<p><strong>DCS Short Write Without Parameter (<code>0x05</code>)</strong> for sending 1 byte of data</p>
<p><strong>DCS Short Write With Parameter (<code>0x15</code>)</strong> for sending 2 bytes of data</p>
</li>
<li>
<p>Everything else is the same</p>
</li>
</ul>
<p>This is how we <strong>compose a Short Packet</strong>: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L113-L168">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Compose MIPI DSI Short Packet. 
// See https://lupyuen.github.io/articles/dsi#appendix-short-packet-for-mipi-dsi
fn composeShortPacket(
  pkt:     []u8,    // Buffer for the Returned Short Packet
  channel: u8,      // Virtual Channel ID
  cmd:     u8,      // DCS Command
  buf:     [*c]const u8,  // Transmit Buffer
  len:     usize          // Buffer Length
) []const u8 {  // Returns the Short Packet
  
  // Short Packet can only have 1 or 2 data bytes
  assert(len == 1 or len == 2);</code></pre></div>
<p><strong><code>composeShortPacket</code></strong> accepts the same parameters as <strong><code>composeLongPacket</code></strong>.</p>
<p>We populate <strong>Data Indentifier (DI)</strong> the same way, with Virtual Channel and DCS Command‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data Identifier (DI) (1 byte):
  // - Virtual Channel Identifier (Bits 6 to 7)
  // - Data Type (Bits 0 to 5)
  assert(channel &lt; 4);
  assert(cmd &lt; (1 &lt;&lt; 6));
  const vc: u8 = channel;
  const dt: u8 = cmd;
  const di: u8 = (vc &lt;&lt; 6) | dt;</code></pre></div>
<p>Our <strong>Packet Header</strong> will include two bytes of data‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data (2 bytes), fill with 0 
  // if Second Byte is missing
  const data = [2]u8 {
    buf[0],                       // First Data Byte
    if (len == 2) buf[1] else 0,  // Second Data Byte
  };</code></pre></div>
<p>We compute the <strong>Error Correction Code (ECC)</strong> based on the Data Identifier and the two Data Bytes‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data Identifier + Data (3 bytes): 
  // For computing Error Correction Code (ECC)
  const di_data = [3]u8 { 
    di,       // Data Identifier
    data[0],  // First Data Byte
    data[1]   // Second Data Byte
  };

  // Compute Error Correction Code (ECC) 
  // for Data Identifier + Word Count
  const ecc: u8 = computeEcc(di_data);</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/dsi2#error-correction-code">(<strong><code>computeEcc</code></strong> is explained here)</a></p>
<p>We pack everything into our 4-byte <strong>Packet Header</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Packet Header (4 bytes):
  // Data Identifier + Data + Error Correction Code
  const header = [4]u8 { 
    di_data[0],  // Data Identifier
    di_data[1],  // First Data Byte
    di_data[2],  // Second Data Byte
    ecc          // Error Correction Code
  };</code></pre></div>
<p>We <strong>copy the Packet Header</strong> into our Packet Buffer‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Verify the Packet Buffer Length
  const pktlen = header.len;
  assert(pktlen &lt;= pkt.len);  // Increase `pkt` size

  // Copy Header to Packet Buffer
  std.mem.copy(
    u8,                  // Type
    pkt[0..header.len],  // Destination
    &amp;header              // Source (4 bytes)
  );</code></pre></div>
<p>And we return the Byte Slice that contains our Short Packet, sized accordingly‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Return the packet
  const result = pkt[0..pktlen];
  return result;
}</code></pre></div>
<p>We‚Äôre done with Long and Short Packets for MIPI DSI, let‚Äôs test them‚Ä¶</p>
<h1 id="test-pinephone-mipi-dsi-driver-with-qemu"><a href="#test-pinephone-mipi-dsi-driver-with-qemu">6 Test PinePhone MIPI DSI Driver with QEMU</a></h1>
<p>TODO</p>
<p>The above Zig Code for composing Long Packets and Short Packets was tested in QEMU for Arm64 with GIC Version 2‚Ä¶</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/tree/gicv2">lupyuen/incubator-nuttx/tree/gicv2</a></p>
<p>Here‚Äôs the NuttX Test Log for QEMU Arm64‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-11.0.0-RC2
nsh&gt; uname -a
NuttX 11.0.0-RC2 c938291 Oct  7 2022 16:54:31 arm64 qemu-a53

nsh&gt; null
HELLO ZIG ON PINEPHONE!
Testing Compose Short Packet (Without Parameter)...
composeShortPacket: channel=0, cmd=0x5, len=1
Result:
05 11 00 36 
Testing Compose Short Packet (With Parameter)...
composeShortPacket: channel=0, cmd=0x15, len=2
Result:
15 bc 4e 35 
Testing Compose Long Packet...
composeLongPacket: channel=0, cmd=0x39, len=64
Result:
39 40 00 25 e9 82 10 06 
05 a2 0a a5 12 31 23 37 
83 04 bc 27 38 0c 00 03 
00 00 00 0c 00 03 00 00 
00 75 75 31 88 88 88 88 
88 88 13 88 64 64 20 88 
88 88 88 88 88 02 88 00 
00 00 00 00 00 00 00 00 
00 00 00 00 65 03 </code></pre></div><h1 id="test-case-for-pinephone-mipi-dsi-driver"><a href="#test-case-for-pinephone-mipi-dsi-driver">7 Test Case for PinePhone MIPI DSI Driver</a></h1>
<p>TODO</p>
<p>This is how we write a Test Case for the PinePhone MIPI DSI Driver on NuttX‚Ä¶</p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L593-L639">display.zig</a></p>
<p>The above Test Case shows this output on QEMU Arm64‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Testing Compose Long Packet...
composeLongPacket: channel=0, cmd=0x39, len=64
Result:
39 40 00 25 e9 82 10 06 
05 a2 0a a5 12 31 23 37 
83 04 bc 27 38 0c 00 03 
00 00 00 0c 00 03 00 00 
00 75 75 31 88 88 88 88 
88 88 13 88 64 64 20 88 
88 88 88 88 88 02 88 00 
00 00 00 00 00 00 00 00 
00 00 00 00 65 03 </code></pre></div><h1 id="initialise-st7703-lcd-controller-in-zig"><a href="#initialise-st7703-lcd-controller-in-zig">8 Initialise ST7703 LCD Controller in Zig</a></h1>
<p>TODO</p>
<p>PinePhone‚Äôs ST7703 LCD Controller needs to be initialised with these 20 Commands‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi#initialise-lcd-controller">‚ÄúInitialise LCD Controller‚Äù</a></li>
</ul>
<p>This is how we send the 20 Commands with our NuttX Driver in Zig, as DCS Short Writes and DCS Long Writes‚Ä¶</p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L62-L429">display.zig</a></p>
<p>To send a command, <code>writeDcs</code> executes a DCS Short Write or DCS Long Write, depending on the length of the command‚Ä¶</p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L431-L453">display.zig</a></p>
<h1 id="test-zig-display-driver-for-pinephone"><a href="#test-zig-display-driver-for-pinephone">9 Test Zig Display Driver for PinePhone</a></h1>
<p>TODO</p>
<p>Our NuttX Zig Display Driver powers on the PinePhone Display and works exactly like the C Driver! üéâ</p>
<p><img src="https://lupyuen.github.io/images/dsi2-title.jpg" alt="Apache NuttX RTOS on PinePhone" /></p>
<p><em>Can our driver render graphics on PinePhone Display?</em></p>
<p>Our PinePhone Display Driver isn‚Äôt complete. It handles MIPI DSI (for initialising ST7703) but doesn‚Äôt support Allwinner A64‚Äôs Display Engine (DE) and Timing Controller (TCON), which are needed for rendering graphics.</p>
<p>We‚Äôll implement DE and TCON next.</p>
<h1 id="whats-next"><a href="#whats-next">10 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>There‚Äôs plenty to be done for NuttX on PinePhone, please lemme know if you would like to join me üôè</p>
<p>Check out the other articles on <strong>NuttX RTOS for PinePhone</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/arm"><strong>‚ÄúApache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/uboot"><strong>‚ÄúPinePhone boots Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/interrupt"><strong>‚ÄúNuttX RTOS for PinePhone: Fixing the Interrupts‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/serial"><strong>‚ÄúNuttX RTOS for PinePhone: UART Driver‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Current Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/dsi2.md"><strong>lupyuen.github.io/src/dsi2.md</strong></a></p>
<h1 id="appendix-zig-on-pinephone"><a href="#appendix-zig-on-pinephone">11 Appendix: Zig on PinePhone</a></h1>
<p>TODO</p>
<p><code>make --trace</code> shows these GCC Compiler Options when building Nuttx for PinePhone‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>aarch64-none-elf-gcc
  -c
  -fno-common
  -Wall
  -Wstrict-prototypes
  -Wshadow
  -Wundef
  -Werror
  -Os
  -fno-strict-aliasing
  -fomit-frame-pointer
  -g
  -march=armv8-a
  -mtune=cortex-a53
  -isystem &quot;/Users/Luppy/PinePhone/nuttx/nuttx/include&quot;
  -D__NuttX__ 
  -pipe
  -I &quot;/Users/Luppy/PinePhone/nuttx/apps/include&quot;
  -Dmain=hello_main  hello_main.c
  -o  hello_main.c.Users.Luppy.PinePhone.nuttx.apps.examples.hello.o</code></pre></div>
<p>Let‚Äôs run this Zig App: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig">display.zig</a></p>
<p>Enable the Null Example App: make menuconfig, select ‚ÄúApplication Configuration‚Äù &gt; ‚ÄúExamples‚Äù &gt; ‚ÄúNull Example‚Äù</p>
<p>Compile the Zig App (based on the above GCC Compiler Options)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>zig build-obj \
  -target aarch64-freestanding-none \
  -mcpu cortex_a53 \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  display.zig

cp display.o \
  $HOME/nuttx/apps/examples/null/*null.o

cd $HOME/nuttx/nuttx
make</code></pre></div>
<p>Run the Zig App‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; null
HELLO ZIG ON PINEPHONE!</code></pre></div><h1 id="appendix-cyclic-redundancy-check"><a href="#appendix-cyclic-redundancy-check">12 Appendix: Cyclic Redundancy Check</a></h1>
<p>TODO</p>
<p>This is how our PinePhone Display Driver computes the 16-bit Cyclic Redundancy Check (CCITT) in Zig‚Ä¶</p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L306-L366">display.zig</a></p>
<p>The Cyclic Redundancy Check is the 2-byte Packet Footer for Long Packets.</p>

    
</body>
</html>