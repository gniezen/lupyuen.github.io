<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Build an LVGL Touchscreen App with Zig</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Build an LVGL Touchscreen App with Zig" 
    data-rh="true">
<meta property="og:description" 
    content="Can we use Zig to build an LVGL Touchscreen App for Apache NuttX RTOS? Can we wrap the LVGL API in Zig to build simpler, safer LVGL Apps? Let's find out!"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/lvgl-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Build an LVGL Touchscreen App with Zig</h1>
    <nav id="TOC"><ul>
<li><a href="#lvgl-app-in-c">1 LVGL App in C</a><ul></ul></li>
<li><a href="#zig-lvgl-app">2 Zig LVGL App</a><ul></ul></li>
<li><a href="#zig-checks-null-pointers">3 Zig Checks Null Pointers</a><ul></ul></li>
<li><a href="#import-c-functions">4 Import C Functions</a><ul></ul></li>
<li><a href="#compile-zig-app">5 Compile Zig App</a><ul></ul></li>
<li><a href="#run-zig-app">6 Run Zig App</a><ul></ul></li>
<li><a href="#simplify-lvgl-api">7 Simplify LVGL API</a><ul></ul></li>
<li><a href="#wrap-lvgl-api">8 Wrap LVGL API</a><ul>
<li><a href="#get-active-screen">8.1 Get Active Screen</a><ul></ul></li>
<li><a href="#object-struct">8.2 Object Struct</a><ul></ul></li>
<li><a href="#label-struct">8.3 Label Struct</a><ul></ul></li>
<li><a href="#after-wrapping-lvgl">8.4 After Wrapping LVGL</a><ul></ul></li></ul></li>
<li><a href="#zig-vs-bit-fields">9 Zig vs Bit Fields</a><ul></ul></li>
<li><a href="#zig-outcomes">10 Zig Outcomes</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">12 Notes</a><ul></ul></li>
<li><a href="#appendix-compiler-options">13 Appendix: Compiler Options</a><ul></ul></li>
<li><a href="#appendix-auto-translate-lvgl-app-to-zig">14 Appendix: Auto-Translate LVGL App to Zig</a><ul></ul></li>
<li><a href="#appendix-zig-auto-translation-is-incomplete">15 Appendix: Zig Auto-Translation is Incomplete</a><ul></ul></li>
<li><a href="#appendix-zig-opaque-types">16 Appendix: Zig Opaque Types</a><ul>
<li><a href="#fix-opaque-types">16.1 Fix Opaque Types</a><ul></ul></li>
<li><a href="#input-driver">16.2 Input Driver</a><ul></ul></li>
<li><a href="#color-type">16.3 Color Type</a><ul></ul></li></ul></li>
<li><a href="#appendix-clean-up">17 Appendix: Clean Up</a><ul></ul></li>
<li><a href="#appendix-auto-generate-zig-wrapper">18 Appendix: Auto-Generate Zig Wrapper</a><ul>
<li><a href="#object-oriented-wrapper-for-lvgl">18.1 Object-Oriented Wrapper for LVGL</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>14 Jul 2022</em></p>
<p><img src="https://lupyuen.github.io/images/lvgl-title.jpg" alt="LVGL Touchscreen App on Pine64‚Äôs PineDio Stack BL604" /></p>
<p><a href="https://docs.lvgl.io/master/"><strong>LVGL</strong></a> is a popular <strong>GUI Library</strong> in C that powers the User Interfaces of many Embedded Devices. <a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/cloud#modify-the-pinetime-source-code">(Like smartwatches)</a></p>
<p><a href="https://ziglang.org"><strong>Zig</strong></a> is a new-ish Programming Language that works well with C. And it comes with built-in <a href="https://ziglang.org/documentation/master/#Undefined-Behavior"><strong>Safety Checks</strong></a> at runtime.</p>
<p><em>Can we use Zig to code an LVGL Touchscreen Application?</em></p>
<p><em>Maybe make LVGL a little safer and friendlier‚Ä¶ By wrapping the LVGL API in Zig?</em></p>
<p><em>Or will we get blocked by something beyond our control? (Like Bit Fields in LVGL Structs)</em></p>
<p>Let‚Äôs find out! We‚Äôll do this on Pine64‚Äôs <a href="https://lupyuen.github.io/articles/pinedio2"><strong>PineDio Stack BL604</strong></a> RISC-V Board (pic above) with <a href="https://lupyuen.github.io/articles/pinedio2"><strong>Apache NuttX RTOS</strong></a>.</p>
<p>(The steps will be similar for other platforms)</p>
<p>Join me as we dive into our <strong>LVGL Touchscreen App in Zig</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/zig-lvgl-nuttx"><strong>lupyuen/zig-lvgl-nuttx</strong></a></li>
</ul>
<p>(Spoilers: Answers are Yes, Maybe, Somewhat)</p>
<p><img src="https://lupyuen.github.io/images/lvgl-code1a.png" alt="LVGL App in C" /></p>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L107-L148">(Source)</a> </p>
<h1 id="lvgl-app-in-c"><a href="#lvgl-app-in-c">1 LVGL App in C</a></h1>
<p>We begin with a barebones <strong>LVGL App in C</strong> that renders a line of text‚Ä¶</p>
<ul>
<li>
<p>Fetch the <strong>Active Screen</strong> from LVGL</p>
</li>
<li>
<p>Create a <strong>Label Widget</strong></p>
</li>
<li>
<p>Set the <strong>Properties, Text and Position</strong> of the Label</p>
</li>
</ul>
<p>(Like the pic at the top of this article)</p>
<div class="example-wrap"><pre class="language-c"><code>static void create_widgets(void) {

  // Get the Active Screen
  lv_obj_t *screen = lv_scr_act();

  // Create a Label Widget
  lv_obj_t *label = lv_label_create(screen, NULL);

  // Wrap long lines in the label text
  lv_label_set_long_mode(label, LV_LABEL_LONG_BREAK);

  // Interpret color codes in the label text
  lv_label_set_recolor(label, true);

  // Center align the label text
  lv_label_set_align(label, LV_LABEL_ALIGN_CENTER);

  // Set the label text and colors
  lv_label_set_text(
    label, 
    &quot;#ff0000 HELLO# &quot;    //  Red Text
    &quot;#00aa00 PINEDIO# &quot;  //  Green Text
    &quot;#0000ff STACK!# &quot;   //  Blue Text
  );

  // Set the label width
  lv_obj_set_width(label, 200);

  // Align the label to the center of the screen, shift 30 pixels up
  lv_obj_align(label, NULL, LV_ALIGN_CENTER, 0, -30);

  // Omitted: LVGL Canvas (we&#39;ll find out why)
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L107-L148">(Source)</a> </p>
<p>Let‚Äôs convert this to Zig.</p>
<p><em>What if we‚Äôre not familiar with Zig?</em></p>
<p>The following sections assume that we‚Äôre familiar with C.</p>
<p>The parts that look Zig-ish shall be explained with examples in C.</p>
<p><a href="https://lupyuen.github.io/articles/pinephone#appendix-learning-zig">(If we‚Äôre keen to learn Zig, see this)</a></p>
<p><em>Where‚Äôs the rest of the code that initialises LVGL?</em></p>
<p>We hit some complications converting the code to Zig, more about this in a while.</p>
<p><img src="https://lupyuen.github.io/images/lvgl-code2a.png" alt="Zig LVGL App" /></p>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L114-L147">(Source)</a></p>
<h1 id="zig-lvgl-app"><a href="#zig-lvgl-app">2 Zig LVGL App</a></h1>
<p>Now the same LVGL App, but <strong>in Zig</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>fn createWidgetsUnwrapped() !void {

  // Get the Active Screen
  const screen = c.lv_scr_act().?;

  // Create a Label Widget
  const label = c.lv_label_create(screen, null).?;

  // Wrap long lines in the label text
  c.lv_label_set_long_mode(label, c.LV_LABEL_LONG_BREAK);

  // Interpret color codes in the label text
  c.lv_label_set_recolor(label, true);

  // Center align the label text
  c.lv_label_set_align(label, c.LV_LABEL_ALIGN_CENTER);

  // Set the label text and colors.
  // `++` is the operator that concatenates two strings or arrays.
  c.lv_label_set_text(
    label, 
    &quot;#ff0000 HELLO# &quot;   ++  // Red Text
    &quot;#00aa00 PINEDIO# &quot; ++  // Green Text
    &quot;#0000ff STACK!# &quot;      // Blue Text
  );

  // Set the label width
  c.lv_obj_set_width(label, 200);

  // Align the label to the center of the screen, shift 30 pixels up
  c.lv_obj_align(label, null, c.LV_ALIGN_CENTER, 0, -30);
}</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L114-L147">(Source)</a></p>
<p>Our Zig App calls the LVGL Functions imported from C, as denoted by ‚Äú<code>c.</code><em>something</em>‚Äù.</p>
<p><em>But this looks mighty similar to C!</em></p>
<p>Yep and we see that‚Ä¶</p>
<ul>
<li>
<p>We no longer specify <strong>Type Names</strong></p>
<p>(Like <strong>lv_obj_t</strong>)</p>
</li>
<li>
<p>We write ‚Äú<strong><code>.?</code></strong>‚Äù to catch <strong>Null Pointers</strong></p>
<p>(Coming up in the next section)</p>
</li>
</ul>
<p><em>What‚Äôs ‚Äú<code>!void</code>‚Äù?</em></p>
<p>‚Äú<strong><code>!void</code></strong>‚Äù is the Return Type for our Zig Function‚Ä¶</p>
<ul>
<li>
<p>Our Zig Function doesn‚Äôt return any value</p>
<p>(Hence ‚Äú<code>void</code>‚Äù)</p>
</li>
<li>
<p>But our function might return an <a href="https://ziglang.org/documentation/master/#Errors"><strong>Error</strong></a></p>
<p>(Hence the ‚Äú<code>!</code>‚Äù)</p>
</li>
</ul>
<p>Let‚Äôs talk about Null Pointers and Runtime Safety in Zig‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lvgl-code3a.png" alt="LVGL App: C vs Zig" /></p>
<h1 id="zig-checks-null-pointers"><a href="#zig-checks-null-pointers">3 Zig Checks Null Pointers</a></h1>
<p>Earlier we saw our Zig App calling the <strong>LVGL Functions</strong> imported from C‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Zig calls a C function
const disp_drv = c.get_disp_drv().?;</code></pre></div>
<p>Note that we write ‚Äú<strong><code>.?</code></strong>‚Äù to catch <strong>Null Pointers</strong> returned by C Functions.</p>
<p><em>What happens if the C Function returns a Null Pointer to Zig?</em></p>
<div class="example-wrap"><pre class="language-c"><code>// Suppose this C Function...
lv_disp_drv_t *get_disp_drv(void) {
  // Returns a Null Pointer to Zig
  return NULL;
}</code></pre></div>
<p>When we run this code, we‚Äôll see a <strong>Zig Panic</strong> and a Stack Trace‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>!ZIG PANIC!
attempt to use null value
Stack Trace:
0x23023606</code></pre></div>
<p>Looking up address <code>23023606</code> in the <a href="https://lupyuen.github.io/articles/auto#disassemble-the-firmware"><strong>RISC-V Disassembly</strong></a> for our firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>zig-lvgl-nuttx/lvgltest.zig:50
    const disp_drv = c.get_disp_drv().?;
230235f4: 23089537 lui   a0,0x23089
230235f8: 5ac50513 addi  a0,a0,1452 # 230895ac &lt;__unnamed_10&gt;
230235fc: 4581     li    a1,0
230235fe: 00000097 auipc ra,0x0
23023602: c92080e7 jalr  -878(ra) # 23023290 &lt;panic&gt;
23023606: ff042503 lw    a0,-16(s0)
2302360a: fea42623 sw    a0,-20(s0)</code></pre></div>
<p>We discover that <code>23023606</code> points to the line of code that caught the Null Pointer.</p>
<p>Hence Zig is super helpful for writing <strong>safer programs</strong>.</p>
<p><em>What if we omit ‚Äú<code>.?</code>‚Äù and do this?</em></p>
<div class="example-wrap"><pre class="language-zig"><code>const disp_drv = c.get_disp_drv();</code></pre></div>
<p>This crashes with a <strong>RISC-V Exception</strong> when our program tries to dereference the Null Pointer in a <strong>later part</strong> of the code.</p>
<p>Which isn‚Äôt as helpful as an immediate Zig Panic.</p>
<p>Thus we always write ‚Äú<code>.?</code>‚Äù to catch Null Pointers returned by C Functions.</p>
<p>(Hopefully someday we‚Äôll have a Zig Lint Tool that will warn us if we forget to use ‚Äú<code>.?</code>‚Äù)</p>
<p><img src="https://lupyuen.github.io/images/lvgl-code5a.png" alt="Import C Functions and Macros" /></p>
<h1 id="import-c-functions"><a href="#import-c-functions">4 Import C Functions</a></h1>
<p><em>How do we import the C Functions and Macros for LVGL?</em></p>
<p>This is how we <strong>import the Functions and Macros</strong> from C into Zig: <a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L9-L39">lvgltest.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import the LVGL Library from C
const c = @cImport({
  // NuttX Defines
  @cDefine(&quot;__NuttX__&quot;,  &quot;&quot;);
  @cDefine(&quot;NDEBUG&quot;,     &quot;&quot;);
  @cDefine(&quot;ARCH_RISCV&quot;, &quot;&quot;);
  @cDefine(&quot;LV_LVGL_H_INCLUDE_SIMPLE&quot;, &quot;&quot;);

  // This is equivalent to...
  // #define __NuttX__
  // #define NDEBUG
  // #define ARCH_RISCV
  // #define LV_LVGL_H_INCLUDE_SIMPLE</code></pre></div>
<p><a href="https://ziglang.org/documentation/master/#Import-from-C-Header-File">(<strong>@cImport</strong> is documented here)</a></p>
<p>At the top of our Zig App we set the <strong>#define Macros</strong> that will be referenced by the C Header Files coming up.</p>
<p>The settings above are specific to Apache NuttX RTOS and the BL602 RISC-V SoC. <a href="https://lupyuen.github.io/articles/lvgl#appendix-compiler-options">(Here‚Äôs why)</a></p>
<p>Next comes a workaround for a <strong>C Macro Error</strong> that appears on Zig with Apache NuttX RTOS‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Workaround for &quot;Unable to translate macro: undefined identifier `LL`&quot;
  @cDefine(&quot;LL&quot;, &quot;&quot;);
  @cDefine(&quot;__int_c_join(a, b)&quot;, &quot;a&quot;);  //  Bypass zig/lib/include/stdint.h</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-macro-error">(More about this)</a></p>
<p>We import the <strong>C Header Files</strong> for Apache NuttX RTOS‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // NuttX Header Files. This is equivalent to...
  // #include &quot;...&quot;;
  @cInclude(&quot;arch/types.h&quot;);
  @cInclude(&quot;../../nuttx/include/limits.h&quot;);
  @cInclude(&quot;stdio.h&quot;);
  @cInclude(&quot;nuttx/config.h&quot;);
  @cInclude(&quot;sys/boardctl.h&quot;);
  @cInclude(&quot;unistd.h&quot;);
  @cInclude(&quot;stddef.h&quot;);
  @cInclude(&quot;stdlib.h&quot;);</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-zig-compiler-as-drop-in-replacement-for-gcc">(More about the includes)</a></p>
<p>Followed by the C Header Files for the <strong>LVGL Library</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // LVGL Header Files
  @cInclude(&quot;lvgl/lvgl.h&quot;);

  // App Header Files
  @cInclude(&quot;fbdev.h&quot;);
  @cInclude(&quot;lcddev.h&quot;);
  @cInclude(&quot;tp.h&quot;);
  @cInclude(&quot;tp_cal.h&quot;);
});</code></pre></div>
<p>And our <strong>Application-Specific</strong> Header Files for LCD Display and Touch Panel.</p>
<p>That‚Äôs how we import the LVGL Library into our Zig App!</p>
<p><em>Why do we write ‚Äú<code>c.</code>something‚Äù when we call C functions? Like ‚Äú<code>c.lv_scr_act()</code>‚Äù?</em></p>
<p>Remember that we import all C Functions and Macros into the <strong>‚Äú<code>c</code>‚Äù Namespace</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import Functions and Macros into &quot;c&quot; Namespace
const c = @cImport({ ... });</code></pre></div>
<p>That‚Äôs why we write ‚Äú<code>c.</code><em>something</em>‚Äù when we refer to C Functions and Macros.</p>
<p><em>What about the Main Function of our Zig App?</em></p>
<p>It gets complicated. We‚Äôll talk later about the <a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L41-L109"><strong>Main Function lvgltest_main</strong></a>.</p>
<h1 id="compile-zig-app"><a href="#compile-zig-app">5 Compile Zig App</a></h1>
<p>Below are the steps to <strong>compile our Zig LVGL App</strong> for Apache NuttX RTOS and BL602 RISC-V SoC.</p>
<p>First we download the latest version of <strong>Zig Compiler</strong> (0.10.0 or later), extract it and add to PATH‚Ä¶</p>
<ul>
<li><a href="https://ziglang.org/download/"><strong>Zig Compiler Downloads</strong></a></li>
</ul>
<p>Then we download and compile <strong>Apache NuttX RTOS</strong> for PineDio Stack BL604‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/pinedio2#build-nuttx"><strong>‚ÄúBuild NuttX‚Äù</strong></a></li>
</ul>
<p>After building NuttX, we download and compile our <strong>Zig LVGL App</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Download our Zig LVGL App for NuttX
git clone --recursive https://github.com/lupyuen/zig-lvgl-nuttx
cd zig-lvgl-nuttx

#  Compile the Zig App for BL602
#  (RV32IMACF with Hardware Floating-Point)
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
zig build-obj \
  --verbose-cimport \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  -I &quot;$HOME/nuttx/apps/examples/lvgltest&quot; \
  lvgltest.zig</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/86298a99cb87b43ac568c19daeb4081a">(See the Compile Log)</a></p>
<p>Note that <strong>target</strong> and <strong>mcpu</strong> are specific to BL602‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/zig#zig-target"><strong>‚ÄúZig Target‚Äù</strong></a></li>
</ul>
<p><em>How did we get the Compiler Options <code>-isystem</code> and <code>-I</code>?</em></p>
<p>Remember that we‚Äôll link our Compiled Zig App with <strong>Apache NuttX RTOS.</strong></p>
<p>Hence the <strong>Zig Compiler Options must be the same</strong> as the GCC Options used to compile NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/lvgl#appendix-compiler-options">(See the GCC Options for NuttX)</a></p>
<p>Next comes a quirk specific to BL602: We must <strong>patch the ELF Header</strong> from Software Floating-Point ABI to Hardware Floating-Point ABI‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Patch the ELF Header of `lvgltest.o` from Soft-Float ABI to Hard-Float ABI
xxd -c 1 lvgltest.o \
  | sed &#39;s/00000024: 01/00000024: 03/&#39; \
  | xxd -r -c 1 - lvgltest2.o
cp lvgltest2.o lvgltest.o</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/zig#patch-elf-header">(More about this)</a></p>
<p>Finally we inject our <strong>Compiled Zig App</strong> into the NuttX Project Directory and link it into the <strong>NuttX Firmware</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Copy the compiled app to NuttX and overwrite `lvgltest.o`
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cp lvgltest.o $HOME/nuttx/apps/examples/lvgltest/lvgltest*.o

#  Build NuttX to link the Zig Object from `lvgltest.o`
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cd $HOME/nuttx/nuttx
make

#  For WSL: Copy the NuttX Firmware to c:\blflash for flashing
mkdir /mnt/c/blflash
cp nuttx.bin /mnt/c/blflash</code></pre></div>
<p>We‚Äôre ready to run our Zig App!</p>
<p><img src="https://lupyuen.github.io/images/lvgl-title.jpg" alt="LVGL Test App" /></p>
<h1 id="run-zig-app"><a href="#run-zig-app">6 Run Zig App</a></h1>
<p>Follow these steps to <strong>flash and boot NuttX</strong> (with our Zig App inside) on PineDio Stack‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#flash-pinedio-stack"><strong>‚ÄúFlash PineDio Stack‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#boot-pinedio-stack"><strong>‚ÄúBoot PineDio Stack‚Äù</strong></a></p>
</li>
</ul>
<p>In the NuttX Shell, enter this command to start our Zig App‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>lvgltest</code></pre></div>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Zig LVGL Test
tp_init: Opening /dev/input0
cst816s_get_touch_data: DOWN: id=0, touch=0, x=176, y=23
...
tp_cal result
offset x:23, y:14
range x:189, y:162
invert x/y:1, x:0, y:1</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/795d7660679c3e0288e8fe5bec190890">(See the complete log)</a></p>
<p>Our Zig App responds to touch and correctly renders the LVGL Screen (pic above).</p>
<p>Yep we have successfully built an LVGL Touchscreen App with Zig!</p>
<p>(We‚Äôll talk about Touch Input in a while)</p>
<h1 id="simplify-lvgl-api"><a href="#simplify-lvgl-api">7 Simplify LVGL API</a></h1>
<p><em>Can we make LVGL a little friendlier with Zig? Such that this code‚Ä¶</em></p>
<div class="example-wrap"><pre class="language-zig"><code>// Get the Active Screen
const screen = c.lv_scr_act().?;

// Create a Label Widget
const label = c.lv_label_create(screen, null).?;

// Wrap long lines in the label text
c.lv_label_set_long_mode(label, c.LV_LABEL_LONG_BREAK);

// Interpret color codes in the label text
c.lv_label_set_recolor(label, true);</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L114-L148">(Source)</a></p>
<p><em>Becomes this?</em></p>
<div class="example-wrap"><pre class="language-zig"><code>// Get the Active Screen
var screen = try lvgl.getActiveScreen();

// Create a Label Widget
var label = try screen.createLabel();

// Wrap long lines in the label text
label.setLongMode(c.LV_LABEL_LONG_BREAK);

// Interpret color codes in the label text
label.setRecolor(true);</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L150-L183">(Source)</a></p>
<p>Yes we can! By <strong>wrapping the LVGL API</strong> in Zig, which we‚Äôll do in the next section.</p>
<p>Note that we now use ‚Äú<strong><code>try</code></strong>‚Äù instead of ‚Äú<strong><code>.?</code></strong>‚Äù to check the values returned by LVGL‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Check that Active Screen is valid with `try`
var screen = try lvgl.getActiveScreen();</code></pre></div>
<p><em>What happens if we forget to ‚Äú<code>try</code>‚Äù?</em></p>
<p>If we don‚Äôt ‚Äú<strong><code>try</code></strong>‚Äù, like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Get the Active Screen without `try`
var screen = lvgl.getActiveScreen();

// Attempt to use the Active Screen
_ = screen;</code></pre></div>
<p>Zig Compiler stops us with an error‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>./lvgltest.zig:109:9:
error: error is discarded. 
consider using `try`, `catch`, or `if`
  _ = screen;
      ^</code></pre></div>
<p>Thus ‚Äú<strong><code>try</code></strong>‚Äù is actually safer than ‚Äú<code>.?</code>‚Äù, Zig Compiler mandates that we check for errors.</p>
<p><em>What if LVGL returns a Null Pointer to Zig?</em></p>
<p>Our app will fail gracefully with an <strong>Application Error</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>lv_scr_act failed
createWidgets failed: error.UnknownError</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L85-L93">(Because of this Error Handler)</a></p>
<h1 id="wrap-lvgl-api"><a href="#wrap-lvgl-api">8 Wrap LVGL API</a></h1>
<p>Earlier we saw the hypothetical <strong>LVGL API wrapped with Zig</strong>, let‚Äôs make it real in 3 steps‚Ä¶</p>
<ul>
<li>
<p>We write a function to fetch the <strong>Active Screen</strong> from LVGL</p>
</li>
<li>
<p>We create a Zig Struct that wraps an <strong>LVGL Screen</strong></p>
</li>
<li>
<p>And another Zig Struct that wraps an <strong>LVGL Label</strong></p>
</li>
</ul>
<h2 id="get-active-screen"><a href="#get-active-screen">8.1 Get Active Screen</a></h2>
<p>Below is the implementation of <strong>getActiveScreen</strong>, which fetches the Active Screen from LVGL‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Return the Active Screen
pub fn getActiveScreen() !Object {

  // Get the Active Screen
  const screen = c.lv_scr_act();

  // If successfully fetched...
  if (screen) |s| {
    // Wrap Active Screen as Object and return it
    return Object.init(s);
  } else {
    // Unable to get Active Screen
    std.log.err(&quot;lv_scr_act failed&quot;, .{});
    return LvglError.UnknownError;
  }
}</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgl.zig#L26-L34">(Source)</a></p>
<p><em>What‚Äôs this unusual <code>if</code> expression?</em></p>
<div class="example-wrap"><pre class="language-zig"><code>if (screen) |s| 
    { ... } else { ... }</code></pre></div>
<p>That‚Äôs how we check if <strong>screen</strong> is null.</p>
<p>If <strong>screen</strong> is not null, then <strong>s</strong> becomes the non-null contents of <strong>screen</strong>. And we create an <strong>Object Struct</strong> with <strong>s</strong> inside‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>if (screen) |s| 
  { return Object.init(s); }
  ...</code></pre></div>
<p>But if <strong>screen</strong> is null, we do the <strong>else</strong> clause and return an Error‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>if (screen) |s| 
  { ... }
else
  { return LvglError.UnknownError; }</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgl.zig#L117-L119">(<strong>LvglError</strong> is defined here)</a></p>
<p>That‚Äôs why the Return Type for our function is <strong>!Object</strong></p>
<div class="example-wrap"><pre class="language-zig"><code>pub fn getActiveScreen() !Object
  { ... }</code></pre></div>
<p>It returns either an <strong>Object Struct</strong> or an <strong>Error</strong>. (‚Äú<code>!</code>‚Äù means Error)</p>
<p>Let‚Äôs talk about the Object Struct‚Ä¶</p>
<h2 id="object-struct"><a href="#object-struct">8.2 Object Struct</a></h2>
<p><strong>Object</strong> is a Zig Struct that wraps around an LVGL Object (like the Active Screen).</p>
<p>It defines 2 Methods‚Ä¶</p>
<ul>
<li>
<p><strong>init</strong>: Initialise the LVGL Object</p>
</li>
<li>
<p><strong>createLabel</strong>: Create an LVGL Label as a child of the Object</p>
</li>
</ul>
<div class="example-wrap"><pre class="language-zig"><code>/// LVGL Object
pub const Object = struct {

  /// Pointer to LVGL Object
  obj: *c.lv_obj_t,

  /// Init the Object
  pub fn init(obj: *c.lv_obj_t) Object {
    return .{ .obj = obj };
  }

  /// Create a Label as a child of the Object
  pub fn createLabel(self: *Object) !Label {

    // Assume we won&#39;t copy from another Object 
    const copy: ?*const c.lv_obj_t = null;

    // Create the Label
    const label = c.lv_label_create(self.obj, copy);

    // If successfully created...
    if (label) |l| {
      // Wrap as Label and return it
      return Label.init(l);
    } else {
      // Unable to create Label
      std.log.err(&quot;lv_label_create failed&quot;, .{});
      return LvglError.UnknownError;
    }
  }
};</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgl.zig#L36-L58">(Source)</a></p>
<h2 id="label-struct"><a href="#label-struct">8.3 Label Struct</a></h2>
<p>Finally we have <strong>Label</strong>, a Zig Struct that wraps around an LVGL Label.</p>
<p>It defines a whole bunch of Methods to set the <strong>Label Properties, Text and Position</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// LVGL Label
pub const Label = struct {

  /// Pointer to LVGL Label
  obj: *c.lv_obj_t,

  /// Init the Label
  pub fn init(obj: *c.lv_obj_t) Label {
    return .{ .obj = obj };
  }

  /// Set the wrapping of long lines in the label text
  pub fn setLongMode(self: *Label, long_mode: c.lv_label_long_mode_t) void {
    c.lv_label_set_long_mode(self.obj, long_mode);
  }

  /// Set the label text alignment
  pub fn setAlign(self: *Label, alignment: c.lv_label_align_t) void {
    c.lv_label_set_align(self.obj, alignment);
  }

  /// Enable or disable color codes in the label text
  pub fn setRecolor(self: *Label, en: bool) void {
    c.lv_label_set_recolor(self.obj, en);
  }

  /// Set the label text and colors
  pub fn setText(self: *Label, text: [*c]const u8) void {
    c.lv_label_set_text(self.obj, text);
  }

  /// Set the object width
  pub fn setWidth(self: *Label, w: c.lv_coord_t) void {
    c.lv_obj_set_width(self.obj, w);
  }

  /// Set the object alignment
  pub fn alignObject(self: *Label, alignment: c.lv_align_t, x_ofs: c.lv_coord_t, y_ofs: c.lv_coord_t) void {
    const base: ?*const c.lv_obj_t = null;
    c.lv_obj_align(self.obj, base, alignment, x_ofs, y_ofs);
  }
};</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgl.zig#L60-L101">(Source)</a></p>
<p>Let‚Äôs call the wrapped LVGL API‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lvgl-code4a.png" alt="Our app calling the LVGL API wrapped with Zig" /></p>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L149-L181">(Source)</a></p>
<h2 id="after-wrapping-lvgl"><a href="#after-wrapping-lvgl">8.4 After Wrapping LVGL</a></h2>
<p>With the <strong>wrapped LVGL API</strong>, our Zig App becomes simpler and safer‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Create the LVGL Widgets that will be rendered on the display. Calls the
/// LVGL API that has been wrapped in Zig. Based on
/// https://docs.lvgl.io/7.11/widgets/label.html#label-recoloring-and-scrolling
fn createWidgetsWrapped() !void {

    // Get the Active Screen
    var screen = try lvgl.getActiveScreen();

    // Create a Label Widget
    var label = try screen.createLabel();

    // Wrap long lines in the label text
    label.setLongMode(c.LV_LABEL_LONG_BREAK);

    // Interpret color codes in the label text
    label.setRecolor(true);

    // Center align the label text
    label.setAlign(c.LV_LABEL_ALIGN_CENTER);

    // Set the label text and colors
    label.setText(
        &quot;#ff0000 HELLO# &quot; ++    // Red Text
        &quot;#00aa00 PINEDIO# &quot; ++  // Green Text
        &quot;#0000ff STACK!# &quot;      // Blue Text
    );

    // Set the label width
    label.setWidth(200);

    // Align the label to the center of the screen, shift 30 pixels up
    label.alignObject(c.LV_ALIGN_CENTER, 0, -30);
}</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L149-L181">(Source)</a></p>
<p>No more worries about catching Null Pointers!</p>
<p>(Someday <strong>LV_LABEL_LONG_BREAK</strong> and the other constants will become Enums)</p>
<p><em>Wrapping the LVGL API in Zig sounds like a lot of work?</em></p>
<p>Yep probably. Here are some ways to <strong>Auto-Generate the Zig Wrapper</strong> for LVGL‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl#appendix-auto-generate-zig-wrapper"><strong>‚ÄúAuto-Generate Zig Wrapper‚Äù</strong></a></li>
</ul>
<p>Also remember that LVGL is <strong>Object-Oriented</strong>. Designing the right wrapper with Zig might be challenging‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl#object-oriented-wrapper-for-lvgl"><strong>‚ÄúObject-Oriented Wrapper for LVGL‚Äù</strong></a></li>
</ul>
<h1 id="zig-vs-bit-fields"><a href="#zig-vs-bit-fields">9 Zig vs Bit Fields</a></h1>
<p><em>Zig looks amazing! Is there anything that Zig won‚Äôt do?</em></p>
<p>Sadly Zig won‚Äôt import <strong>C Structs containing Bit Fields</strong>.</p>
<p>(Zig Compiler version 0.10.0 has this issue, it might have been fixed in later versions of the compiler)</p>
<p>TODO</p>
<h1 id="zig-outcomes"><a href="#zig-outcomes">10 Zig Outcomes</a></h1>
<p><em>Have we gained anything by coding our LVGL App in Zig?</em></p>
<p>TODO: Runtime Checks, Null Pointers, Wrapper</p>
<p>TODO: But Bit Fields</p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>I hope this article has inspired you to create LVGL apps in Zig!</p>
<p>Check out my earlier work on Zig, NuttX and LoRaWAN‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/zig"><strong>‚ÄúZig on RISC-V BL602: Quick Peek with Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/iot"><strong>‚ÄúBuild an IoT App with Zig and LoRaWAN‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/lvgl.md"><strong>lupyuen.github.io/src/lvgl.md</strong></a></p>
<h1 id="notes"><a href="#notes">12 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1543395925116088320"><strong>this Twitter Thread</strong></a></p>
</li>
<li>
<p>Our Zig App includes a <a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L225-L257"><strong>Custom Logger</strong></a> and <a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L199-L225"><strong>Panic Handler</strong></a>.</p>
<p>They are explained below‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-logging"><strong>‚ÄúLogging‚Äù</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-panic-handler"><strong>‚ÄúPanic Handler‚Äù</strong></a></p>
</li>
</ol>
<h1 id="appendix-compiler-options"><a href="#appendix-compiler-options">13 Appendix: Compiler Options</a></h1>
<p>TODO</p>
<p>NuttX compiles the LVGL Test App with this GCC command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  App Source Directory
cd $HOME/nuttx/apps/examples/lvgltest

#  Compile lvgltest.c with GCC
riscv64-unknown-elf-gcc \
  -c \
  -fno-common \
  -Wall \
  -Wstrict-prototypes \
  -Wshadow \
  -Wundef \
  -Os \
  -fno-strict-aliasing \
  -fomit-frame-pointer \
  -fstack-protector-all \
  -ffunction-sections \
  -fdata-sections \
  -g \
  -march=rv32imafc \
  -mabi=ilp32f \
  -mno-relax \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -pipe \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  -DLV_LVGL_H_INCLUDE_SIMPLE \
  -Wno-format \
  -Dmain=lvgltest_main \
  -lvgltest.c \
  -o lvgltest.c.home.user.nuttx.apps.examples.lvgltest.o</code></pre></div>
<p>(Observed from <code>make --trace</code>)</p>
<p>Let‚Äôs convert the LVGL Test App from C to Zig‚Ä¶</p>
<h1 id="appendix-auto-translate-lvgl-app-to-zig"><a href="#appendix-auto-translate-lvgl-app-to-zig">14 Appendix: Auto-Translate LVGL App to Zig</a></h1>
<p>TODO</p>
<p>The Zig Compiler can auto-translate C code to Zig. <a href="https://ziglang.org/documentation/master/#C-Translation-CLI">(See this)</a></p>
<p>Here‚Äôs how we auto-translate our LVGL App <a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c">lvgltest_main.c</a> from C to Zig‚Ä¶</p>
<ul>
<li>
<p>Take the GCC command from above</p>
</li>
<li>
<p>Change <code>riscv64-unknown-elf-gcc</code> to <code>zig translate-c</code></p>
</li>
<li>
<p>Add the target <code>-target riscv32-freestanding-none -mcpu=baseline_rv32-d</code></p>
</li>
<li>
<p>Remove <code>-march=rv32imafc</code></p>
</li>
<li>
<p>Surround the C Flags by <code>-cflags</code> ‚Ä¶ <code>--</code></p>
</li>
</ul>
<p>Like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  App Source Directory
cd $HOME/nuttx/apps/examples/lvgltest

#  Auto-translate lvgltest.c from C to Zig
zig translate-c \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -cflags \
    -fno-common \
    -Wall \
    -Wstrict-prototypes \
    -Wshadow \
    -Wundef \
    -Os \
    -fno-strict-aliasing \
    -fomit-frame-pointer \
    -fstack-protector-all \
    -ffunction-sections \
    -fdata-sections \
    -g \
    -mabi=ilp32f \
    -mno-relax \
    -Wno-format \
  -- \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  -DLV_LVGL_H_INCLUDE_SIMPLE \
  -Dmain=lvgltest_main  \
  lvgltest.c \
  &gt;lvgltest.zig</code></pre></div>
<p>The target <code>-target riscv32-freestanding-none -mcpu=baseline_rv32-d</code> is specific to Zig and the BL602 RISC-V SoC‚Ä¶</p>
<p>TODO</p>
<p>To fix the translation we need to insert this‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#if defined(__NuttX__) &amp;&amp; defined(__clang__)  //  Workaround for NuttX with zig cc
#include &lt;arch/types.h&gt;
#include &quot;../../nuttx/include/limits.h&quot;
#define FAR
#endif  //  defined(__NuttX__) &amp;&amp; defined(__clang__)</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L25-L29">(Source)</a></p>
<p>And change this‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>static void monitor_cb(lv_disp_drv_t * disp_drv, uint32_t time, uint32_t px)
{
#ifndef __clang__  //  Doesn&#39;t compile with zig cc
  ginfo(&quot;%&quot; PRIu32 &quot; px refreshed in %&quot; PRIu32 &quot; ms\n&quot;, px, time);
#endif  //  __clang__
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L95-L100">(Source)</a></p>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/commit/1e8b0501c800209f0fa3f35f54b3742498d0e302">(See the changes)</a></p>
<p>Here‚Äôs the original C code: <a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c">lvgltest_main.c</a></p>
<p>And the auto-translation from C to Zig: <a href="translated/lvgltest.zig">translated/lvgltest.zig</a></p>
<h1 id="appendix-zig-auto-translation-is-incomplete"><a href="#appendix-zig-auto-translation-is-incomplete">15 Appendix: Zig Auto-Translation is Incomplete</a></h1>
<p><em>(Note: We observed this issue with Zig Compiler version 0.10.0, it might have been fixed in later versions of the compiler)</em></p>
<p>TODO</p>
<p>The Auto-Translation from C to Zig is missing 2 key functions: <code>lvgltest_main</code> and <code>create_widgets</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// lvgltest.c:129:13: warning: unable to translate function, demoted to extern
pub extern fn create_widgets() callconv(.C) void;
// lvgltest.c:227:17: warning: local variable has opaque type

// (no file):353:14: warning: unable to translate function, demoted to extern
pub extern fn lvgltest_main(arg_argc: c_int, arg_argv: [*c][*c]u8) c_int;</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/9e95d800f3a429c5f35970ca35cd43bd8fbd9529/translated/lvgltest.zig#L5901-L5904">(Source)</a></p>
<p>When we look up <code>lvgltest.c</code> line 227‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>int lvgltest_main(int argc, FAR char *argv[])
{
  // lvgltest.c:227:17: warning: local variable has opaque type
  lv_disp_drv_t disp_drv;
  lv_disp_buf_t disp_buf;
  ...</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/1e8b0501c800209f0fa3f35f54b3742498d0e302/lvgltest.c#L225-L228">(Source)</a></p>
<p>We see that Zig couldn‚Äôt translate the type <code>lv_disp_drv_t</code> because it‚Äôs opaque.</p>
<p>Let‚Äôs find out why.</p>
<h1 id="appendix-zig-opaque-types"><a href="#appendix-zig-opaque-types">16 Appendix: Zig Opaque Types</a></h1>
<p><em>(Note: We observed this issue with Zig Compiler version 0.10.0, it might have been fixed in later versions of the compiler)</em></p>
<p>TODO</p>
<p>To find out why the type is opaque, we search for <code>lv_disp_drv_t</code> in the Zig Translation‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// nuttx/apps/graphics/lvgl/lvgl/src/lv_hal/lv_hal_disp.h:154:9: 
// warning: struct demoted to opaque type - has bitfield
pub const lv_disp_drv_t = struct__disp_drv_t; 
pub const struct__disp_drv_t = opaque {};

// nuttx/apps/graphics/lvgl/lvgl/src/lv_hal/lv_hal_disp.h:59:23: 
// warning: struct demoted to opaque type - has bitfield
pub const lv_disp_t = struct__disp_t;
pub const struct__disp_t = opaque {};

pub const lv_disp_buf_t = opaque {};</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/9e95d800f3a429c5f35970ca35cd43bd8fbd9529/translated/lvgltest.zig#L700-L704">(Source)</a></p>
<p>Below are the C definitions of <code>lv_disp_drv_t</code>, <code>lv_disp_t</code> and <code>lv_disp_buf_t</code>.</p>
<p>The structs couldn‚Äôt be translated to Zig because they contain Bit Fields‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>typedef struct _disp_drv_t {
    uint32_t rotated : 1;
    uint32_t dpi : 10;
    ...
} lv_disp_drv_t;

typedef struct _disp_t {
    uint8_t del_prev  : 1;
    uint32_t inv_p : 10;
    ...
} lv_disp_t;

typedef struct {
    volatile uint32_t last_area : 1;
    volatile uint32_t last_part : 1;
    ...
} lv_disp_buf_t;</code></pre></div>
<p>Let‚Äôs fix the Opaque Types.</p>
<h2 id="fix-opaque-types"><a href="#fix-opaque-types">16.1 Fix Opaque Types</a></h2>
<p>TODO</p>
<p>Earlier we saw that Zig couldn‚Äôt translate and import these structs because they contain Bit Fields‚Ä¶</p>
<ul>
<li>
<p><code>lv_disp_drv_t</code> (Display Driver)</p>
</li>
<li>
<p><code>lv_disp_buf_t</code> (Display Buffer)</p>
</li>
</ul>
<p>Instead of creating instances of these structs in Zig, we do it in C instead‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/****************************************************************************
 * Name: get_disp_drv
 *
 * Description:
 *   Return the static instance of Display Driver, because Zig can&#39;t
 *   allocate structs wth bitfields inside.
 *
 ****************************************************************************/

lv_disp_drv_t *get_disp_drv(void)
{
  static lv_disp_drv_t disp_drv;
  return &amp;disp_drv;
}

/****************************************************************************
 * Name: get_disp_buf
 *
 * Description:
 *   Return the static instance of Display Buffer, because Zig can&#39;t
 *   allocate structs wth bitfields inside.
 *
 ****************************************************************************/

lv_disp_buf_t *get_disp_buf(void)
{
  static lv_disp_buf_t disp_buf;
  return &amp;disp_buf;
}

/****************************************************************************
 * Name: init_disp_drv
 *
 * Description:
 *   Initialise the Display Driver, because Zig can&#39;t access its fields.
 *
 ****************************************************************************/

void init_disp_drv(lv_disp_drv_t *disp_drv,
  lv_disp_buf_t *disp_buf,
  void (*monitor_cb)(struct _disp_drv_t *, uint32_t, uint32_t))
{
  assert(disp_drv != NULL);
  assert(disp_buf != NULL);
  assert(monitor_cb != NULL);

  lv_disp_drv_init(disp_drv);
  disp_drv-&gt;buffer = disp_buf;
  disp_drv-&gt;monitor_cb = monitor_cb;
}

/****************************************************************************
 * Name: init_disp_buf
 *
 * Description:
 *   Initialise the Display Buffer, because Zig can&#39;t access the fields.
 *
 ****************************************************************************/

void init_disp_buf(lv_disp_buf_t *disp_buf)
{
  assert(disp_buf != NULL);
  lv_disp_buf_init(disp_buf, buffer1, buffer2, DISPLAY_BUFFER_SIZE);
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lcddev.c#L335-L398">(Source)</a></p>
<p>Then we fetch the pointers to these structs in our Main Function and initialise the structs‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>int lvgltest_main(int argc, FAR char *argv[])
{
  lv_disp_drv_t *disp_drv = get_disp_drv();
  lv_disp_buf_t *disp_buf = get_disp_buf();
  ...
  /* Basic LVGL display driver initialization */
  init_disp_buf(disp_buf);
  init_disp_drv(disp_drv, disp_buf, monitor_cb);
  ...
  /* Touchpad Initialization */
  lv_indev_drv_t *indev_drv = get_indev_drv();
  init_indev_drv(indev_drv, tp_read);</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L214-L293">(Source)</a></p>
<p>(<code>get_indev_drv</code> and <code>init_indev_drv</code> are explained in the next section)</p>
<p>After this modification, our Auto-Translation from C to Zig now contains the 2 missing functions‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/translated/lvgltest.zig#L5913-L5944"><code>lvgltest_main</code></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/translated/lvgltest.zig#L5903-L5912"><code>create_widgets</code></a></p>
</li>
</ul>
<h2 id="input-driver"><a href="#input-driver">16.2 Input Driver</a></h2>
<p>TODO</p>
<p>Our Input Driver <code>lv_indev_drv_t</code> is also an Opaque Type because it contains Bit Fields.</p>
<p>We fix <code>lv_indev_drv_t</code> the same way as other Opaque Types: We allocate and initialise the structs in C (instead of Zig)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/****************************************************************************
 * Name: get_indev_drv
 *
 * Description:
 *   Return the static instance of Input Driver, because Zig can&#39;t
 *   allocate structs wth bitfields inside.
 *
 ****************************************************************************/

lv_indev_drv_t *get_indev_drv(void)
{
  static lv_indev_drv_t indev_drv;
  return &amp;indev_drv;
}

/****************************************************************************
 * Name: init_indev_drv
 *
 * Description:
 *   Initialise the Input Driver, because Zig can&#39;t access its fields.
 *
 ****************************************************************************/

void init_indev_drv(lv_indev_drv_t *indev_drv,
  bool (*read_cb)(struct _lv_indev_drv_t *, lv_indev_data_t *))
{
  assert(indev_drv != NULL);
  assert(read_cb != NULL);

  lv_indev_drv_init(indev_drv);
  indev_drv-&gt;type = LV_INDEV_TYPE_POINTER;

  /* This function will be called periodically (by the library) to get the
   * mouse position and state.
   */

  indev_drv-&gt;read_cb = read_cb;
  lv_indev_drv_register(indev_drv);
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/tp.c#L282-L320">(Source)</a></p>
<h2 id="color-type"><a href="#color-type">16.3 Color Type</a></h2>
<p>TODO</p>
<p>We also commented out all references to <code>lv_color_t</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  LVGL Canvas Demo doesn&#39;t work with zig cc because of `lv_color_t`
#if defined(CONFIG_USE_LV_CANVAS) &amp;&amp; !defined(__clang__)  

  //  Set the Canvas Buffer (Warning: Might take a lot of RAM!)
  static lv_color_t cbuf[LV_CANVAS_BUF_SIZE_TRUE_COLOR(CANVAS_WIDTH, CANVAS_HEIGHT)];
  ...</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L160-L165">(Source)</a></p>
<p>That‚Äôs because <code>lv_color_t</code> is also an Opaque Type‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>pub const lv_color_t = lv_color16_t;

pub const lv_color16_t = extern union {
    ch: struct_unnamed_7,
    full: u16,
};

// nuttx/apps/graphics/lvgl/lvgl/src/lv_core/../lv_draw/../lv_misc/lv_color.h:240:18:
// warning: struct demoted to opaque type - has bitfield
const struct_unnamed_7 = opaque {};</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/translated/lvgltest.zig#L520-L537">(Source)</a></p>
<p>That contains Bit Fields‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>typedef union {
    struct {
        // Bit fields for lv_color16_t (aliased to lv_color_t)
        uint16_t blue : 5;
        uint16_t green : 6;
        uint16_t red : 5;
    } ch;
    uint16_t full;
} lv_color16_t;</code></pre></div><h1 id="appendix-clean-up"><a href="#appendix-clean-up">17 Appendix: Clean Up</a></h1>
<p>TODO</p>
<p>After cleaning up our Zig LVGL App, here‚Äôs our Main Function <code>lvgltest_main</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Main Function that will be called by NuttX. We render an LVGL Screen and
/// handle Touch Input.
pub export fn lvgltest_main(
    _argc: c_int, 
    _argv: [*]const [*]const u8
) c_int {
    debug(&quot;Zig LVGL Test&quot;, .{});
    // Command-line args are not used
    _ = _argc;
    _ = _argv;

    // Init LVGL Library
    c.lv_init();

    // Init Display Buffer
    const disp_buf = c.get_disp_buf().?;
    c.init_disp_buf(disp_buf);

    // Init Display Driver
    const disp_drv = c.get_disp_drv().?;
    c.init_disp_drv(disp_drv, disp_buf, monitorCallback);

    // Init LCD Driver
    if (c.lcddev_init(disp_drv) != c.EXIT_SUCCESS) {
        // If failed, try Framebuffer Driver
        if (c.fbdev_init(disp_drv) != c.EXIT_SUCCESS) {
            // No possible drivers left, fail
            return c.EXIT_FAILURE;
        }
    }

    // Register Display Driver
    _ = c.lv_disp_drv_register(disp_drv);

    // Init Touch Panel
    _ = c.tp_init();

    // Init Input Device. tp_read will be called periodically
    // to get the touched position and state
    const indev_drv = c.get_indev_drv().?;
    c.init_indev_drv(indev_drv, c.tp_read);

    // Create the widgets for display
    createWidgetsUnwrapped()
        catch |e| {
            // In case of error, quit
            std.log.err(&quot;createWidgets failed: {}&quot;, .{e});
            return c.EXIT_FAILURE;
        };

    // To call the LVGL API that&#39;s wrapped in Zig, change
    // `createWidgetsUnwrapped` above to `createWidgetsWrapped`

    // Start Touch Panel calibration
    c.tp_cal_create();

    // Loop forever handing LVGL tasks
    while (true) {
        // Handle LVGL tasks
        _ = c.lv_task_handler();

        // Sleep a while
        _ = c.usleep(10000);
    }
    return 0;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L44-L109">(Source)</a></p>
<p>And here‚Äôs our <code>createWidgetsUnwrapped</code> function that creates widgets‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Create the LVGL Widgets that will be rendered on the display. Calls the
/// LVGL API directly, without wrapping in Zig. Based on
/// https://docs.lvgl.io/7.11/widgets/label.html#label-recoloring-and-scrolling
fn createWidgetsUnwrapped() !void {

    // Get the Active Screen
    const screen = c.lv_scr_act().?;

    // Create a Label Widget
    const label = c.lv_label_create(screen, null).?;

    // Wrap long lines in the label text
    c.lv_label_set_long_mode(label, c.LV_LABEL_LONG_BREAK);

    // Interpret color codes in the label text
    c.lv_label_set_recolor(label, true);

    // Center align the label text
    c.lv_label_set_align(label, c.LV_LABEL_ALIGN_CENTER);

    // Set the label text and colors
    c.lv_label_set_text(
        label, 
        &quot;#ff0000 HELLO# &quot; ++    // Red Text
        &quot;#00aa00 PINEDIO# &quot; ++  // Green Text
        &quot;#0000ff STACK!# &quot;      // Blue Text
    );

    // Set the label width
    c.lv_obj_set_width(label, 200);

    // Align the label to the center of the screen, shift 30 pixels up
    c.lv_obj_align(label, null, c.LV_ALIGN_CENTER, 0, -30);
}</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L114-L147">(Source)</a></p>
<p>The Zig Functions look very similar to C: <a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L107-L318">lvgltest.c</a></p>
<h1 id="appendix-auto-generate-zig-wrapper"><a href="#appendix-auto-generate-zig-wrapper">18 Appendix: Auto-Generate Zig Wrapper</a></h1>
<p>TODO</p>
<p><em>Can we auto-generate the Wrapper Code?</em></p>
<p>We could use Zig Type Reflection‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/README.md#zig-type-reflection">‚ÄúZig Type Reflection‚Äù</a></li>
</ul>
<p>But Zig Type Reflection doesn‚Äôt include the Parameter Types.</p>
<p>Instead, we can parse the Type Info JSON generated by Zig Compiler‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># Emit IR, BC and Type Info
zig build-obj \
  -femit-llvm-ir \
  -femit-llvm-bc \
  -femit-analysis \
  --verbose-cimport \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  -I &quot;$HOME/nuttx/apps/examples/lvgltest&quot; \
  lvgltest.zig</code></pre></div>
<p>This produces the IR, BC and Type Info JSON files: </p>
<div class="example-wrap"><pre class="language-text"><code>lvgltest.ll
lvgltest.bc
lvgltest-analysis.json</code></pre></div>
<p>Let‚Äôs look up the Type Info for the LVGL Function <code>lv_obj_align</code>.</p>
<p>We search for <code>lv_obj_align</code> in <code>lvgltest-analysis.json</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>&quot;decls&quot;:
  ...
  {
   &quot;import&quot;: 99,
   &quot;src&quot;: 1962,
   &quot;name&quot;: &quot;lv_obj_align&quot;,
   &quot;kind&quot;: &quot;const&quot;,
   &quot;type&quot;: 148,
   &quot;value&quot;: 60
  },</code></pre></div>
<p>Then we look up type 148 in <code>lvgltest-analysis.json</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ jq &#39;.types[148]&#39; lvgltest-analysis.json
{
  &quot;kind&quot;: 18,
  &quot;name&quot;: &quot;fn(?*.cimport:10:11.struct__lv_obj_t, ?*const .cimport:10:11.struct__lv_obj_t, u8, i16, i16) callconv(.C) void&quot;,
  &quot;generic&quot;: false,
  &quot;ret&quot;: 70,
  &quot;args&quot;: [
    79,
    194,
    95,
    134,
    134
  ]
}</code></pre></div>
<p>The First Parameter has type 79, so we look up <code>lvgltest-analysis.json</code> and follow the trail‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ jq &#39;.types[79]&#39; lvgltest-analysis.json
{
  &quot;kind&quot;: 13,
  &quot;child&quot;: 120
}
# Kind 13 is `?` (Optional)

$ jq &#39;.types[120]&#39; lvgltest-analysis.json
{
  &quot;kind&quot;: 6,
  &quot;elem&quot;: 137
}
# Kind 6 is `*` (Pointer)

$ jq &#39;.types[137]&#39; lvgltest-analysis.json
{
  &quot;kind&quot;: 20,
  &quot;name&quot;: &quot;.cimport:10:11.struct__lv_obj_t&quot;
}
# Kind 20 is `struct`???</code></pre></div>
<p>Which gives us the complete type of the First Parameter‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>?*.cimport:10:11.struct__lv_obj_t</code></pre></div>
<p>We don‚Äôt have the Parameter Names though, we might need to parse the <code>.cimport</code> file.</p>
<p><a href="https://stedolan.github.io/jq/manual/">(More about jq)</a></p>
<h2 id="object-oriented-wrapper-for-lvgl"><a href="#object-oriented-wrapper-for-lvgl">18.1 Object-Oriented Wrapper for LVGL</a></h2>
<p>TODO</p>
<p><em>Is LVGL really Object-Oriented?</em></p>
<p>Yep the LVGL API is actually Object-Oriented since it uses Inheritance.</p>
<p>All LVGL Widgets (Labels, Buttons, etc) have the same Base Type: <code>lv_obj_t</code>. But same LVGL Functions will work only for specific Widgets, some will work only on any Widget‚Ä¶</p>
<ul>
<li>
<p><code>lv_label_set_text</code> works only for Labels</p>
</li>
<li>
<p><code>lv_obj_set_width</code> works for any Widget</p>
</li>
</ul>
<p>The LVGL Docs also say that LVGL is Object-Oriented‚Ä¶</p>
<ul>
<li><a href="https://docs.lvgl.io/latest/en/html/widgets/obj.html">‚ÄúBase object (lv_obj)‚Äù</a></li>
</ul>
<p>Creating an Object-Oriented Zig Wrapper for LVGL might be challenging: Our Zig Wrapper needs to support <code>setWidth</code> for all LVGL Widgets.</p>
<p>To do this we might use Zig Interfaces and <code>@fieldParentPtr</code>‚Ä¶</p>
<ul>
<li>
<p><a href="https://zig.news/david_vanderson/interfaces-in-zig-o1c">‚ÄúInterfaces in Zig‚Äù</a></p>
</li>
<li>
<p><a href="https://www.nmichaels.org/zig/interfaces.html">‚ÄúZig Interfaces for the Uninitiated‚Äù</a></p>
</li>
</ul>
<p>Which look somewhat similar to VTables in C++‚Ä¶</p>
<ul>
<li><a href="https://pithlessly.github.io/allocgate.html">‚ÄúAllocgate is coming in Zig 0.9‚Äù</a></li>
</ul>
<p><em>Are there any Object-Oriented Bindings for LVGL?</em></p>
<p>The official Python Bindings for LVGL appear to be Object-Oriented. This could inspire our Object-Oriented Wrapper in Zig‚Ä¶</p>
<ul>
<li><a href="https://github.com/lvgl/lv_binding_micropython">Python Bindings for LVGL</a></li>
</ul>
<p>However the Python Bindings are Dynamically Typed, might be tricky implementing them as Static Types in Zig.</p>

    
</body>
</html>