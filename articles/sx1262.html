<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>LoRa SX1262 on Apache NuttX OS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="LoRa SX1262 on Apache NuttX OS" 
    data-rh="true">
<meta property="og:description" 
    content="Porting the LoRa Driver for Semtech SX1262 from Linux to Apache NuttX OS... And testing it on PineDio Stack BL604 RISC-V Board"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/sx1262-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">LoRa SX1262 on Apache NuttX OS</h1>
    <nav id="TOC"><ul>
<li><a href="#small-steps">1 Small Steps</a><ul>
<li><a href="#lorawan-support">1.1 LoRaWAN Support</a><ul></ul></li>
<li><a href="#lora-sx1262-library">1.2 LoRa SX1262 Library</a><ul></ul></li>
<li><a href="#library-vs-driver">1.3 Library vs Driver</a><ul></ul></li></ul></li>
<li><a href="#connect-sx1262-transceiver">2 Connect SX1262 Transceiver</a><ul></ul></li>
<li><a href="#read-sx1262-registers">3 Read SX1262 Registers</a><ul>
<li><a href="#build-the-firmware">3.1 Build the Firmware</a><ul></ul></li>
<li><a href="#run-the-firmware">3.2 Run the Firmware</a><ul></ul></li>
<li><a href="#source-files">3.3 Source Files</a><ul></ul></li></ul></li>
<li><a href="#lora-parameters">4 LoRa Parameters</a><ul>
<li><a href="#initialise-lora-sx1262">4.1 Initialise LoRa SX1262</a><ul></ul></li></ul></li>
<li><a href="#transmit-lora-message">5 Transmit LoRa Message</a><ul>
<li><a href="#run-the-firmware-1">5.1 Run the Firmware</a><ul></ul></li>
<li><a href="#spectrum-analysis-with-sdr">5.2 Spectrum Analysis with SDR</a><ul></ul></li></ul></li>
<li><a href="#receive-lora-message">6 Receive LoRa Message</a><ul>
<li><a href="#run-the-firmware-2">6.1 Run the Firmware</a><ul></ul></li></ul></li>
<li><a href="#spi-interface">7 SPI Interface</a><ul>
<li><a href="#initialise-spi">7.1 Initialise SPI</a><ul></ul></li>
<li><a href="#transfer-spi">7.2 Transfer SPI</a><ul></ul></li>
<li><a href="#transmit-message">7.3 Transmit Message</a><ul></ul></li>
<li><a href="#receive-message">7.4 Receive Message</a><ul></ul></li>
<li><a href="#long-messages">7.5 Long Messages</a><ul></ul></li></ul></li>
<li><a href="#gpio-interface">8 GPIO Interface</a><ul></ul></li>
<li><a href="#multithreading-with-nimble-porting-layer">9 Multithreading with NimBLE Porting Layer</a><ul>
<li><a href="#nimble-porting-layer">9.1 NimBLE Porting Layer</a><ul></ul></li></ul></li>
<li><a href="#whats-next">10 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">11 Notes</a><ul></ul></li>
<li><a href="#appendix-create-a-nuttx-library">12 Appendix: Create a NuttX Library</a><ul>
<li><a href="#update-makefiles-and-kconfig">12.1 Update Makefiles and Kconfig</a><ul></ul></li>
<li><a href="#enable-library">12.2 Enable Library</a><ul></ul></li>
<li><a href="#verify-library">12.3 Verify Library</a><ul></ul></li></ul></li>
<li><a href="#appendix-build-flash-and-run-nuttx">13 Appendix: Build, Flash and Run NuttX</a><ul>
<li><a href="#build-nuttx">13.1 Build NuttX</a><ul></ul></li>
<li><a href="#flash-nuttx">13.2 Flash NuttX</a><ul></ul></li>
<li><a href="#run-nuttx">13.3 Run NuttX</a><ul></ul></li></ul></li>
<li><a href="#appendix-radio-functions">14 Appendix: Radio Functions</a><ul>
<li><a href="#radioinit-initialise-lora-module">14.1 RadioInit: Initialise LoRa Module</a><ul></ul></li>
<li><a href="#radiosetchannel-set-lora-frequency">14.2 RadioSetChannel: Set LoRa Frequency</a><ul></ul></li>
<li><a href="#radiosettxconfig-set-transmit-configuration">14.3 RadioSetTxConfig: Set Transmit Configuration</a><ul></ul></li>
<li><a href="#radiosetrxconfig-set-receive-configuration">14.4 RadioSetRxConfig: Set Receive Configuration</a><ul></ul></li>
<li><a href="#radiosend-transmit-message">14.5 RadioSend: Transmit Message</a><ul></ul></li>
<li><a href="#radiorx-receive-message">14.6 RadioRx: Receive Message</a><ul></ul></li>
<li><a href="#radioirqprocess-process-transmit-and-receive-interrupts">14.7 RadioIrqProcess: Process Transmit and Receive Interrupts</a><ul>
<li><a href="#transmit-done">14.7.1 Transmit Done</a><ul></ul></li>
<li><a href="#receive-done">14.7.2 Receive Done</a><ul></ul></li>
<li><a href="#cad-done">14.7.3 CAD Done</a><ul></ul></li>
<li><a href="#transmit--receive-timeout">14.7.4 Transmit / Receive Timeout</a><ul></ul></li>
<li><a href="#preamble-detected">14.7.5 Preamble Detected</a><ul></ul></li>
<li><a href="#sync-word-valid">14.7.6 Sync Word Valid</a><ul></ul></li>
<li><a href="#header-valid">14.7.7 Header Valid</a><ul></ul></li>
<li><a href="#header-error">14.7.8 Header Error</a><ul></ul></li>
<li><a href="#radioondioirq">14.7.9 RadioOnDioIrq</a><ul></ul></li></ul></li>
<li><a href="#radiosleep-switch-to-sleep-mode">14.8 RadioSleep: Switch to Sleep Mode</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>25 Dec 2021</em></p>
<p><img src="https://lupyuen.github.io/images/sx1262-title.jpg" alt="PineDio Stack BL604 RISC-V Board with onboard Semtech SX1262 LoRa Transceiver (left)‚Ä¶ Sniffed wirelessly with Airspy R2 Software Defined Radio (right)" /></p>
<p><em>PineDio Stack BL604 RISC-V Board with onboard Semtech SX1262 LoRa Transceiver (left)‚Ä¶ Sniffed wirelessly with Airspy R2 Software Defined Radio (right)</em></p>
<p><strong>LoRa</strong> is an awesome wireless technology for IoT that will transmit <strong>small packets over super long distances</strong>‚Ä¶</p>
<p><a href="https://lora-developers.semtech.com/documentation/tech-papers-and-guides/lora-and-lorawan/">(Up to 5 km or 3 miles in urban areas‚Ä¶ 15 km or 10 miles in rural areas!)</a></p>
<p>Let‚Äôs port LoRa to <a href="https://lupyuen.github.io/articles/nuttx"><strong>Apache NuttX OS!</strong></a></p>
<p><a href="https://makezine.com/2021/05/24/go-long-with-lora-radio/">(More about LoRa)</a></p>
<p><em>Doesn‚Äôt NuttX support LoRa already?</em></p>
<p>Yep NuttX has a standalone LoRa Driver for <strong>Semtech SX1276 Transceiver</strong> (Radio Transmitter + Receiver)‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/incubator-nuttx/tree/master/drivers/wireless/lpwan/sx127x"><strong>NuttX SX127x Driver</strong></a></p>
</li>
<li>
<p><a href="https://github.com/apache/incubator-nuttx-apps/tree/master/examples/sx127x_demo"><strong>NuttX SX127x Demo</strong></a></p>
</li>
</ul>
<p>(That doesn‚Äôt work with LoRaWAN yet)</p>
<p>Today we build a NuttX Driver for the (newer) <a href="https://www.semtech.com/products/wireless-rf/lora-core/sx1262"><strong>Semtech SX1262 Transceiver</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/tree/nuttx"><strong>SX1262 Library</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/tree/master/examples/sx1262_test"><strong>SX1262 Test App</strong></a></p>
</li>
</ul>
<p>Our LoRa SX1262 Driver shall be tested on Bouffalo Lab‚Äôs <a href="https://lupyuen.github.io/articles/pinecone"><strong>BL602 and BL604 RISC-V SoCs</strong></a>.</p>
<p>(It will probably run on <strong>ESP32</strong>, since we‚Äôre calling standard NuttX Interfaces)</p>
<p>Eventually our LoRa SX1262 Driver will support the <strong>LoRaWAN Wireless Protocol</strong>.</p>
<p><em>How useful is LoRaWAN? Will we be using it?</em></p>
<p>Our LoRa SX1262 Driver will work perfectly fine for unsecured <strong>Point-to-Point Wireless Communication</strong>.</p>
<p>But if we need to <strong>relay data packets</strong> securely to a Local Area Network or to the internet, we need <strong>LoRaWAN</strong>.</p>
<p><a href="https://makezine.com/2021/05/24/go-long-with-lora-radio/">(More about LoRaWAN)</a></p>
<h1 id="small-steps" class="section-header"><a href="#small-steps">1 Small Steps</a></h1>
<p><em>So today we‚Äôll build the NuttX Drivers for LoRa SX1262 and LoRaWAN?</em></p>
<p>Not quite. Implementing LoRa AND LoRaWAN is a complex endeavour.</p>
<p>Thus we break the implementation into small steps‚Ä¶</p>
<ul>
<li>
<p>Today we do the <strong>SX1262 Library</strong> (top right)</p>
</li>
<li>
<p>And we test with our <strong>LoRa App</strong> (top left)</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/sx1262-library.jpg" alt="Porting LoRaWAN to NuttX OS" /></p>
<ul>
<li>
<p>In the next article we‚Äôll do the <strong>LoRaWAN Library</strong> and test with our <strong>LoRaWAN App</strong></p>
</li>
<li>
<p>Eventually we shall wrap the SX1262 and LoRaWAN Libraries as <strong>NuttX Drivers</strong></p>
<p>(Because that‚Äôs the proper design for NuttX)</p>
</li>
</ul>
<h2 id="lorawan-support" class="section-header"><a href="#lorawan-support">1.1 LoRaWAN Support</a></h2>
<p><em>Why is LoRaWAN so complex?</em></p>
<p>LoRaWAN works <strong>slightly differently across the world regions</strong>, to comply with Local Wireless Regulations: Radio Frequency, Maximum Airtime (Duty Cycle), <a href="https://lupyuen.github.io/articles/lorawan#appendix-lora-carrier-sensing">Listen Before Talk</a>, ‚Ä¶</p>
<p>Thus we should port <strong>Semtech‚Äôs LoRaWAN Stack</strong> to NuttX with <strong>minimal changes</strong>, in case of future updates. (Like for new regions)</p>
<p>This also means that we should port <strong>Semtech‚Äôs SX1262 Driver</strong> to NuttX as-is, because of the dependencies between the LoRaWAN Stack and the SX1262 Driver.</p>
<h2 id="lora-sx1262-library" class="section-header"><a href="#lora-sx1262-library">1.2 LoRa SX1262 Library</a></h2>
<p><em>Where did the LoRa SX1262 code come from?</em></p>
<p>Our LoRa SX1262 Library originated from <strong>Semtech‚Äôs Reference Implementation</strong> of SX1262 Driver‚Ä¶</p>
<ul>
<li><a href="https://github.com/Lora-net/LoRaMac-node/tree/master/src/radio/sx126x"><strong>LoRaMac-node/radio/sx126x</strong></a></li>
</ul>
<p>Which we ported to <strong>Linux</strong> and <strong>BL602 IoT SDK</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/lora-sx1262/tree/nuttx"><strong>lupyuen/lora-sx1262 (nuttx branch)</strong></a></li>
</ul>
<p>And we‚Äôre porting now to <strong>NuttX</strong>.</p>
<p>(Because porting Linux code to NuttX is straightforward)</p>
<p><em>How did we create the LoRa SX1262 Library?</em></p>
<p>We followed the steps below to create <strong>‚Äúnuttx/libs/libsx1262‚Äù</strong> by cloning a NuttX Library‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/sx1262#appendix-create-a-nuttx-library"><strong>‚ÄúCreate a NuttX Library‚Äù</strong></a></li>
</ul>
<p>Then we replaced the ‚Äúlibsx1262‚Äù folder by a <strong>Git Submodule</strong> that contains our LoRa SX1262 code‚Ä¶ </p>
<div class="example-wrap"><pre class="language-bash"><code>cd nuttx/nuttx/libs
rm -r libsx1262
git rm -r libsx1262
git submodule add --branch nuttx https://github.com/lupyuen/lora-sx1262 libsx1262</code></pre></div>
<p>(Note that we‚Äôre using the <strong>‚Äúnuttx‚Äù</strong> branch of the ‚Äúlora_sx1262‚Äù repo)</p>
<h2 id="library-vs-driver" class="section-header"><a href="#library-vs-driver">1.3 Library vs Driver</a></h2>
<p><em>NuttX Libraries vs Drivers‚Ä¶ What‚Äôs the difference?</em></p>
<p>Our LoRa SX1262 code is initially packaged as a <strong>NuttX Library</strong> (instead of NuttX Driver) because‚Ä¶</p>
<ul>
<li>
<p>NuttX Libraries are <strong>easier to code and troubleshoot</strong></p>
</li>
<li>
<p>NuttX Libraries may be called by <strong>NuttX Apps AND NuttX Drivers</strong></p>
<p>(So we can test our library with a NuttX App)</p>
</li>
</ul>
<p>Eventually our LoRa SX1262 code shall be packaged as a <strong>NuttX Driver</strong>‚Ä¶</p>
<ul>
<li>
<p>Our code shall run inside NuttX OS, which means‚Ä¶</p>
</li>
<li>
<p>Our driver needs to expose an <strong>ioctl()</strong> interface to NuttX Apps</p>
<p>(Which will be cumbersome to code)</p>
</li>
</ul>
<p>Check out the <strong>ioctl()</strong> interface for the existing SX1276 Driver in NuttX: <a href="https://github.com/apache/incubator-nuttx/blob/master/drivers/wireless/lpwan/sx127x/sx127x.c#L954-L1162"><strong>sx127x.c</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-plan2.jpg" alt="SPI Test Driver" /></p>
<p><em>But how will our library access the NuttX SPI Interface?</em></p>
<p>The NuttX SPI Interface is accessible by NuttX Drivers, but not NuttX Apps.</p>
<p>Thankfully in the previous article we have created an <strong>SPI Test Driver ‚Äú/dev/spitest0‚Äù</strong> that exposes the SPI Interface to NuttX Apps (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2"><strong>‚ÄúSPI on Apache NuttX OS‚Äù</strong></a></li>
</ul>
<p>For now we‚Äôll call this SPI Test Driver in our LoRa SX1262 Library.</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio1.jpg" alt="Inside PineDio Stack BL604" /></p>
<h1 id="connect-sx1262-transceiver" class="section-header"><a href="#connect-sx1262-transceiver">2 Connect SX1262 Transceiver</a></h1>
<p>Our code has been configured for <a href="https://lupyuen.github.io/articles/pinedio"><strong>PineDio Stack BL604</strong></a> and its onboard SX1262 Transceiver. (Pic above)</p>
<p>Based on this schematic for PineDio Stack BL604 (version 2)‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio3.png" alt="SX1262 Interface on PineDio Stack" /></p>
</blockquote>
<p>We have configured the following <strong>BL604 Pin Definitions</strong> in <a href="https://github.com/lupyuen/incubator-nuttx/blob/sx1262/boards/risc-v/bl602/bl602evb/include/board.h#L42-L95">board.h</a></p>
<div><table><thead><tr><th align="center">SX1262</th><th align="center">BL604 Pin</th><th align="left">NuttX Pin</th></tr></thead><tbody>
<tr><td align="center"><strong>MOSI</strong></td><td align="center">GPIO 13</td><td align="left">BOARD_SPI_MOSI</td></tr>
<tr><td align="center"><strong>MISO</strong></td><td align="center">GPIO 0</td><td align="left">BOARD_SPI_MISO</td></tr>
<tr><td align="center"><strong>SCK</strong></td><td align="center">GPIO 11</td><td align="left">BOARD_SPI_CLK</td></tr>
<tr><td align="center"><strong>CS</strong></td><td align="center">GPIO 15</td><td align="left">BOARD_GPIO_OUT1</td></tr>
<tr><td align="center"><strong>BUSY</strong></td><td align="center">GPIO 10</td><td align="left">BOARD_GPIO_IN1</td></tr>
<tr><td align="center"><strong>DIO1</strong></td><td align="center">GPIO 19</td><td align="left">BOARD_GPIO_INT1</td></tr>
<tr><td align="center"><strong>NRESET</strong></td><td align="center">GPIO 18</td><td align="left">Not assigned yet</td></tr>
</tbody></table>
</div><div class="example-wrap"><pre class="language-c"><code>/* Busy Pin for PineDio SX1262 */

#define BOARD_GPIO_IN1    (GPIO_INPUT | GPIO_FLOAT | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN10)

/* SPI Chip Select for PineDio SX1262 */

#define BOARD_GPIO_OUT1   (GPIO_OUTPUT | GPIO_PULLUP | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN15)

/* GPIO Interrupt (DIO1) for PineDio SX1262 */

#define BOARD_GPIO_INT1   (GPIO_INPUT | GPIO_PULLUP | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN19)

/* SPI Configuration: Chip Select is unused because we control via GPIO instead */

#define BOARD_SPI_CS   (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN8)  /* Unused */
#define BOARD_SPI_MOSI (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN13)
#define BOARD_SPI_MISO (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN0)
#define BOARD_SPI_CLK  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN11)</code></pre></div>
<p>GPIO Output <strong>BOARD_GPIO_OUT1</strong> becomes our <strong>SPI Chip Select</strong>. <a href="https://lupyuen.github.io/articles/spi2#control-chip-select-with-gpio">(See this)</a></p>
<p>Right now we won‚Äôt use <strong>BOARD_GPIO_IN1</strong> (Busy Pin), <strong>BOARD_GPIO_INT1</strong> (DIO1) and <strong>NRESET</strong>.</p>
<p><strong>For BL602:</strong> Connect SX1262 to <a href="https://lupyuen.github.io/articles/spi2#connect-sx1262">these pins</a>. Copy the BL602 Pin Definitions from <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/boards/risc-v/bl602/bl602evb/include/board.h#L36-L92">board.h</a> to‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>boards/risc-v/bl602/bl602evb/include/board.h</code></pre></div>
<p><strong>For ESP32:</strong> Connect SX1262 to <a href="https://lupyuen.github.io/articles/spi2#connect-sx1262">these pins</a></p>
<p>Before testing, remember to connect the <strong>LoRa Antenna</strong>‚Ä¶ </p>
<p>(So we don‚Äôt fry the SX1262 Transceiver as we charge up the Power Amplifier)</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio10a.jpg" alt="PineDio Stack BL604 with Antenna" /></p>
<p><em>What are these SX1262 pins: DIO1, BUSY and NRESET?</em></p>
<p><strong>DIO1</strong> is used by SX1262 to signal that a LoRa Packet has been received.</p>
<p><strong>BUSY</strong> is tells us if SX1262 is busy.</p>
<p><strong>NRESET</strong> is toggled to reset the SX1262 module.</p>
<p>Although our SX1262 Library doesn‚Äôt use these pins, it works somewhat OK for sending and receiving LoRa Messages.</p>
<p>(We‚Äôll learn why in a while)</p>
<p><img src="https://lupyuen.github.io/images/sx1262-read2.png" alt="Reading SX1262 Registers" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L155-L171">(Source)</a></p>
<h1 id="read-sx1262-registers" class="section-header"><a href="#read-sx1262-registers">3 Read SX1262 Registers</a></h1>
<p><em>What‚Äôs the simplest way to test our SX1262 Library?</em></p>
<p>To test whether our SX1262 Library is sending SPI Commands correctly to the SX1262 Transceiver, we can read the <strong>SX1262 Registers</strong>.</p>
<p>Here‚Äôs how: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L155-L171">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Main Function
int main(int argc, FAR char *argv[]) {
  //  Read SX1262 registers 0x00 to 0x0F
  read_registers();
  return 0;
}

/// Read SX1262 registers
static void read_registers(void) {
  //  Init the SPI port
  SX126xIoInit();

  //  Read and print the first 16 registers: 0 to 15
  for (uint16_t addr = 0; addr &lt; 0x10; addr++) {
    //  Read the register
    uint8_t val = SX126xReadRegister(addr);

    //  Print the register value
    printf(&quot;Register 0x%02x = 0x%02x\n&quot;, addr, val);
  }
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L65-L77">(<strong>SX126xIoInit</strong> is defined here)</a></p>
<p>In our Test App we call <strong>read_registers</strong> and <strong>SX126xReadRegister</strong> to read a bunch of SX1262 Registers. (<code>0x00</code> to <code>0x0F</code>)</p>
<p>In our SX1262 Library, <strong>SX126xReadRegister</strong> calls <strong>SX126xReadRegisters</strong> and <strong>sx126x_read_register</strong> to read each register: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L268-L281">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Read an SX1262 Register at the specified address
uint8_t SX126xReadRegister(uint16_t address) {
  //  Read one register and return the value
  uint8_t data;
  SX126xReadRegisters(address, &amp;data, 1);
  return data;
}

/// Read one or more SX1262 Registers at the specified address.
/// `size` is the number of registers to read.
void SX126xReadRegisters(uint16_t address, uint8_t *buffer, uint16_t size) {
  //  Wake up SX1262 if sleeping
  SX126xCheckDeviceReady();

  //  Read the SX1262 registers
  int rc = sx126x_read_register(NULL, address, buffer, size);
  assert(rc == 0);

  //  Wait for SX1262 to be ready
  SX126xWaitOnBusy();
}</code></pre></div>
<p>(We‚Äôll see <strong>SX126xCheckDeviceReady</strong> and <strong>SX126xWaitOnBusy</strong> in a while)</p>
<p><strong>sx126x_read_register</strong> reads a register by sending the Read Register Command to SX1262 over SPI: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L495-L504">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Send a Read Register Command to SX1262 over SPI
/// and return the results in `buffer`. `size` is the
/// number of registers to read.
static int sx126x_read_register(const void* context, const uint16_t address, uint8_t* buffer, const uint8_t size) {
  //  Reserve 4 bytes for our SX1262 Command Buffer
  uint8_t buf[SX126X_SIZE_READ_REGISTER] = { 0 };

  //  Init the SX1262 Command Buffer
  buf[0] = RADIO_READ_REGISTER;       //  Command ID (0x1D)
  buf[1] = (uint8_t) (address &gt;&gt; 8);  //  MSB of Register ID
  buf[2] = (uint8_t) (address &gt;&gt; 0);  //  LSB of Register ID
  buf[3] = 0;                         //  Unused

  //  Transmit the Command Buffer over SPI 
  //  and receive the Result Buffer
  int status = sx126x_hal_read( 
    context,  //  Context (unsued)
    buf,      //  Command Buffer
    SX126X_SIZE_READ_REGISTER,  //  Command Buffer Size: 4 bytes
    buffer,   //  Result Buffer
    size,     //  Result Buffer Size
    NULL      //  Status not required
  );
  return status;
}</code></pre></div>
<p>(More about <strong>sx126x_hal_read</strong> later)</p>
<p>This transmits the following <strong>Read Register Command</strong> to SX1262‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>1d 00 08 00 00 </code></pre></div>
<p>(<code>0x1D</code> is the Command ID, <code>0x08</code> is the Register ID)</p>
<p>SX1262 responds with‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>a2 a2 a2 a2 80 </code></pre></div>
<p>The last byte is the <strong>Register Value</strong>: <code>0x80</code></p>
<h2 id="build-the-firmware" class="section-header"><a href="#build-the-firmware">3.1 Build the Firmware</a></h2>
<p>Let‚Äôs build the modified NuttX Firmware that contains our <strong>LoRa SX1262 Library and Test App</strong>‚Ä¶</p>
<ol>
<li>
<p>Install the build prerequisites‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Download the modified source code‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>mkdir nuttx
cd nuttx
git clone --recursive --branch sx1262 https://github.com/lupyuen/incubator-nuttx nuttx
git clone --recursive --branch sx1262 https://github.com/lupyuen/incubator-nuttx-apps apps</code></pre></div></li>
<li>
<p>Edit <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L100-L101"><strong>apps/examples/sx1262_test_main.c</strong></a> and uncomment‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define READ_REGISTERS</code></pre></div></li>
<li>
<p>Configure the build‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cd nuttx

# For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

# For ESP32: Configure the build for ESP32.
# TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

# Edit the Build Config
make menuconfig </code></pre></div></li>
<li>
<p>Enable the <strong>GPIO Driver</strong> in menuconfig‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#enable-gpio-driver"><strong>‚ÄúEnable GPIO Driver‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-menu7a.png" alt="Enable the GPIO Driver" /></p>
</li>
<li>
<p>Enable the <strong>SPI Peripheral</strong> and <strong>SPI Character Driver</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-spi"><strong>‚ÄúEnable SPI‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-debug.jpg" alt="Enable SPI" /></p>
</li>
<li>
<p>Enable our <strong>SPI Test Driver</strong> ‚Äú/dev/spitest0‚Äù‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-spi"><strong>‚ÄúEnable SPI‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver6.png" alt="Select SPI Test Driver" /></p>
</li>
<li>
<p>Enable <strong>GPIO and SPI Logging</strong> for easier troubleshooting‚Ä¶</p>
<p>(Might be good to uncheck <strong>‚ÄúGPIO Informational Output‚Äù</strong> and <strong>‚ÄúSPI Informational Output‚Äù</strong>)</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-logging"><strong>‚ÄúEnable Logging‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/spi2-driver4.png" alt="Enable Logging" /></p>
</li>
<li>
<p>Enable our <strong>SX1262 Library</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#enable-library"><strong>‚ÄúEnable Library‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/sx1262-clone7.png" alt="Enable Library" /></p>
</li>
<li>
<p>Enable our <strong>SX1262 Test App</strong>‚Ä¶</p>
<p>Check the box for <strong>‚ÄúApplication Configuration‚Äù</strong> ‚Üí <strong>‚ÄúExamples‚Äù</strong> ‚Üí <strong>‚ÄúSX1262 Test‚Äù</strong></p>
</li>
<li>
<p>Save the configuration and exit menuconfig</p>
<p><a href="https://gist.github.com/lupyuen/ec97cff54064c9f9d7d1c700c035b777">(Here‚Äôs the .config for BL602)</a></p>
</li>
<li>
<p><strong>For ESP32:</strong> Edit <a href="https://github.com/lupyuen/incubator-nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L118-L426"><strong>esp32_bringup.c</strong></a> to register our SPI Test Driver <a href="https://lupyuen.github.io/articles/spi2#register-device-driver">(See this)</a></p>
</li>
<li>
<p>Build, flash and run the NuttX Firmware on BL602 or ESP32‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX‚Äù</strong></a></p>
</li>
</ol>
<h2 id="run-the-firmware" class="section-header"><a href="#run-the-firmware">3.2 Run the Firmware</a></h2>
<p>Finally we run the NuttX Firmware and test our <strong>LoRa SX1262 Library</strong>‚Ä¶</p>
<ol>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>ls /dev</code></pre></div>
<p>Our SPI Test Driver should appear as <strong>‚Äú/dev/spitest0‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/spi2-newdriver10.png" alt="Our SPI Test Driver appears as ‚Äú/dev/spitest0‚Äù" /></p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sx1262_test</code></pre></div></li>
<li>
<p>We should see these <strong>SX1262 Register Values</strong> (pic below)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Register 0x00 = 0x00
...
Register 0x08 = 0x80
Register 0x09 = 0x00
Register 0x0a = 0x01</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/1e732f5b1e0e4a80d1eb351ab3aadede">(See the Output Log)</a></p>
<p>Our LoRa SX1262 Library talks OK to the SX1262 Transceiver!</p>
<p>Note that the values above will change when we <strong>transmit and receive LoRa Messages</strong>. Let‚Äôs do that now.</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/sx1262-read5.png" alt="Reading SX1262 Registers" /></p>
<h2 id="source-files" class="section-header"><a href="#source-files">3.3 Source Files</a></h2>
<p><em>We‚Äôre seeing layers of code, like an onion? (Or Shrek)</em></p>
<p>Yep our SX1262 Library is structured as <strong>layers of Source Files</strong> because we hope to support three platforms‚Ä¶</p>
<ol>
<li>
<p><strong>NuttX</strong></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/usb"><strong>Linux</strong></a> (PineDio USB)</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lorawan"><strong>BL602 IoT SDK</strong></a></p>
</li>
</ol>
<p>The <strong>Platform-Independent</strong> Source Files shared by all platforms are‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c"><strong>src/sx126x.c</strong></a></p>
<p>(Semtech‚Äôs Driver for SX1262 Transceiver)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c"><strong>src/radio.c</strong></a></p>
<p>(Semtech‚Äôs Radio Interface for LoRa Transceivers)</p>
</li>
</ul>
<p>(We should minimise changes to the above files, because they will be called by Semtech‚Äôs LoRaWAN Driver)</p>
<p>The <strong>Platform-Specific</strong> Source Files for NuttX are‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c"><strong>src/sx126x-nuttx.c</strong></a></p>
<p>(NuttX Interface for SX1262)</p>
</li>
</ul>
<h1 id="lora-parameters" class="section-header"><a href="#lora-parameters">4 LoRa Parameters</a></h1>
<p>Before we transmit and receive LoRa Messages, let‚Äôs talk about the <strong>LoRa Parameters</strong>.</p>
<p>Check this doc to find out which <strong>LoRa Frequency</strong> we should use for our region‚Ä¶</p>
<ul>
<li><a href="https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html"><strong>LoRa Frequencies by Country</strong></a></li>
</ul>
<p>We set the <strong>LoRa Frequency</strong> in our SX1262 Test App like so: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L30-L45">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// TODO: We are using LoRa Frequency 923 MHz 
/// for Singapore. Change this for your region.
#define USE_BAND_923</code></pre></div>
<p>Change <strong>USE_BAND_923</strong> to <strong>USE_BAND_433</strong>, <strong>780</strong>, <strong>868</strong> or <strong>915</strong>.</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L33-L45">(See the complete list)</a></p>
<p>Below are the other <strong>LoRa Parameters</strong>: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L47-L66">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// LoRa Parameters
#define LORAPING_TX_OUTPUT_POWER            14        /* dBm */

#define LORAPING_BANDWIDTH                  0         /* [0: 125 kHz, */
                                                      /*  1: 250 kHz, */
                                                      /*  2: 500 kHz, */
                                                      /*  3: Reserved] */
#define LORAPING_SPREADING_FACTOR           7         /* [SF7..SF12] */
#define LORAPING_CODINGRATE                 1         /* [1: 4/5, */
                                                      /*  2: 4/6, */
                                                      /*  3: 4/7, */
                                                      /*  4: 4/8] */
#define LORAPING_PREAMBLE_LENGTH            8         /* Same for Tx and Rx */
#define LORAPING_SYMBOL_TIMEOUT             5         /* Symbols */
#define LORAPING_FIX_LENGTH_PAYLOAD_ON      false
#define LORAPING_IQ_INVERSION_ON            false

#define LORAPING_TX_TIMEOUT_MS              3000    /* ms */
#define LORAPING_RX_TIMEOUT_MS              10000    /* ms */
#define LORAPING_BUFFER_SIZE                64      /* LoRa message size */</code></pre></div>
<p><a href="https://www.thethingsnetwork.org/docs/lorawan/spreading-factors/">(More about LoRa Parameters)</a></p>
<p>During testing, these should <strong>match the LoRa Parameters</strong> used by the LoRa Transmitter / Receiver.</p>
<p>In a while we‚Äôll use <a href="https://lupyuen.github.io/articles/wisblock"><strong>RAKwireless WisBlock</strong></a> (pic below) to test our SX1262 Library. </p>
<p>Below are the <strong>LoRa Transmitter and Receiver</strong> programs (Arduino) that we‚Äôll run on WisBlock‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/wisblock-lora-transmitter"><strong>wisblock-lora-transmitter</strong></a></p>
<p><a href="https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp#L38-L54">(LoRa Parameters for Transmitter)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/wisblock-lora-receiver"><strong>wisblock-lora-receiver</strong></a></p>
<p><a href="https://github.com/lupyuen/wisblock-lora-receiver/blob/main/src/main.cpp#L37-L56">(LoRa Parameters for Receiver)</a></p>
</li>
</ul>
<p>The LoRa Parameters above should match the ones in our SX1262 Test App for NuttX.</p>
<p><em>Are there practical limits on the LoRa Parameters?</em></p>
<p>Yes we need to comply with the <strong>Local Regulations</strong> on the usage of <a href="https://en.wikipedia.org/wiki/ISM_radio_band"><strong>ISM Radio Bands</strong></a>: FCC, ETSI, ‚Ä¶</p>
<ul>
<li><a href="https://www.thethingsnetwork.org/docs/lorawan/regional-parameters/"><strong>‚ÄúRegional Parameters‚Äù</strong></a></li>
</ul>
<p>(Blasting LoRa Messages non-stop is no-no!)</p>
<p><img src="https://lupyuen.github.io/images/wisblock-title.jpg" alt="RAKwireless WisBlock LPWAN Module mounted on WisBlock Base Board" /></p>
<h2 id="initialise-lora-sx1262" class="section-header"><a href="#initialise-lora-sx1262">4.1 Initialise LoRa SX1262</a></h2>
<p>Let‚Äôs watch how the LoRa Parameters are used to <strong>initialise the SX1262 Transceiver</strong>.</p>
<p>The <strong>init_driver</strong> function in our Test App takes the LoRa Parameters and initialises LoRa SX1262 like so: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L173-L227">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Command to initialise the LoRa Driver.
/// Assume that create_task has been called to init the Event Queue.
static void init_driver(char *buf, int len, int argc, char **argv) {
  //  Set the LoRa Callback Functions
  RadioEvents_t radio_events;
  memset(&amp;radio_events, 0, sizeof(radio_events));  //  Must init radio_events to null, because radio_events lives on stack!
  radio_events.TxDone    = on_tx_done;     //  Packet has been transmitted
  radio_events.RxDone    = on_rx_done;     //  Packet has been received
  radio_events.TxTimeout = on_tx_timeout;  //  Transmit Timeout
  radio_events.RxTimeout = on_rx_timeout;  //  Receive Timeout
  radio_events.RxError   = on_rx_error;    //  Receive Error</code></pre></div>
<p>Here we set the <strong>Callback Functions</strong> that will be called when a LoRa Message has been transmitted or received, also when we encounter a transmit / receive timeout or error.</p>
<p>(We‚Äôll see the Callback Functions in a while)</p>
<p>Next we call our SX1262 Library to initialise the LoRa Transceiver and set the <strong>LoRa Frequency</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Init the SPI Port and the LoRa Transceiver
  Radio.Init(&amp;radio_events);

  //  Set the LoRa Frequency
  Radio.SetChannel(RF_FREQUENCY);</code></pre></div>
<p>Then we set the <strong>LoRa Transmit Parameters</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Configure the LoRa Transceiver for transmitting messages
  Radio.SetTxConfig(
    MODEM_LORA,
    LORAPING_TX_OUTPUT_POWER,
    0,        //  Frequency deviation: Unused with LoRa
    LORAPING_BANDWIDTH,
    LORAPING_SPREADING_FACTOR,
    LORAPING_CODINGRATE,
    LORAPING_PREAMBLE_LENGTH,
    LORAPING_FIX_LENGTH_PAYLOAD_ON,
    true,     //  CRC enabled
    0,        //  Frequency hopping disabled
    0,        //  Hop period: N/A
    LORAPING_IQ_INVERSION_ON,
    LORAPING_TX_TIMEOUT_MS
  );</code></pre></div>
<p>Finally we set the <strong>LoRa Receive Parameters</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Configure the LoRa Transceiver for receiving messages
  Radio.SetRxConfig(
    MODEM_LORA,
    LORAPING_BANDWIDTH,
    LORAPING_SPREADING_FACTOR,
    LORAPING_CODINGRATE,
    0,        //  AFC bandwidth: Unused with LoRa
    LORAPING_PREAMBLE_LENGTH,
    LORAPING_SYMBOL_TIMEOUT,
    LORAPING_FIX_LENGTH_PAYLOAD_ON,
    0,        //  Fixed payload length: N/A
    true,     //  CRC enabled
    0,        //  Frequency hopping disabled
    0,        //  Hop period: N/A
    LORAPING_IQ_INVERSION_ON,
    true      //  Continuous receive mode
  );    
}</code></pre></div>
<p>The <strong>Radio</strong> functions are Platform-Independent, defined in our SX1262 Library: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c">radio.c</a></p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#radioinit-initialise-lora-module"><strong>RadioInit:</strong></a> Init LoRa SX1262</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radioinit-initialise-lora-module">(<strong>RadioInit</strong> is explained here)</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosetchannel-set-lora-frequency"><strong>RadioSetChannel:</strong></a> Set LoRa Frequency</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosetchannel-set-lora-frequency">(<strong>RadioSetChannel</strong> is explained here)</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosettxconfig-set-transmit-configuration"><strong>RadioSetTxConfig:</strong></a> Set LoRa Transmit Configuration</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosettxconfig-set-transmit-configuration">(<strong>RadioSetTxConfig</strong> is explained here)</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosetrxconfig-set-receive-configuration"><strong>RadioSetRxConfig:</strong></a> Set LoRa Receive Configuration</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosetrxconfig-set-receive-configuration">(<strong>RadioSetRxConfig</strong> is explained here)</a></p>
</li>
</ul>
<p>(The <strong>Radio</strong> functions will also be called when we implement LoRaWAN)</p>
<p><img src="https://lupyuen.github.io/images/sx1262-send.png" alt="Transmitting a LoRa Message" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L237-L253">(Source)</a></p>
<h1 id="transmit-lora-message" class="section-header"><a href="#transmit-lora-message">5 Transmit LoRa Message</a></h1>
<p>Now we‚Äôre ready to <strong>transmit a LoRa Message</strong> in our SX1262 Test App! Here‚Äôs how: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L110-L121">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Main Function
int main(void) {
  //  Init SX1262 driver
  init_driver();

  //  TODO: Do we need to wait?
  sleep(1);

  //  Send a LoRa message
  send_message();
  return 0;
}</code></pre></div>
<p>We begin by calling <strong>init_driver</strong> in our Test App to set the LoRa Parameters and the Callback Functions.</p>
<p>(We‚Äôve seen <strong>init_driver</strong> in the previous section)</p>
<p>To transmit a LoRa Message, <strong>send_message</strong> calls <strong>send_once</strong>: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L229-L235">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Send a LoRa message. Assume that SX1262 driver has been initialised.
static void send_message(void) {
  //  Send the &quot;PING&quot; message
  send_once(1);
}</code></pre></div>
<p><strong>send_once</strong> prepares a 64-byte LoRa Message containing the string ‚Äú<code>PING</code>‚Äù: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L237-L253">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// We send a &quot;PING&quot; message and expect a &quot;PONG&quot; response
const uint8_t loraping_ping_msg[] = &quot;PING&quot;;
const uint8_t loraping_pong_msg[] = &quot;PONG&quot;;

/// 64-byte buffer for our LoRa message
static uint8_t loraping_buffer[LORAPING_BUFFER_SIZE];

/// Send a LoRa message. If is_ping is 0, send &quot;PONG&quot;. Otherwise send &quot;PING&quot;.
static void send_once(int is_ping) {
  //  Copy the &quot;PING&quot; or &quot;PONG&quot; message 
  //  to the transmit buffer
  if (is_ping) {
    memcpy(loraping_buffer, loraping_ping_msg, 4);
  } else {
    memcpy(loraping_buffer, loraping_pong_msg, 4);
  }</code></pre></div>
<p>Then we <strong>pad the 64-byte message</strong> with values 0, 1, 2, ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Fill up the remaining space in the 
  //  transmit buffer (64 bytes) with values 
  //  0, 1, 2, ...
  for (int i = 4; i &lt; sizeof loraping_buffer; i++) {
    loraping_buffer[i] = i - 4;
  }</code></pre></div>
<p>And we call our SX1262 Library to <strong>transmit the LoRa Message</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  We send the transmit buffer (64 bytes)
  Radio.Send(loraping_buffer, sizeof loraping_buffer);
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosend-transmit-message">(<strong>RadioSend</strong> is explained here)</a></p>
<p>When the LoRa Message has been transmitted, the SX1262 Library calls our Callback Function <strong>on_tx_done</strong> defined in <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L267-L280">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function that is called when our LoRa message has been transmitted
static void on_tx_done(void) {
  //  Log the success status
  loraping_stats.tx_success++;

  //  Switch the LoRa Transceiver to 
  //  low power, sleep mode
  Radio.Sleep();
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosleep-switch-to-sleep-mode">(<strong>RadioSleep</strong> is explained here)</a></p>
<p>Here we log the number of packets transmitted, and put LoRa SX1262 into <strong>low power, sleep mode</strong>.</p>
<p>Note: <strong>on_tx_done</strong> won‚Äôt actually be called in our current driver, because we haven‚Äôt implemented Multithreading. (More about this later)</p>
<p>To handle Transmit Timeout Errors, we define the Callback Function <strong>on_tx_timeout</strong>: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L314-L326">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function that is called when our LoRa message couldn&#39;t be transmitted due to timeout
static void on_tx_timeout(void) {
  //  Switch the LoRa Transceiver to 
  //  low power, sleep mode
  Radio.Sleep();

  //  Log the timeout
  loraping_stats.tx_timeout++;
}</code></pre></div><h2 id="run-the-firmware-1" class="section-header"><a href="#run-the-firmware-1">5.1 Run the Firmware</a></h2>
<p>Let‚Äôs test our SX1262 Library and <strong>transmit a LoRa Message</strong>‚Ä¶</p>
<ol>
<li>
<p>Assume that we have downloaded and configured our NuttX code‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#build-the-firmware"><strong>‚ÄúBuild the Firmware‚Äù</strong></a></p>
</li>
<li>
<p>Edit <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L116-L117"><strong>apps/examples/sx1262_test_main.c</strong></a> and uncomment‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define SEND_MESSAGE</code></pre></div></li>
<li>
<p>Also edit <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L30-L66"><strong>sx1262_test_main.c</strong></a> and set the <strong>LoRa Parameters</strong>. (As explained earlier)</p>
</li>
<li>
<p>Build, flash and run the NuttX Firmware on BL602 or ESP32‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX‚Äù</strong></a></p>
</li>
<li>
<p>Switch over to <strong>RAKwireless WisBlock</strong> and run our <strong>LoRa Receiver</strong>‚Ä¶</p>
<p><a href="https://github.com/lupyuen/wisblock-lora-receiver"><strong>wisblock-lora-receiver</strong></a></p>
<p>Check that the <strong>LoRa Parameters</strong> are correct‚Ä¶</p>
<p><a href="https://github.com/lupyuen/wisblock-lora-receiver/blob/main/src/main.cpp#L37-L56"><strong>LoRa Parameters for WisBlock Receiver</strong></a></p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sx1262_test</code></pre></div></li>
<li>
<p>We should see our SX1262 Library transmitting a 64-byte <strong>LoRa Message</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>send_message
RadioSend: size=64
50 49 4e 47 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L237-L253">(‚Äú<code>PING</code>‚Äù followed by 0, 1, 2, ‚Ä¶)</a></p>
<p><a href="https://gist.github.com/lupyuen/5fdede131ad0e327478994872f190668">(See the Output Log)</a></p>
</li>
<li>
<p>On WisBlock we should see the same 64-byte <strong>LoRa Message</strong> received by WisBlock‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>LoRaP2P Rx Test
Starting Radio.Rx
OnRxDone: Timestamp=18, RssiValue=-28 dBm, SnrValue=13, 
Data=50 49 4e 47 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b</code></pre></div>
<p>Our SX1262 Library has successfully transmitted a 64-byte LoRa Message to RAKwireless WisBlock!</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/sx1262-send2.png" alt="Our SX1262 Library transmits a LoRa Message to RAKwireless WisBlock" /></p>
<p>In case of problems, try troubleshooting with a Software Defined Radio like Airspy R2‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/sx1262-title.jpg" alt="PineDio Stack BL604 RISC-V Board with onboard Semtech SX1262 LoRa Transceiver (left)‚Ä¶ Sniffed wirelessly with Airspy R2 Software Defined Radio (right)" /></p>
<h2 id="spectrum-analysis-with-sdr" class="section-header"><a href="#spectrum-analysis-with-sdr">5.2 Spectrum Analysis with SDR</a></h2>
<p><em>What if nothing appears in our LoRa Receiver?</em></p>
<p>Use a <strong>Spectrum Analyser</strong> (like a <strong>Software Defined Radio</strong>) to sniff the airwaves and check whether our LoRa Message is transmitted‚Ä¶</p>
<ol>
<li>
<p>At the right <strong>Radio Frequency</strong></p>
<p>(923 MHz below)</p>
</li>
<li>
<p>With <strong>sufficient power</strong></p>
<p>(Red stripe below)</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/sx1262-sdr.png" alt="Spectrum Analysis of LoRa Message with SDR" /></p>
<p>LoRa Messages have a characteristic criss-cross shape: <strong>LoRa Chirp</strong>. (Like above)</p>
<p>More about LoRa Chirps and Software Defined Radio‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lora#visualise-lora-with-software-defined-radio"><strong>‚ÄúVisualise LoRa with Software Defined Radio‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/sx1262-receive.png" alt="Receiving a LoRa Message" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L123-L262">(Source)</a></p>
<h1 id="receive-lora-message" class="section-header"><a href="#receive-lora-message">6 Receive LoRa Message</a></h1>
<p>Watch the (turn)tables turn as we <strong>receive a LoRa Message</strong> with our SX1262 Library! This is how we do it: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L107-L137">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Main Function
int main(void) {
  //  TODO: Create a Background Thread 
  //  to handle LoRa Events
  create_task();</code></pre></div>
<p>We start by creating a <strong>Background Thread</strong> to handle LoRa Events in our Test App.</p>
<p>(<strong>create_task</strong> doesn‚Äôt do anything because we haven‚Äôt implemented Multithreading. More about this later)</p>
<p>Next we set the <strong>LoRa Parameters</strong> and the <strong>Callback Functions</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Init SX1262 driver
  init_driver();

  //  TODO: Do we need to wait?
  sleep(1);</code></pre></div>
<p>(Yep the same <strong>init_driver</strong> we‚Äôve seen earlier)</p>
<p>For the next <strong>10 seconds</strong> we poll and handle LoRa Events (like Message Received)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Handle LoRa events for the next 10 seconds
  for (int i = 0; i &lt; 10; i++) {
    //  Prepare to receive a LoRa message
    receive_message();

    //  Process the received LoRa message, if any
    RadioOnDioIrq(NULL);
    
    //  Sleep for 1 second
    usleep(1000 * 1000);
  }
  return 0;
}</code></pre></div>
<p>(Polling isn‚Äôt efficient, we‚Äôll discuss the enhancements later)</p>
<p>We call <strong>receive_message</strong> to get SX1262 ready to receive a single LoRa Message.</p>
<p>Then we call <strong>RadioOnDioIrq</strong> (from our SX1262 Library) to handle the Message Received Event. (If any)</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radioondioirq">(<strong>RadioOnDioIrq</strong> is explained here)</a></p>
<p><strong>receive_message</strong> is defined in our Test App: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L255-L262">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Receive a LoRa message. Assume that SX1262 driver has been initialised.
/// Assume that create_task has been called to init the Event Queue.
static void receive_message(void) {
  //  Receive a LoRa message within the timeout period
  Radio.Rx(LORAPING_RX_TIMEOUT_MS);
}</code></pre></div>
<p>This code calls <strong>RadioRx</strong> (from our SX1262 Library) to prep SX1262 to receive a single LoRa Message.</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiorx-receive-message">(<strong>RadioRx</strong> is explained here)</a></p>
<p>When our SX1262 Library receives a LoRa Message, it calls our Callback Function <strong>on_rx_done</strong> defined in our Test App: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L282-L312">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function that is called when a LoRa message has been received
static void on_rx_done(
  uint8_t *payload,  //  Buffer containing received LoRa message
  uint16_t size,     //  Size of the LoRa message
  int16_t rssi,      //  Signal strength
  int8_t snr) {      //  Signal To Noise ratio

  //  Switch the LoRa Transceiver to low power, sleep mode
  Radio.Sleep();

  //  Log the signal strength, signal to noise ratio
  loraping_rxinfo_rxed(rssi, snr);</code></pre></div>
<p><strong>on_rx_done</strong> switches the LoRa Transceiver to low power, sleep mode and logs the received packet.</p>
<p>Next we <strong>copy the received packet</strong> into a buffer‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Copy the received packet
  if (size &gt; sizeof loraping_buffer) {
    size = sizeof loraping_buffer;
  }
  loraping_rx_size = size;
  memcpy(loraping_buffer, payload, size);</code></pre></div>
<p>Finally we <strong>dump the buffer</strong> containing the received packet‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Dump the contents of the received packet
  for (int i = 0; i &lt; loraping_rx_size; i++) {
    printf(&quot;%02x &quot;, loraping_buffer[i]);
  }
  puts(&quot;&quot;);
}</code></pre></div>
<p><em>What happens when we don‚Äôt receive a packet in 10 seconds? (LORAPING_RX_TIMEOUT_MS)</em></p>
<p>Our SX1262 Library calls our Callback Function <strong>on_rx_timeout</strong> defined in our Test App: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L328-L341">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function that is called when no LoRa messages could be received due to timeout
static void on_rx_timeout(void) {
  //  Switch the LoRa Transceiver to low power, sleep mode
  Radio.Sleep();

  //  Log the timeout
  loraping_stats.rx_timeout++;
}</code></pre></div>
<p>We switch the LoRa Transceiver into sleep mode and log the timeout.</p>
<p>Note: <strong>on_rx_timeout</strong> won‚Äôt actually be called in our current driver, because we haven‚Äôt implemented Multithreading. (More about this later)</p>
<p>To handle Receive Errors, we define the Callback Function <strong>on_rx_error</strong> in our Test App: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L343-L355">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function that is called when we couldn&#39;t receive a LoRa message due to error
static void on_rx_error(void) {
  //  Log the error
  loraping_stats.rx_error++;

  //  Switch the LoRa Transceiver to low power, sleep mode
  Radio.Sleep();
}</code></pre></div><h2 id="run-the-firmware-2" class="section-header"><a href="#run-the-firmware-2">6.1 Run the Firmware</a></h2>
<p>Let‚Äôs test our SX1262 Library and <strong>receive a LoRa Message</strong>‚Ä¶</p>
<ol>
<li>
<p>Assume that we have downloaded and configured our NuttX code‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#build-the-firmware"><strong>‚ÄúBuild the Firmware‚Äù</strong></a></p>
</li>
<li>
<p>Edit <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L123-L124"><strong>apps/examples/sx1262_test_main.c</strong></a> and uncomment‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define RECEIVE_MESSAGE</code></pre></div></li>
<li>
<p>Also edit <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L30-L66"><strong>sx1262_test_main.c</strong></a> and set the <strong>LoRa Parameters</strong>. (As explained earlier)</p>
</li>
<li>
<p>Build, flash and run the NuttX Firmware on BL602 or ESP32‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX‚Äù</strong></a></p>
</li>
<li>
<p>Switch over to <strong>RAKwireless WisBlock</strong> and run our <strong>LoRa Transmitter</strong>‚Ä¶</p>
<p><a href="https://github.com/lupyuen/wisblock-lora-transmitter"><strong>wisblock-lora-transmitter</strong></a></p>
<p>Check that the <strong>LoRa Parameters</strong> are correct‚Ä¶</p>
<p><a href="https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp#L38-L54"><strong>LoRa Parameters for WisBlock Transmitter</strong></a></p>
</li>
<li>
<p>WisBlock transmits a 64-byte <strong>LoRa Message</strong> every 5 seconds‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>LoRap2p Tx Test
send: 48 65 6c 6c 6f 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a
OnTxDone</code></pre></div>
<p><a href="https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp#L120-L144">(‚Äú<code>Hello</code>‚Äù followed by 0, 1, 2, ‚Ä¶)</a></p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sx1262_test</code></pre></div></li>
<li>
<p>On NuttX we should see the same 64-byte <strong>LoRa Message</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>IRQ_RX_DONE
48 65 6c 6c 6f 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a
IRQ_PREAMBLE_DETECTED
IRQ_HEADER_VALID
receive_message</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/0d78b13871fca41ac6d812407890b29b">(See the Output Log)</a></p>
<p>Congratulations our SX1262 Library has successfully received the 64-byte LoRa Message from RAKwireless WisBlock!</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/sx1262-receive2.png" alt="Our SX1262 Library receives a LoRa Message from RAKwireless WisBlock" /></p>
<h1 id="spi-interface" class="section-header"><a href="#spi-interface">7 SPI Interface</a></h1>
<p><em>Porting the SX1262 Library from Linux to NuttX‚Ä¶ Was it difficult?</em></p>
<p>Not at all! NuttX works much like Linux because of its <a href="https://lupyuen.github.io/articles/nuttx"><strong>POSIX Compliance</strong></a>.</p>
<p>Most of the porting effort <a href="https://lupyuen.github.io/images/sx1262-git.png">(14 minutes!)</a> was spent on‚Ä¶</p>
<ol>
<li>
<p><strong>SPI Interface</strong></p>
</li>
<li>
<p><strong>GPIO Interface</strong></p>
</li>
</ol>
<p>Because the interfaces work differently on NuttX vs Linux.</p>
<p>Let‚Äôs dive into the SPI Interface: How we initialise the interface and transfer data over SPI.</p>
<p><img src="https://lupyuen.github.io/images/spi2-plan2.jpg" alt="SPI Test Driver" /></p>
<h2 id="initialise-spi" class="section-header"><a href="#initialise-spi">7.1 Initialise SPI</a></h2>
<p>In the previous article we have created an <strong>SPI Test Driver ‚Äú/dev/spitest0‚Äù</strong> that exposes the SPI Interface to NuttX Apps (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2"><strong>‚ÄúSPI on Apache NuttX OS‚Äù</strong></a></li>
</ul>
<p>Our SX1262 Library opens the SPI Test Driver to <strong>initialise the SPI Bus</strong> like so: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L663-L675">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// SPI Bus
static int spi = 0;

/// Chip Select Pin (GPIO Output)
static int cs = 0;

/// Init the SPI Bus. Return 0 on success.
static int init_spi(void) {
  //  Open the SPI Bus (SPI Test Driver)
  spi = open(&quot;/dev/spitest0&quot;, O_RDWR);
  assert(spi &gt; 0);

  //  Open GPIO Output for SPI Chip Select
  cs = open(&quot;/dev/gpio1&quot;, O_RDWR);
  assert(cs &gt; 0);
  return 0;
}</code></pre></div>
<p><strong>init_spi</strong> is called by <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L65-L77"><strong>SX126xIoInit</strong></a>, which is called by <a href="https://lupyuen.github.io/articles/sx1262#radioinit-initialise-lora-module"><strong>RadioInit</strong></a> and <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L173-L227"><strong>init_driver</strong></a></p>
<p>(We‚Äôve seen <strong>init_driver</strong> earlier in our Test App)</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radioinit-initialise-lora-module">(<strong>RadioInit</strong> is explained here)</a></p>
<p><em>Where are SPI Mode and SPI Frequency defined?</em></p>
<p><strong>SPI Mode</strong> and <strong>SPI Frequency</strong> are defined in the SPI Test Driver‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#configure-spi"><strong>‚ÄúConfigure SPI‚Äù</strong></a></li>
</ul>
<p><em>Why did we use GPIO Output?</em></p>
<p>We‚Äôre controlling the <strong>SPI Chip Select Pin</strong> ourselves via GPIO Output, as explained below‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#control-chip-select-with-gpio"><strong>‚ÄúControl Chip Select with GPIO‚Äù</strong></a></li>
</ul>
<p>More about GPIO Output in the next section.</p>
<p><img src="https://lupyuen.github.io/images/sx1262-driver2a.png" alt="Initialise SPI" /></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L677-L703">(Source)</a></p>
<h2 id="transfer-spi" class="section-header"><a href="#transfer-spi">7.2 Transfer SPI</a></h2>
<p>To <strong>transfer SPI Data</strong> to SX1262 via our SPI Test Driver, we do this: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L677-L703">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Blocking call to transmit and receive buffers on SPI. Return 0 on success.
static int transfer_spi(const uint8_t *tx_buf, uint8_t *rx_buf, uint16_t len) {
  assert(spi &gt; 0);
  assert(cs  &gt; 0);
  assert(len &gt; 0);
  assert(len &lt;= SPI_BUFFER_SIZE);
  printf(&quot;spi tx: &quot;); for (int i = 0; i &lt; len; i++) { printf(&quot;%02x &quot;, tx_buf[i]); } printf(&quot;\n&quot;);

  //  Set SPI Chip Select to Low
  int ret = ioctl(cs, GPIOC_WRITE, 0);
  assert(ret &gt;= 0);

  //  Transmit data over SPI
  int bytes_written = write(spi, tx_buf, len);
  assert(bytes_written == len);

  //  Receive SPI response
  int bytes_read = read(spi, rx_buf, len);
  assert(bytes_read == len);

  //  Set SPI Chip Select to High
  ret = ioctl(cs, GPIOC_WRITE, 1);
  assert(ret &gt;= 0);

  printf(&quot;spi rx: &quot;); for (int i = 0; i &lt; len; i++) { printf(&quot;%02x &quot;, rx_buf[i]); } printf(&quot;\n&quot;);
  return 0;
}</code></pre></div>
<p>Note that we control <strong>SPI Chip Select</strong> ourselves with GPIO Output. The code above is explained in‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#gpio-output-as-chip-select"><strong>‚ÄúGPIO Output as Chip Select‚Äù</strong></a></li>
</ul>
<p>Let‚Äôs watch how <strong>transfer_spi</strong> is called by our SX1262 Library.</p>
<p><img src="https://lupyuen.github.io/images/sx1262-driver3.png" alt="Transfer SPI" /></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L677-L703">(Source)</a></p>
<h2 id="transmit-message" class="section-header"><a href="#transmit-message">7.3 Transmit Message</a></h2>
<p>Our SX1262 Library calls this function to <strong>transmit a LoRa Message</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L506-L512">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int sx126x_write_buffer(const void* context, const uint8_t offset, const uint8_t* buffer, const uint8_t size) {
  //  Prepare the Write Buffer Command (2 bytes)
  uint8_t buf[SX126X_SIZE_WRITE_BUFFER] = { 0 };
  buf[0] = RADIO_WRITE_BUFFER;  //  Write Buffer Command: 0x0E
  buf[1] = offset;              //  Write Buffer Offset

  //  Transfer the Write Buffer Command to SX1262 over SPI
  return sx126x_hal_write(
    context,  //  Context
    buf,      //  Command Buffer
    SX126X_SIZE_WRITE_BUFFER,  //  Command Buffer Size (2 bytes)
    buffer,   //  Write Data Buffer
    size      //  Write Data Buffer Size
  );
}</code></pre></div>
<p>In this code we prepare a <strong>SX1262 Write Buffer Command</strong> (2 bytes) and pass the Command Buffer (plus Data Buffer) to <strong>sx126x_hal_write</strong>.</p>
<p>(Data Buffer contains the LoRa Message to be transmitted)</p>
<p>Note that <strong>Write Buffer Offset is always 0</strong>, because of <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L144-L147"><strong>SX126xSetPayload</strong></a> and <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L283-L289"><strong>SX126xWriteBuffer</strong></a>.</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radiosend-transmit-message">(<strong>SX126xSetPayload</strong> and <strong>SX126xWriteBuffer</strong> are explained here)</a></p>
<p><strong>sx126x_hal_write</strong> transfers the Command Buffer and Data Buffer over SPI: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L544-L581">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/**
 * Radio data transfer - write
 *
 * @remark Shall be implemented by the user
 *
 * @param [in] context          Radio implementation parameters
 * @param [in] command          Pointer to the buffer to be transmitted
 * @param [in] command_length   Buffer size to be transmitted
 * @param [in] data             Pointer to the buffer to be transmitted
 * @param [in] data_length      Buffer size to be transmitted
 *
 * @returns Operation status
 */
static int sx126x_hal_write( 
  const void* context, const uint8_t* command, const uint16_t command_length,
  const uint8_t* data, const uint16_t data_length ) {
  printf(&quot;sx126x_hal_write: command_length=%d, data_length=%d\n&quot;, command_length, data_length);

  //  Total length is command + data length
  uint16_t len = command_length + data_length;
  assert(len &gt; 0);
  assert(len &lt;= SPI_BUFFER_SIZE);

  //  Clear the SPI Transmit and Receive buffers
  memset(&amp;spi_tx_buf, 0, len);
  memset(&amp;spi_rx_buf, 0, len);

  //  Copy command bytes to SPI Transmit Buffer
  memcpy(&amp;spi_tx_buf, command, command_length);

  //  Copy data bytes to SPI Transmit Buffer
  memcpy(&amp;spi_tx_buf[command_length], data, data_length);

  //  Transmit and receive the SPI buffers
  int rc = transfer_spi(spi_tx_buf, spi_rx_buf, len);
  assert(rc == 0);
  return 0;
}</code></pre></div>
<p>We use an internal <strong>1024-byte buffer for SPI Transfers</strong>, so we‚Äôre hunky dory here: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L533-L540">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Max size of SPI transfers
#define SPI_BUFFER_SIZE 1024

/// SPI Transmit Buffer
static uint8_t spi_tx_buf[SPI_BUFFER_SIZE];

/// SPI Receive Buffer
static uint8_t spi_rx_buf[SPI_BUFFER_SIZE];</code></pre></div>
<p><strong>sx126x_hal_write</strong> calls <strong>transfer_spi</strong> to transfer the SPI Data.</p>
<p>(We‚Äôve seen <strong>transfer_spi</strong> earlier)</p>
<p>Thus <strong>transfer_spi</strong> looks highly sus for transmitting Long LoRa Messages.</p>
<p>What about receiving Long LoRa Messages?</p>
<h2 id="receive-message" class="section-header"><a href="#receive-message">7.4 Receive Message</a></h2>
<p>TODO</p>
<p>Our SX1262 Library calls this function to <strong>receive a LoRa Message</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L514-L522">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int sx126x_read_buffer(const void* context, const uint8_t offset, uint8_t* buffer, const uint8_t size) {
  //  Prepare the Read Buffer Command (3 bytes)
  uint8_t buf[SX126X_SIZE_READ_BUFFER] = { 0 };
  buf[0] = RADIO_READ_BUFFER;  //  Read Buffer Command: 0x1E
  buf[1] = offset;             //  Read Buffer Offset
  buf[2] = 0;                  //  NOP

  //  Transfer the Read Buffer Command to SX1262 over SPI
  int status = sx126x_hal_read( 
    context,  //  Context
    buf,      //  Command Buffer
    SX126X_SIZE_READ_BUFFER,  //  Command Buffer Size (3 bytes)
    buffer,   //  Read Data Buffer
    size,     //  Read Data Buffer Size
    NULL      //  Ignore the status
  );
  return status;
}</code></pre></div>
<p>In this code we prepare a <strong>SX1262 Read Buffer Command</strong> (3 bytes) and pass the Command Buffer (plus Data Buffer) to <strong>sx126x_hal_read</strong>.</p>
<p>(Data Buffer will contain the received LoRa Message)</p>
<p>Note that <strong>Read Buffer Offset is always 0</strong>, because of <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L149-L160"><strong>SX126xGetPayload</strong></a> and <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L291-L297"><strong>SX126xReadBuffer</strong></a>.</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#receive-done">(<strong>SX126xGetPayload</strong> and <strong>SX126xReadBuffer</strong> are explained here)</a></p>
<p><strong>sx126x_hal_read</strong> transfers the Command Buffer over SPI: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L583-L627">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/**
 * Radio data transfer - read
 *
 * @remark Shall be implemented by the user
 *
 * @param [in] context          Radio implementation parameters
 * @param [in] command          Pointer to the buffer to be transmitted
 * @param [in] command_length   Buffer size to be transmitted
 * @param [in] data             Pointer to the buffer to be received
 * @param [in] data_length      Buffer size to be received
 * @param [out] status          If not null, return the second SPI byte received as status
 *
 * @returns Operation status
 */
static int sx126x_hal_read( 
  const void* context, const uint8_t* command, const uint16_t command_length,
  uint8_t* data, const uint16_t data_length, uint8_t *status ) {
  printf(&quot;sx126x_hal_read: command_length=%d, data_length=%d\n&quot;, command_length, data_length);

  //  Total length is command + data length
  uint16_t len = command_length + data_length;
  assert(len &gt; 0);
  assert(len &lt;= SPI_BUFFER_SIZE);

  //  Clear the SPI Transmit and Receive buffers
  memset(&amp;spi_tx_buf, 0, len);
  memset(&amp;spi_rx_buf, 0, len);

  //  Copy command bytes to SPI Transmit Buffer
  memcpy(&amp;spi_tx_buf, command, command_length);

  //  Transmit and receive the SPI buffers
  int rc = transfer_spi(spi_tx_buf, spi_rx_buf, len);
  assert(rc == 0);

  //  Copy SPI Receive buffer to data buffer
  memcpy(data, &amp;spi_rx_buf[command_length], data_length);

  //  Return the second SPI byte received as status
  if (status != NULL) {
    assert(len &gt;= 2);
    *status = spi_rx_buf[1];
  }
  return 0;
}</code></pre></div>
<p>And returns the Data Buffer that has been read over SPI.</p>
<p><strong>sx126x_hal_read</strong> also calls <strong>transfer_spi</strong> to transfer the SPI Data.</p>
<h2 id="long-messages" class="section-header"><a href="#long-messages">7.5 Long Messages</a></h2>
<p>TODO</p>
<p>Let‚Äôs look back at our code in <a href="https://lupyuen.github.io/articles/sx1262#transmit-long-message"><strong>sx126x_write_buffer</strong></a>.</p>
<p>To transmit a LoRa Message, we send the <strong>WriteBuffer Command</strong> to SX1262 over SPI‚Ä¶</p>
<ol>
<li>
<p><strong>WriteBuffer Command:</strong> <code>0x0E</code></p>
</li>
<li>
<p><strong>WriteBuffer Offset:</strong> <code>0x00</code></p>
</li>
<li>
<p><strong>WriteBuffer Data:</strong> Transfer 29 bytes (max)</p>
</li>
</ol>
<p>This copies the <strong>entire LoRa Message</strong> into the SX1262 Transmit Buffer as a <strong>single (huge) chunk</strong>.</p>
<p>This appears in the <a href="https://github.com/lupyuen/lora-sx1262#send-message"><strong>Output Log</strong></a> as‚Ä¶</p>
<p>TODO</p>
<div class="example-wrap"><pre class="language-text"><code>sx126x_hal_write: 
  command_length=2, 
  data_length=29
spi tx: 
  0e 00 
  50 49 4e 47 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 
spi rx: 
  a2 a2 
  a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 </code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L237-L253">(‚Äú<code>50 49 4e 47</code>‚Äù is ‚Äú<code>PING</code>‚Äù followed by 0, 1, 2, ‚Ä¶)</a></p>
<p>To receive a LoRa Message, <a href="https://lupyuen.github.io/articles/sx1262#receive-long-message"><strong>sx126x_read_buffer</strong></a> sends this <strong>ReadBuffer Command</strong> to SX1262 over SPI‚Ä¶</p>
<ol>
<li>
<p><strong>ReadBuffer Command:</strong> <code>0x1E</code></p>
</li>
<li>
<p><strong>ReadBuffer Offset:</strong> <code>0x00</code></p>
</li>
<li>
<p><strong>ReadBuffer NOP:</strong> <code>0x00</code></p>
</li>
<li>
<p><strong>ReadBuffer Data:</strong> Transfer 28 bytes (max)</p>
</li>
</ol>
<p>Which appears in the <a href="https://github.com/lupyuen/lora-sx1262#receive-message"><strong>Output Log</strong></a> as‚Ä¶</p>
<p>TODO</p>
<div class="example-wrap"><pre class="language-text"><code>sx126x_hal_read: 
  command_length=3, 
  data_length=28
spi tx: 
  1e 00 00 
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
spi rx: 
  d2 d2 d2 
  48 65 6c 6c 6f 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 </code></pre></div>
<p><a href="https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp#L120-L144">(‚Äú<code>48 65 6c 6c 6f</code>‚Äù is ‚Äú<code>Hello</code>‚Äù followed by 0, 1, 2, ‚Ä¶)</a></p>
<h1 id="gpio-interface" class="section-header"><a href="#gpio-interface">8 GPIO Interface</a></h1>
<p>TODO</p>
<p><em>Besides SPI, what Interfaces do we need to control LoRa SX1262?</em></p>
<p>Our SX1262 Library needs a <strong>GPIO Interface</strong> to control these <strong>SX1262 Pins</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>DIO1</strong>: Used by SX1262 to signal that a LoRa Packet has been transmitted or received</p>
<p>(<strong>DIO1</strong> shifts from Low to High when that happens)</p>
</li>
<li>
<p><strong>BUSY</strong>: Read by our driver to check if SX1262 is busy</p>
<p>(<strong>BUSY</strong> is High when SX1262 is busy)</p>
</li>
<li>
<p><strong>NRESET</strong>: Toggled by our driver to reset the SX1262 module</p>
</li>
</ul>
<p>We may call the GPIO Interface that‚Äôs provided by NuttX‚Ä¶</p>
<ul>
<li>TODO</li>
</ul>
<p>But the current SX1262 Library <strong>doesn‚Äôt use GPIO yet</strong>.</p>
<p><em>Huh? SX1262 works without GPIO control?</em></p>
<p>We found some sneaky workarounds to <strong>control LoRa SX1262 without GPIO</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>DIO1</strong>: Because we don‚Äôt support GPIO Interrupts (yet), we <strong>poll the SX1262 Status every second</strong> to check if a LoRa Packet has been received.</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L126-L136">(See this)</a></p>
</li>
<li>
<p><strong>BUSY</strong>: Instead of reading this pin to check if SX1262 is busy, we <strong>sleep 10 milliseconds</strong>.</p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L171-L182">(See this)</a></p>
</li>
<li>
<p><strong>NRESET</strong>: To reset the SX1262 module, we <strong>manually restart our NuttX gadget</strong>.</p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L149-L169">(See this)</a></p>
</li>
</ul>
<p>These sneaky hacks will need to be fixed by calling the GPIO Interface.</p>
<p><em>What needs to be fixed for GPIO?</em></p>
<p>We need to mod these functions to call the <strong>NuttX GPIO Interface</strong>‚Ä¶</p>
<ol>
<li>
<p>Initialise the GPIO Pins: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L65-L77"><strong>SX126xIoInit</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/lorawan#appendix-bl602-spi-functions">(Explained here)</a></p>
</li>
<li>
<p>Register GPIO Interrupt Handler for DIO1: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L79-L91"><strong>SX126xIoIrqInit</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/lorawan#appendix-bl602-gpio-interrupts">(Explained here)</a></p>
</li>
<li>
<p>Reset SX1262 via GPIO: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L149-L169"><strong>SX126xReset</strong></a></p>
<div class="example-wrap"><pre class="language-c"><code>void SX126xReset(void) {
    //  TODO: Set Reset pin to Low
    //  rc = bl_gpio_output_set(SX126X_NRESET, 1);
    //  assert(rc == 0);

    //  Wait 1 ms
    DelayMs(1);

    //  TODO: Configure Reset pin as a GPIO Input Pin, no pullup, no pulldown
    //  rc = bl_gpio_enable_input(SX126X_NRESET, 0, 0);
    //  assert(rc == 0);

    //  Wait 6 ms
    DelayMs(6);
}</code></pre></div></li>
<li>
<p>Check SX1262 Busy State via GPIO: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L171-L182"><strong>SX126xWaitOnBusy</strong></a></p>
<p>(<strong>SX126xWaitOnBusy</strong> is called by <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L133-L142"><strong>SX126xCheckDeviceReady</strong></a>, which wakes up SX1262 before checking if SX1262 is busy)</p>
<div class="example-wrap"><pre class="language-c"><code>void SX126xWaitOnBusy(void) {
  //  TODO: Fix the GPIO check for busy state.
  //  while( bl_gpio_input_get_value( SX126X_BUSY_PIN ) == 1 );

  //  Meanwhile we sleep 10 milliseconds
  usleep(10 * 1000);
}</code></pre></div></li>
<li>
<p>Get DIO1 Pin State: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L337-L344"><strong>SX126xGetDio1PinState</strong></a></p>
<div class="example-wrap"><pre class="language-c"><code>uint32_t SX126xGetDio1PinState(void) {    
  //  TODO: Read and return DIO1 Pin State
  //  return bl_gpio_input_get_value( SX126X_DIO1 );

  //  Meanwhile we always return 0
  return 0;
}</code></pre></div></li>
</ol>
<p>When we have implemented <strong>GPIO Interrupts</strong> in our driver, we can remove the <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L126-L136"><strong>Event Polling</strong></a>. And we run a <strong>Background Thread</strong> to handle LoRa Events.</p>
<p>Here‚Äôs how we‚Äôll do multithreading‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/usb-handler.jpg" alt="Multithreading with NimBLE Porting Layer" /></p>
<h1 id="multithreading-with-nimble-porting-layer" class="section-header"><a href="#multithreading-with-nimble-porting-layer">9 Multithreading with NimBLE Porting Layer</a></h1>
<p>TODO</p>
<h2 id="nimble-porting-layer" class="section-header"><a href="#nimble-porting-layer">9.1 NimBLE Porting Layer</a></h2>
<p>TODO</p>
<p><em>Do we call any open source libraries in our SX1262 Library?</em></p>
<p>Yes we call <strong>NimBLE Porting Layer</strong>, the open source library for Multithreading Functions‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lora2#multitask-with-nimble-porting-layer"><strong>Multitask with NimBLE Porting Layer</strong></a></li>
</ul>
<p>To transmit and receive LoRa Messages we need <strong>Timers and Background Threads</strong>. Which are provided by NimBLE Porting Layer.</p>
<p><em>Have we used NimBLE Porting Layer before?</em></p>
<p>Yep we used NimBLE Porting Layer in the <strong>LoRa SX1262 and SX1276 Drivers</strong> for BL602‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lora2"><strong>‚ÄúPineCone BL602 RISC-V Board Receives LoRa Packets‚Äù</strong></a></li>
</ul>
<p>So we‚Äôre really fortunate that NimBLE Porting Layer complies on NuttX as well.</p>
<p><em>How will we receive LoRa Messages with GPIO Interrupts?</em></p>
<p>After we have implemented <strong>GPIO Interrupts</strong> in our SX1262 Library, this is how we‚Äôll <strong>receive LoRa Messages</strong> (see pic above)‚Ä¶</p>
<ol>
<li>
<p>When SX1262 receives a LoRa Message, it triggers a <strong>GPIO Interrupt</strong> on Pin DIO1</p>
</li>
<li>
<p>GPIO Driver forwards the GPIO Interrupt to our Interrupt Handler Function <a href="https://lupyuen.github.io/articles/lora2#gpio-interrupt-handler"><strong>handle_gpio_interrupt</strong></a></p>
</li>
<li>
<p><strong>handle_gpio_interrupt</strong> enqueues an Event into our <strong>Event Queue</strong></p>
</li>
<li>
<p>Our <strong>Background Thread</strong> removes the Event from the Event Queue and calls <a href="https://lupyuen.github.io/articles/sx1262#radioondioirq"><strong>RadioOnDioIrq</strong></a> to process the received LoRa Message</p>
</li>
</ol>
<p>We handle GPIO Interrupts the same way in our <strong>LoRa SX1262 Driver for BL602</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lorawan#appendix-bl602-gpio-interrupts"><strong>‚ÄúBL602 GPIO Interrupts‚Äù</strong></a></li>
</ul>
<p><em>Why do we need a Background Thread?</em></p>
<p>This will allow our LoRa Application to <strong>run without blocking</strong> (waiting) on incoming LoRa Messages.</p>
<p>This is especially useful when we implement <strong>LoRaWAN with our SX1262 Library</strong>, because LoRaWAN needs to handle <strong>asynchronous messages</strong> in the background.</p>
<p><a href="https://lupyuen.github.io/articles/lorawan#join-network-request">(Like when we join a LoRaWAN Network)</a></p>
<p><em>How will we implement the Background Thread and Event Queue?</em></p>
<p>We‚Äôll call <strong>NimBLE Porting Layer</strong>, the open source library for Multithreading Functions‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lora2#multitask-with-nimble-porting-layer"><strong>Multitask with NimBLE Porting Layer</strong></a></li>
</ul>
<p>Which has been compiled into our SX1262 Library‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/lora-sx1262/tree/nuttx/npl/linux/src"><strong>npl/linux/src</strong></a></li>
</ul>
<p>The code below shall be updated to <strong>start the Background Thread</strong>: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L369-L388">sx1262_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// TODO: Create a Background Thread to handle LoRa Events
static void create_task(void) {
  //  Init the Event Queue
  ble_npl_eventq_init(&amp;event_queue);

  //  Init the Event
  ble_npl_event_init(
    &amp;event,        //  Event
    handle_event,  //  Event Handler Function
    NULL           //  Argument to be passed to Event Handler
  );

  //  TODO: Create a Background Thread to process the Event Queue
  //  nimble_port_freertos_init(task_callback);
}</code></pre></div>
<p>And we shall implement the GPIO Interrupt Handler Function <a href="https://lupyuen.github.io/articles/lora2#gpio-interrupt-handler"><strong>handle_gpio_interrupt</strong></a> for Linux.</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L357-L432">(We don‚Äôt need to code the Event Queue, it has been done here)</a></p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">10 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Now that we have NuttX talking OK to the SX1262 LoRa Transceiver‚Ä¶ We‚Äôre ready to port <strong>LoRa and LoRaWAN</strong> to NuttX!</p>
<p>We‚Äôll port this LoRa + LoRaWAN Stack‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lorawan"><strong>‚ÄúPineCone BL602 Talks LoRaWAN‚Äù</strong></a></li>
</ul>
<p>Over the next couple of articles we shall <strong>migrate the LoRa + LoRaWAN code incrementally</strong> to NuttX‚Ä¶</p>
<ol>
<li>
<p>Initially as a <strong>NuttX App Library</strong> running in a NuttX App</p>
<p>(Because it‚Äôs easier to code and troubleshoot)</p>
</li>
<li>
<p>Eventually moving into a <strong>NuttX Device Driver</strong></p>
<p>(Because it‚Äôs The Right Thing)</p>
</li>
<li>
<p>By implementing <strong>ioctl()</strong> operations for LoRaWAN</p>
<p><a href="https://github.com/apache/incubator-nuttx/blob/master/drivers/wireless/lpwan/sx127x/sx127x.c#L954-L1162">(Similar to this SX1276 Device Driver)</a></p>
</li>
</ol>
<p>I‚Äôm still super curious about porting the <a href="https://lupyuen.github.io/articles/nuttx#rust-on-nuttx"><strong>Rust Embedded HAL</strong></a> to NuttX. We might start soon with GPIO and SPI to see whether the concept is feasible.</p>
<p>Stay Tuned!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/sx1262.md"><code>lupyuen.github.io/src/sx1262.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">11 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1471179698268893188">this Twitter Thread</a></p>
</li>
<li>
<p>We have already ported LoRaWAN to <strong>BL602 IoT SDK</strong> <a href="https://lupyuen.github.io/articles/lorawan">(see this)</a>, why are we porting again to NuttX?</p>
<p>Regrettably BL602 IoT SDK has been revamped (without warning) to the <strong>new ‚Äúhosal‚Äù HAL</strong> <a href="https://twitter.com/MisterTechBlog/status/1456259223323508748">(see this)</a>, and the LoRaWAN Stack will <strong>no longer work</strong> on the revamped BL602 IoT SDK.</p>
<p>For easier maintenance, we shall <strong>code our BL602 and BL604 projects with Apache NuttX OS</strong> instead.</p>
<p>(Which won‚Äôt get revamped overnight!)</p>
</li>
</ol>
<h1 id="appendix-create-a-nuttx-library" class="section-header"><a href="#appendix-create-a-nuttx-library">12 Appendix: Create a NuttX Library</a></h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>This section explains the steps to create a <strong>NuttX Library</strong> named <strong>‚Äúlibsx1262‚Äù</strong>.</p>
<p>(Change ‚Äúlibsx1262‚Äù to the desired name of our library)</p>
<ol>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/incubator-nuttx/tree/newlibrary/libs"><strong>‚Äúnuttx/libs‚Äù</strong></a> folder</p>
</li>
<li>
<p>Copy the <strong>‚Äúlibdsp‚Äù</strong> subfolder and paste it as <strong>‚Äúlibsx1262‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/sx1262-clone1.png" alt="Copy the ‚Äúlibdsp‚Äù subfolder and paste it as ‚Äúlibsx1262‚Äù" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/commit/6596edd6eb47547f41f647e6da1e08d33faacf4f#diff-739a304e183a900711f6497e6544a814ef5367da89ccedad067fc1a3f0814b41">(Source)</a></p>
</li>
<li>
<p>Inside the <strong>‚Äúlibsx1262‚Äù</strong> folder, delete all source files except <strong>‚Äúlib_misc.c‚Äù</strong></p>
</li>
<li>
<p>Edit <strong>‚ÄúMakefile‚Äù</strong>. Remove all ‚ÄúCSRCS‚Äù lines except‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>CSRCS += lib_misc.c</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/newlibrary/libs/libsx1262/Makefile">(See Makefile)</a></p>
</li>
<li>
<p>Inside the <strong>‚Äúlibsx1262‚Äù</strong> folder, search and replace all <strong>‚Äúlibdsp‚Äù</strong> by <strong>‚Äúlibsx1262‚Äù</strong></p>
<p>Be sure to <strong>Preserve Case!</strong></p>
<p><img src="https://lupyuen.github.io/images/sx1262-clone2a.png" alt="Change all ‚Äúlibdsp‚Äù to ‚Äúlibsx1262‚Äù" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/commit/9fe76d3bca389642e71ac405c8343b280384276d#diff-a9d844356942ef04a0efe9eac47f95390756485e2aec9cd4018831af2e8e9409">(See changes)</a></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/tree/newlibrary/libs/libsx1262">(See libsx1262 folder)</a></p>
</li>
<li>
<p>Edit the file <strong>‚ÄúKconfig‚Äù</strong></p>
<p>Update the section <strong>‚Äúmenuconfig LIBSX1262‚Äù</strong> as follows‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>menuconfig LIBSX1262
    bool &quot;Semtech SX1262 Library&quot;
    default n
    ---help---
        Enable build for Semtech SX1262 functions    </code></pre></div>
<p><img src="https://lupyuen.github.io/images/sx1262-clone4.png" alt="Update Kconfig" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/newlibrary/libs/libsx1262/Kconfig">(Source)</a></p>
</li>
<li>
<p>Edit the file <strong>‚Äúlib_misc.c‚Äù</strong>.  Remove all the code and add‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#include &lt;stdio.h&gt;  /* TODO: Fix this for kernel mode */
#include &lt;sx1262.h&gt;

void test_libsx1262(void)
{
  puts(&quot;libsx1262 OK!&quot;);
}</code></pre></div>
<p>We‚Äôll call this function in a while.</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/newlibrary/libs/libsx1262/lib_misc.c">(See lib_misc.c)</a></p>
</li>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/incubator-nuttx/blob/newlibrary/include"><strong>‚Äúnuttx/include‚Äù</strong></a> folder</p>
</li>
<li>
<p>Copy the file <strong>‚Äúdsp.h‚Äù</strong> and paste it as <strong>‚Äúsx1262.h‚Äù</strong></p>
</li>
<li>
<p>Inside the file <strong>‚Äúsx1262.h‚Äù</strong>, search and replace all <strong>‚Äúdsp‚Äù</strong> by <strong>‚Äúsx1262‚Äù</strong></p>
<p>Remember to <strong>Preserve Case!</strong></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/newlibrary/include/sx1262.h">(See sx1262.h)</a></p>
</li>
<li>
<p>Edit the file <strong>‚Äúsx1262.h‚Äù</strong>, remove all Public Functions Prototypes and add‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>void test_libsx1262(void);</code></pre></div>
<p>We‚Äôll test this function in a while.</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/sx1262.h">(See sx1262.h)</a></p>
</li>
</ol>
<h2 id="update-makefiles-and-kconfig" class="section-header"><a href="#update-makefiles-and-kconfig">12.1 Update Makefiles and Kconfig</a></h2>
<p>Next we update the Makefiles and Kconfig so that NuttX will build our library‚Ä¶</p>
<ol>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/incubator-nuttx/tree/newlibrary/tools"><strong>‚Äúnuttx/tools‚Äù</strong></a> folder</p>
</li>
<li>
<p>Edit the file <strong>‚ÄúDirectories.mk‚Äù</strong></p>
<p>After <strong>‚Äúlibdsp‚Äù</strong>, insert this section‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>ifeq ($(CONFIG_LIBSX1262),y)
KERNDEPDIRS += libs$(DELIM)libsx1262
else
CLEANDIRS += libs$(DELIM)libsx1262
endif</code></pre></div>
<p>As shown below‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/sx1262-clone5.png" alt="Update ‚ÄúDirectories.mk‚Äù" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/commit/8bd31da9abccbcfdd1b9b1ccfd22bd41803ac7f8#diff-f9d35d43770d39092a663e665e82ae1d84a9e0da3d0d10c407acada6a40cd281">(Source)</a></p>
</li>
<li>
<p>Edit the files <strong>‚ÄúFlatLibs.mk‚Äù</strong>, <strong>‚ÄúKernelLibs.mk‚Äù</strong> and <strong>‚ÄúProtectedLibs.mk‚Äù</strong></p>
<p>After <strong>‚Äúlibopenamp‚Äù</strong>, insert this section‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>ifeq ($(CONFIG_LIBSX1262),y)
NUTTXLIBS += staging$(DELIM)libsx1262$(LIBEXT)
endif</code></pre></div>
<p>As shown below‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/sx1262-clone6.png" alt="Update Makefiles" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/commit/b381a99e7512d09d74db4da982826b5e40b2606a#diff-f9d35d43770d39092a663e665e82ae1d84a9e0da3d0d10c407acada6a40cd281">(Source)</a></p>
</li>
<li>
<p>Edit the file <strong>‚ÄúLibTargets.mk‚Äù</strong></p>
<p>After <strong>‚Äúlibdsp‚Äù</strong>, insert this section‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>libs$(DELIM)libsx1262$(DELIM)libsx1262$(LIBEXT): pass2dep
    $(Q) $(MAKE) -C libs$(DELIM)libsx1262 libsx1262$(LIBEXT) EXTRAFLAGS=&quot;$(EXTRAFLAGS)&quot;

staging$(DELIM)libsx1262$(LIBEXT): libs$(DELIM)libsx1262$(DELIM)libsx1262$(LIBEXT)
    $(Q) $(call INSTALL_LIB,$&lt;,$@)</code></pre></div>
<p>As shown in the pic above.</p>
</li>
<li>
<p>Browse to the <a href="https://github.com/lupyuen/incubator-nuttx/tree/newlibrary"><strong>‚Äúnuttx‚Äù</strong></a> folder</p>
</li>
<li>
<p>Edit the file <strong>‚ÄúKconfig‚Äù</strong></p>
<p>Inside the section <strong>menu ‚ÄúLibrary Routines‚Äù</strong>, add this line‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>source &quot;libs/libsx1262/Kconfig&quot;</code></pre></div>
<p><img src="https://lupyuen.github.io/images/sx1262-clone3a.png" alt="Update Root Kconfig" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/commit/6a18348842b5fcec6a9fe8672c0de380b889086c">(Source)</a></p>
</li>
<li>
<p>Run the following‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># TODO: Change this to the path of our &quot;incubator-nuttx&quot; folder
cd nuttx/nuttx

# Preserve the Build Config
cp .config ../config

# Erase the Build Config and Kconfig files
make distclean

# For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

# For ESP32: Configure the build for ESP32.
# TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

# Restore the Build Config
cp ../config .config

# Edit the Build Config
make menuconfig </code></pre></div></li>
</ol>
<h2 id="enable-library" class="section-header"><a href="#enable-library">12.2 Enable Library</a></h2>
<p>We enable our library as follows‚Ä¶</p>
<ol>
<li>
<p>In <strong>menuconfig</strong>, select <strong>‚ÄúLibrary Routines‚Äù</strong></p>
<p>Check the box for <strong>‚ÄúSemtech SX1262 Library‚Äù</strong></p>
<p><img src="https://lupyuen.github.io/images/sx1262-clone7.png" alt="Enable Library" /></p>
</li>
<li>
<p>Hit <strong>‚ÄúSave‚Äù</strong> then <strong>‚ÄúOK‚Äù</strong> to save the NuttX Configuration to <strong>‚Äú.config‚Äù</strong></p>
</li>
<li>
<p>Hit <strong>‚ÄúExit‚Äù</strong> until <strong>menuconfig</strong> quits</p>
</li>
</ol>
<h2 id="verify-library" class="section-header"><a href="#verify-library">12.3 Verify Library</a></h2>
<p>To verify our library‚Ä¶</p>
<ol>
<li>
<p>We create a simple NuttX App: <a href="https://github.com/lupyuen/incubator-nuttx-apps/tree/newlibrary/examples/sx1262_test"><strong>apps/examples/sx1262_test</strong></a></p>
<div class="example-wrap"><pre class="language-c"><code>#include &lt;nuttx/config.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sx1262.h&gt;

int main(int argc, FAR char *argv[])
{
  printf(&quot;Sx1262_test, World!!\n&quot;);

  /* Call SX1262 Library */

  test_libsx1262();

  return 0;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/newlibrary/examples/sx1262_test/sx1262_test_main.c">(Source)</a></p>
</li>
<li>
<p>Build (‚Äúmake‚Äù), flash and run the NuttX Firmware on BL602 or ESP32.</p>
</li>
<li>
<p>In the NuttX Shell, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sx1262_test</code></pre></div></li>
<li>
<p>We should see the message‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>libsx1262 OK!</code></pre></div>
<p>Congratulations our library is now running on NuttX!</p>
<p><img src="https://lupyuen.github.io/images/sx1262-library4.png" alt="Our library runs OK" /></p>
</li>
</ol>
<h1 id="appendix-build-flash-and-run-nuttx" class="section-header"><a href="#appendix-build-flash-and-run-nuttx">13 Appendix: Build, Flash and Run NuttX</a></h1>
<p><em>(For BL602 and ESP32)</em></p>
<p>Below are the steps to build, flash and run NuttX on BL602 and ESP32.</p>
<p>The instructions below will work on <strong>Linux (Ubuntu)</strong>, <strong>WSL (Ubuntu)</strong> and <strong>macOS</strong>.</p>
<p><a href="https://nuttx.apache.org/docs/latest/quickstart/install.html">(Instructions for other platforms)</a></p>
<p><a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(See this for Arch Linux)</a></p>
<h2 id="build-nuttx" class="section-header"><a href="#build-nuttx">13.1 Build NuttX</a></h2>
<p>Follow these steps to build NuttX for BL602 or ESP32‚Ä¶</p>
<ol>
<li>
<p>Install the build prerequisites‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Assume that we have downloaded and configured our NuttX code‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#build-the-firmware"><strong>‚ÄúBuild the Firmware‚Äù</strong></a></p>
</li>
<li>
<p>To build NuttX, enter this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>make</code></pre></div></li>
<li>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>LD: nuttx
CP: nuttx.hex
CP: nuttx.bin</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/8f725c278c25e209c1654469a2855746">(See the complete log for BL602)</a></p>
</li>
<li>
<p><strong>For BL602:</strong> Copy the <strong>NuttX Firmware</strong> to the <strong>blflash</strong> directory‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  For Linux and macOS:
#  TODO: Change $HOME/blflash to the full path of blflash
cp nuttx.bin $HOME/blflash

#  For WSL:
#  TODO: Change /mnt/c/blflash to the full path of blflash in Windows
#  /mnt/c/blflash refers to c:\blflash
cp nuttx.bin /mnt/c/blflash</code></pre></div>
<p>(We‚Äôll cover <strong>blflash</strong> in the next section)</p>
<p>For WSL we need to run <strong>blflash</strong> under plain old Windows CMD (not WSL) because it needs to access the COM port.</p>
</li>
<li>
<p>In case of problems, refer to the <strong>NuttX Docs</strong>‚Ä¶</p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/risc-v/bl602/index.html"><strong>‚ÄúBL602 NuttX‚Äù</strong></a></p>
<p><a href="https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html"><strong>‚ÄúESP32 NuttX‚Äù</strong></a></p>
<p><a href="https://nuttx.apache.org/docs/latest/quickstart/install.html"><strong>‚ÄúInstalling NuttX‚Äù</strong></a></p>
</li>
</ol>
<blockquote>
<p><img src="https://lupyuen.github.io/images/nuttx-build2.png" alt="Building NuttX" /></p>
</blockquote>
<h2 id="flash-nuttx" class="section-header"><a href="#flash-nuttx">13.2 Flash NuttX</a></h2>
<p><strong>For ESP32:</strong> <a href="https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html#flashing"><strong>See instructions here</strong></a> <a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(Also check out this article)</a></p>
<p><strong>For BL602:</strong> Follow these steps to install <strong>blflash</strong>‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>‚ÄúInstall rustup‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>‚ÄúDownload and build blflash‚Äù</strong></a></p>
</li>
</ol>
<p>We assume that our Firmware Binary File <strong>nuttx.bin</strong> has been copied to the <strong>blflash</strong> folder.</p>
<p>Set BL602 / BL604 to <strong>Flashing Mode</strong> and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>High</strong> <a href="https://lupyuen.github.io/images/pinedio-high.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ol>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>Enter these commands to flash <strong>nuttx.bin</strong> to BL602 / BL604 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># TODO: Change ~/blflash to the full path of blflash
cd ~/blflash

# For Linux:
sudo cargo run flash nuttx.bin \
    --port /dev/ttyUSB0

# For macOS:
cargo run flash nuttx.bin \
    --port /dev/tty.usbserial-1420 \
    --initial-baud-rate 230400 \
    --baud-rate 230400

# For Windows: Change COM5 to the BL602 / BL604 Serial Port
cargo run flash nuttx.bin --port COM5</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9c0dbd75bb6b8e810939a36ffb5c399f">(See the Output Log)</a></p>
<p>For WSL: Do this under plain old Windows CMD (not WSL) because <strong>blflash</strong> needs to access the COM port.</p>
<p><a href="https://github.com/apache/incubator-nuttx/issues/4336">(Flashing WiFi apps to BL602 / BL604? Remember to use <strong>bl_rfbin</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">(More details on flashing firmware)</a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-flash2.png" alt="Flashing NuttX" /></p>
<h2 id="run-nuttx" class="section-header"><a href="#run-nuttx">13.3 Run NuttX</a></h2>
<p><strong>For ESP32:</strong> Use Picocom to connect to ESP32 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>picocom -b 115200 /dev/ttyUSB0</code></pre></div>
<p><a href="https://popolon.org/gblog3/?p=1977&amp;lang=en">(More about this)</a></p>
<p><strong>For BL602:</strong> Set BL602 / BL604 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>Low</strong> <a href="https://lupyuen.github.io/images/pinedio-low.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ol>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>After restarting, connect to BL602 / BL604‚Äôs UART Port at 2 Mbps like so‚Ä¶</p>
<p><strong>For Linux:</strong></p>
<div class="example-wrap"><pre class="language-bash"><code>sudo screen /dev/ttyUSB0 2000000</code></pre></div>
<p><strong>For macOS:</strong> Use CoolTerm (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>For Windows:</strong> Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>Alternatively:</strong> Use the Web Serial Terminal (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p>Press Enter to reveal the <strong>NuttX Shell</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-10.2.0-RC0
nsh&gt;</code></pre></div>
<p>Congratulations NuttX is now running on BL602 / BL604!</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">(More details on connecting to BL602 / BL604)</a></p>
<p><img src="https://lupyuen.github.io/images/nuttx-boot2.png" alt="Running NuttX" /></p>
<p><strong>macOS Tip:</strong> Here‚Äôs the script I use to build, flash and run NuttX on macOS, all in a single step: <a href="https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af">run.sh</a></p>
<p><img src="https://lupyuen.github.io/images/spi2-script.png" alt="Script to build, flash and run NuttX on macOS" /></p>
<p><a href="https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af">(Source)</a></p>
<h1 id="appendix-radio-functions" class="section-header"><a href="#appendix-radio-functions">14 Appendix: Radio Functions</a></h1>
<p>TODO</p>
<p>In this section we explain the Platform-Independent (Linux and BL602) <strong>Radio Functions</strong>, which are defined in <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c">radio.c</a></p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L523-L559"><strong>RadioInit:</strong></a> Initialise LoRa SX1262</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L600-L604"><strong>RadioSetChannel:</strong></a> Set LoRa Frequency</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L788-L908"><strong>RadioSetTxConfig:</strong></a> Set LoRa Transmit Configuration</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L661-L786"><strong>RadioSetRxConfig:</strong></a> Set LoRa Receive Configuration</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1069-L1098"><strong>RadioSend:</strong></a> Transmit a LoRa Message</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1117-L1138"><strong>RadioRx:</strong></a> Receive one LoRa Message</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1314-L1460"><strong>RadioIrqProcess:</strong></a> Process Transmit and Receive Interrupts</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1100-L1109"><strong>RadioSleep:</strong></a> Switch SX1262 to low-power sleep mode</p>
</li>
</ul>
<h2 id="radioinit-initialise-lora-module" class="section-header"><a href="#radioinit-initialise-lora-module">14.1 RadioInit: Initialise LoRa Module</a></h2>
<p>TODO</p>
<p><strong>RadioInit</strong> initialises the LoRa SX1262 Module: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L523-L559">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void RadioInit( RadioEvents_t *events ) {
  //  We copy the Event Callbacks from &quot;events&quot;, because
  //  &quot;events&quot; may be stored on the stack
  assert(events != NULL);
  memcpy(&amp;RadioEvents, events, sizeof(RadioEvents));
  //  Previously: RadioEvents = events;</code></pre></div>
<p>The function begins by copying the list of <strong>Radio Event Callbacks</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>TxDone</strong>: Called when a LoRa Message has been transmitted</p>
</li>
<li>
<p><strong>RxDone</strong>: Called when a LoRa Message has been received</p>
</li>
<li>
<p><strong>TxTimeout</strong>: Called upon timeout when transmitting a LoRa Message</p>
</li>
<li>
<p><strong>RxTimeout</strong>: Called upon timeout when receiving a LoRa Message</p>
</li>
<li>
<p><strong>RxError</strong>: Called when a LoRa Message has been received with CRC Error</p>
</li>
</ul>
<p>This differs from the Semtech Reference Implementation, which copies the pointer to <strong>RadioEvents_t</strong> instead of the entire <strong>RadioEvents_t</strong>.</p>
<p>(Which causes problems when <strong>RadioEvents_t</strong> lives on the stack)</p>
<p>Next we <strong>init the SPI and GPIO Ports</strong>, wake up the LoRa Module, and init the TCXO Control and RF Switch Control.</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Init SPI and GPIO Ports, wake up the LoRa Module,
  //  init TCXO Control and RF Switch Control.
  SX126xInit( RadioOnDioIrq );</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L112-L131">(<strong>SX126xInit</strong> is defined here)</a></p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radioondioirq">(<strong>RadioOnDioIrq</strong> is explained here)</a></p>
<p>We set the LoRa Module to <strong>Standby Mode</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Set LoRa Module to standby mode
  SX126xSetStandby( STDBY_RC );</code></pre></div>
<p>We set the <strong>Power Regulation: LDO or DC-DC</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  TODO: Declare the power regulation used to power the device
  //  This command allows the user to specify if DC-DC or LDO is used for power regulation.
  //  Using only LDO implies that the Rx or Tx current is doubled

  //  #warning SX126x is set to LDO power regulator mode (instead of DC-DC)
  //  SX126xSetRegulatorMode( USE_LDO );   //  Use LDO

  //  #warning SX126x is set to DC-DC power regulator mode (instead of LDO)
  SX126xSetRegulatorMode( USE_DCDC );  //  Use DC-DC</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L390-L393">(<strong>SX126xSetRegulatorMode</strong> is defined here)</a></p>
<p>This depends on how our LoRa Module is wired for power.</p>
<p>For now we‚Äôre using <strong>DC-DC</strong> Power Regulation. (To be verified)</p>
<p><a href="https://lupyuen.github.io/articles/lorawan#dc-dc-vs-ldo">(More about LDO vs DC-DC Power Regulation)</a></p>
<p>We set the <strong>Base Addresses</strong> of the Read and Write Buffers to 0‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Set the base addresses of the Read and Write Buffers to 0
  SX126xSetBufferBaseAddress( 0x00, 0x00 );</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L697-L704">(<strong>SX126xSetBufferBaseAddress</strong> is defined here)</a></p>
<p>The Read and Write Buffers are accessed by <a href="https://lupyuen.github.io/articles/sx1262#receive-long-message"><strong>sx126x_read_buffer</strong></a> and <a href="https://lupyuen.github.io/articles/sx1262#transmit-long-message"><strong>sx126x_write_buffer</strong></a>.</p>
<p>We set the <strong>Transmit Power</strong> and the <strong>Ramp Up Time</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  TODO: Set the correct transmit power and ramp up time
  SX126xSetTxParams( 22, RADIO_RAMP_3400_US );
  //  TODO: Previously: SX126xSetTxParams( 0, RADIO_RAMP_200_US );</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L528-L576">(<strong>SX126xSetTxParams</strong> is defined here)</a></p>
<p><strong>Ramp Up Time</strong> is the duration (in microseconds) we need to wait for SX1262‚Äôs Power Amplifier to ramp up (charge up) to the configured Transmit Power.</p>
<p>For easier testing we have set the Transmit Power to <strong>22 dBm</strong> (highest power) and Ramp Up Time to <strong>3400 microseconds</strong> (longest duration).</p>
<p>(To give sufficient time for the Power Amplifier to ramp up to the highest Transmit Power)</p>
<p>After testing we should revert to the <strong>Default Transmit Power</strong> (0) and <strong>Ramp Up Time</strong> (200 microseconds).</p>
<p><a href="https://lupyuen.github.io/articles/lorawan#transmit-power">(More about the Transmit Power)</a></p>
<p><a href="https://lupyuen.github.io/articles/lorawan#over-current-protection">(Over Current Protection in <strong>SX126xSetTxParams</strong>)</a></p>
<p>We configure which <strong>LoRa Events will trigger interrupts</strong> on each DIO Pin‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Set the DIO Interrupt Events:
  //  All LoRa Events will trigger interrupts on DIO1
  SX126xSetDioIrqParams(
    IRQ_RADIO_ALL,   //  Interrupt Mask
    IRQ_RADIO_ALL,   //  Interrupt Events for DIO1
    IRQ_RADIO_NONE,  //  Interrupt Events for DIO2
    IRQ_RADIO_NONE   //  Interrupt Events for DIO3
  );</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L457-L470">(<strong>SX126xSetDioIrqParams</strong> is defined here)</a></p>
<p>(All LoRa Events will trigger interrupts on DIO1)</p>
<p>We define the SX1262 Registers that will be restored from <strong>Retention Memory</strong> when waking up from Warm Start Mode‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Add registers to the retention list (4 is the maximum possible number)
  RadioAddRegisterToRetentionList( REG_RX_GAIN );
  RadioAddRegisterToRetentionList( REG_TX_MODULATION );</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1167-L1195">(<strong>RadioAddRegisterToRetentionList</strong> is defined here)</a></p>
<p>Finally we init the Timeout Timers (from NimBLE Porting Layer) for <strong>Transmit Timeout</strong> and <strong>Receive Timeout</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Initialize driver timeout timers
  TimerInit( &amp;TxTimeoutTimer, RadioOnTxTimeoutIrq );
  TimerInit( &amp;RxTimeoutTimer, RadioOnRxTimeoutIrq );

  //  Interrupt not fired yet
  IrqFired = false;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L361-L380">(<strong>TimerInit</strong> is defined here)</a></p>
<h2 id="radiosetchannel-set-lora-frequency" class="section-header"><a href="#radiosetchannel-set-lora-frequency">14.2 RadioSetChannel: Set LoRa Frequency</a></h2>
<p>TODO</p>
<p><strong>RadioSetChannel</strong> sets the LoRa Frequency: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L600-L604">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void RadioSetChannel( uint32_t freq ) {
  SX126xSetRfFrequency( freq );
}</code></pre></div>
<p><strong>RadioSetChannel</strong> passes the LoRa Frequency (like <code>923000000</code> for 923 MHz) to <strong>SX126xSetRfFrequency</strong>.</p>
<p><strong>SX126xSetRfFrequency</strong> is defined as follows: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L497-L514">sx126x.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void SX126xSetRfFrequency( uint32_t frequency ) {
  uint8_t buf[4];
  if( ImageCalibrated == false ) {
    SX126xCalibrateImage( frequency );
    ImageCalibrated = true;
  }
  uint32_t freqInPllSteps = SX126xConvertFreqInHzToPllStep( frequency );
  buf[0] = ( uint8_t )( ( freqInPllSteps &gt;&gt; 24 ) &amp; 0xFF );
  buf[1] = ( uint8_t )( ( freqInPllSteps &gt;&gt; 16 ) &amp; 0xFF );
  buf[2] = ( uint8_t )( ( freqInPllSteps &gt;&gt; 8 ) &amp; 0xFF );
  buf[3] = ( uint8_t )( freqInPllSteps &amp; 0xFF );
  SX126xWriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L408-L438">(<strong>SX126xCalibrateImage</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L812-L826">(<strong>SX126xConvertFreqInHzToPllStep</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L204-L217">(<strong>SX126xWriteCommand</strong> is defined here)</a></p>
<h2 id="radiosettxconfig-set-transmit-configuration" class="section-header"><a href="#radiosettxconfig-set-transmit-configuration">14.3 RadioSetTxConfig: Set Transmit Configuration</a></h2>
<p>TODO</p>
<p><strong>RadioSetTxConfig</strong> sets the LoRa Transmit Configuration: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L788-L908">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void RadioSetTxConfig( RadioModems_t modem, int8_t power, uint32_t fdev,
  uint32_t bandwidth, uint32_t datarate,
  uint8_t coderate, uint16_t preambleLen,
  bool fixLen, bool crcOn, bool freqHopOn,
  uint8_t hopPeriod, bool iqInverted, uint32_t timeout ) {

  //  LoRa Modulation or FSK Modulation?
  switch( modem ) {
    case MODEM_FSK:
      //  Omitted: FSK Modulation
      ...</code></pre></div>
<p>Since we‚Äôre using <strong>LoRa Modulation</strong> instead of FSK Modulation, we skip the section on FSK Modulation.</p>
<p>We begin by populating the <strong>Modulation Parameters</strong>: Spreading Factor, Bandwidth and Coding Rate‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    case MODEM_LORA:
      //  LoRa Modulation
      SX126x.ModulationParams.PacketType = 
        PACKET_TYPE_LORA;
      SX126x.ModulationParams.Params.LoRa.SpreadingFactor = 
        ( RadioLoRaSpreadingFactors_t ) datarate;
      SX126x.ModulationParams.Params.LoRa.Bandwidth =  
        Bandwidths[bandwidth];
      SX126x.ModulationParams.Params.LoRa.CodingRate = 
        ( RadioLoRaCodingRates_t )coderate;</code></pre></div>
<p>Depending on the LoRa Parameters, we optimise for <strong>Low Data Rate</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Optimise for Low Data Rate
      if( ( ( bandwidth == 0 ) &amp;&amp; ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
      ( ( bandwidth == 1 ) &amp;&amp; ( datarate == 12 ) ) ) {
        SX126x.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x01;
      } else {
        SX126x.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
      }</code></pre></div>
<p>Next we populate the <strong>Packet Parameters</strong>: Preamble Length, Header Type, Payload Length, CRC Mode and Invert IQ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Populate Packet Type
      SX126x.PacketParams.PacketType = PACKET_TYPE_LORA;

      //  Populate Preamble Length
      if( ( SX126x.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
        ( SX126x.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF6 ) ) {
        if( preambleLen &lt; 12 ) {
          SX126x.PacketParams.Params.LoRa.PreambleLength = 12;
        } else {
          SX126x.PacketParams.Params.LoRa.PreambleLength = preambleLen;
        }
      } else {
        SX126x.PacketParams.Params.LoRa.PreambleLength = preambleLen;
      }

      //  Populate Header Type, Payload Length, CRC Mode and Invert IQ
      SX126x.PacketParams.Params.LoRa.HeaderType = 
        ( RadioLoRaPacketLengthsMode_t )fixLen;
      SX126x.PacketParams.Params.LoRa.PayloadLength = 
        MaxPayloadLength;
      SX126x.PacketParams.Params.LoRa.CrcMode = 
        ( RadioLoRaCrcModes_t )crcOn;
      SX126x.PacketParams.Params.LoRa.InvertIQ = 
        ( RadioLoRaIQModes_t )iqInverted;</code></pre></div>
<p>We set the LoRa Module to <strong>Standby Mode</strong> and configure it for <strong>LoRa Modulation</strong> (or FSK Modulation)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Set LoRa Module to Standby Mode
      RadioStandby( );

      //  Configure LoRa Module for LoRa Modulation (or FSK Modulation)
      RadioSetModem( 
        ( SX126x.ModulationParams.PacketType == PACKET_TYPE_GFSK ) 
        ? MODEM_FSK 
        : MODEM_LORA
      );</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1111-L1115">(<strong>RadioStandby</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L576-L598">(<strong>RadioSetModem</strong> is defined here)</a></p>
<p>We configure the LoRa Module with the <strong>Modulation Parameters</strong> and <strong>Packet Parameters</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Configure Modulation Parameters
      SX126xSetModulationParams( &amp;SX126x.ModulationParams );

      //  Configure Packet Parameters
      SX126xSetPacketParams( &amp;SX126x.PacketParams );
      break;
  }</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L578-L621">(<strong>SX126xSetModulationParams</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L623-L680">(<strong>SX126xSetPacketParams</strong> is defined here)</a></p>
<p>This is a Workaround for <strong>Modulation Quality</strong> with <strong>500 kHz Bandwidth</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  // WORKAROUND - Modulation Quality with 500 kHz LoRa Bandwidth, see DS_SX1261-2_V1.2 datasheet chapter 15.1
  if( ( modem == MODEM_LORA ) &amp;&amp; ( SX126x.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ) ) {
    SX126xWriteRegister( 
      REG_TX_MODULATION, 
      SX126xReadRegister( REG_TX_MODULATION ) &amp; ~( 1 &lt;&lt; 2 ) 
    );
  } else {
    SX126xWriteRegister( 
      REG_TX_MODULATION, 
      SX126xReadRegister( REG_TX_MODULATION ) | ( 1 &lt;&lt; 2 ) 
    );
  }
  // WORKAROUND END</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L263-L266">(<strong>SX126xWriteRegister</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L276-L281">(<strong>SX126xReadRegister</strong> is defined here)</a></p>
<p>We finish by setting the <strong>Transmit Power</strong> and <strong>Transmit Timeout</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Set Transmit Power
  SX126xSetRfTxPower( power );

  //  Set Transmit Timeout
  TxTimeout = timeout;
}</code></pre></div>
<p><strong>SX126xSetRfTxPower</strong> is defined in <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L299-L304">sx126x-nuttx.c</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>void SX126xSetRfTxPower( int8_t power ) {
  //  TODO: Previously: SX126xSetTxParams( power, RADIO_RAMP_40_US );
  SX126xSetTxParams( power, RADIO_RAMP_3400_US );  //  TODO
}</code></pre></div>
<p>For easier testing we have set the Ramp Up Time to <strong>3400 microseconds</strong> (longest duration).</p>
<p>After testing we should revert to the <strong>Default Ramp Up Time</strong> (40 microseconds).</p>
<h2 id="radiosetrxconfig-set-receive-configuration" class="section-header"><a href="#radiosetrxconfig-set-receive-configuration">14.4 RadioSetRxConfig: Set Receive Configuration</a></h2>
<p>TODO</p>
<p><strong>RadioSetRxConfig</strong> sets the LoRa Receive Configuration: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L661-L786">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void RadioSetRxConfig( RadioModems_t modem, uint32_t bandwidth,
  uint32_t datarate, uint8_t coderate,
  uint32_t bandwidthAfc, uint16_t preambleLen,
  uint16_t symbTimeout, bool fixLen,
  uint8_t payloadLen,
  bool crcOn, bool freqHopOn, uint8_t hopPeriod,
  bool iqInverted, bool rxContinuous ) {

  //  Set Symbol Timeout
  RxContinuous = rxContinuous;
  if( rxContinuous == true ) {
    symbTimeout = 0;
  }

  //  Set Max Payload Length
  if( fixLen == true ) {
    MaxPayloadLength = payloadLen;
  }
  else {
    MaxPayloadLength = 0xFF;
  }</code></pre></div>
<p>We begin by setting the <strong>Symbol Timeout</strong> and <strong>Max Payload Length</strong>.</p>
<p>Since we‚Äôre using <strong>LoRa Modulation</strong> instead of FSK Modulation, we skip the section on FSK Modulation‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  LoRa Modulation or FSK Modulation?
  switch( modem )
  {
    case MODEM_FSK:
      //  Omitted: FSK Modulation
      ...</code></pre></div>
<p>We populate the <strong>Modulation Parameters</strong>: Spreading Factor, Bandwidth and Coding Rate‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    case MODEM_LORA:
      //  LoRa Modulation
      SX126xSetStopRxTimerOnPreambleDetect( false );
      SX126x.ModulationParams.PacketType = 
        PACKET_TYPE_LORA;
      SX126x.ModulationParams.Params.LoRa.SpreadingFactor = 
        ( RadioLoRaSpreadingFactors_t )datarate;
      SX126x.ModulationParams.Params.LoRa.Bandwidth = 
        Bandwidths[bandwidth];
      SX126x.ModulationParams.Params.LoRa.CodingRate = 
        ( RadioLoRaCodingRates_t )coderate;</code></pre></div>
<p>Depending on the LoRa Parameters, we optimise for <strong>Low Data Rate</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Optimise for Low Data Rate
      if( ( ( bandwidth == 0 ) &amp;&amp; ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
      ( ( bandwidth == 1 ) &amp;&amp; ( datarate == 12 ) ) ) {
        SX126x.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x01;
      } else {
        SX126x.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
      }</code></pre></div>
<p>We populate the <strong>Packet Parameters</strong>: Preamble Length, Header Type, Payload Length, CRC Mode and Invert IQ‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Populate Packet Type
      SX126x.PacketParams.PacketType = PACKET_TYPE_LORA;

      //  Populate Preamble Length
      if( ( SX126x.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
          ( SX126x.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF6 ) ){
        if( preambleLen &lt; 12 ) {
          SX126x.PacketParams.Params.LoRa.PreambleLength = 12;
        } else {
          SX126x.PacketParams.Params.LoRa.PreambleLength = preambleLen;
        }
      } else {
        SX126x.PacketParams.Params.LoRa.PreambleLength = preambleLen;
      }

      //  Populate Header Type, Payload Length, CRC Mode and Invert IQ
      SX126x.PacketParams.Params.LoRa.HeaderType = 
        ( RadioLoRaPacketLengthsMode_t )fixLen;
      SX126x.PacketParams.Params.LoRa.PayloadLength = 
        MaxPayloadLength;
      SX126x.PacketParams.Params.LoRa.CrcMode = 
        ( RadioLoRaCrcModes_t )crcOn;
      SX126x.PacketParams.Params.LoRa.InvertIQ = 
        ( RadioLoRaIQModes_t )iqInverted;</code></pre></div>
<p>We set the LoRa Module to <strong>Standby Mode</strong> and configure it for <strong>LoRa Modulation</strong> (or FSK Modulation)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Set LoRa Module to Standby Mode
      RadioStandby( );

      //  Configure LoRa Module for LoRa Modulation (or FSK Modulation)
      RadioSetModem( 
          ( SX126x.ModulationParams.PacketType == PACKET_TYPE_GFSK ) 
          ? MODEM_FSK 
          : MODEM_LORA 
      );</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1111-L1115">(<strong>RadioStandby</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L576-L598">(<strong>RadioSetModem</strong> is defined here)</a></p>
<p>We configure the LoRa Module with the <strong>Modulation Parameters</strong>, <strong>Packet Parameters</strong> and Symbol Timeout‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  Configure Modulation Parameters
      SX126xSetModulationParams( &amp;SX126x.ModulationParams );

      //  Configure Packet Parameters
      SX126xSetPacketParams( &amp;SX126x.PacketParams );

      //  Configure Symbol Timeout
      SX126xSetLoRaSymbNumTimeout( symbTimeout );</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L578-L621">(<strong>SX126xSetModulationParams</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L623-L680">(<strong>SX126xSetPacketParams</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L366-L388">(<strong>SX126xSetLoRaSymbNumTimeout</strong> is defined here)</a></p>
<p>This is a Workaround that <strong>optimises the Inverted IQ Operation</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      // WORKAROUND - Optimizing the Inverted IQ Operation, see DS_SX1261-2_V1.2 datasheet chapter 15.4
      if( SX126x.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED ) {
        SX126xWriteRegister( 
          REG_IQ_POLARITY, 
          SX126xReadRegister( REG_IQ_POLARITY ) &amp; ~( 1 &lt;&lt; 2 ) 
        );
      } else {
        SX126xWriteRegister( 
          REG_IQ_POLARITY, 
          SX126xReadRegister( REG_IQ_POLARITY ) | ( 1 &lt;&lt; 2 ) 
        );
      }
      // WORKAROUND END</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L263-L266">(<strong>SX126xWriteRegister</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L276-L281">(<strong>SX126xReadRegister</strong> is defined here)</a></p>
<p>We finish by setting the <strong>Receive Timeout</strong> to No Timeout (always receiving)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      // Timeout Max, Timeout handled directly in SetRx function
      RxTimeout = 0xFFFF;
      break;
  }
}</code></pre></div><h2 id="radiosend-transmit-message" class="section-header"><a href="#radiosend-transmit-message">14.5 RadioSend: Transmit Message</a></h2>
<p>TODO</p>
<p><strong>RadioSend</strong> transmits a LoRa Message: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1069-L1098">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void RadioSend( uint8_t *buffer, uint8_t size ) {

  //  Set the DIO Interrupt Events:
  //  Transmit Done and Transmit Timeout
  //  will trigger interrupts on DIO1
  SX126xSetDioIrqParams( 
    IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT,  //  Interrupt Mask
    IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT,  //  Interrupt Events for DIO1
    IRQ_RADIO_NONE,  //  Interrupt Events for DIO2
    IRQ_RADIO_NONE   //  Interrupt Events for DIO3
  );</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L457-L470">(<strong>SX126xSetDioIrqParams</strong> is defined here)</a></p>
<p>We begin by configuring which <strong>LoRa Events will trigger interrupts</strong> on each DIO Pin.</p>
<p>(Transmit Done and Transmit Timeout will trigger interrupts on DIO1)</p>
<p>Next we configure the <strong>Packet Parameters</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Populate the payload length
  if( SX126xGetPacketType( ) == PACKET_TYPE_LORA ) {
    SX126x.PacketParams.Params.LoRa.PayloadLength = size;
  } else {
    SX126x.PacketParams.Params.Gfsk.PayloadLength = size;
  }
  //  Configure the packet parameters
  SX126xSetPacketParams( &amp;SX126x.PacketParams );</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L523-L526">(<strong>SX126xGetPacketType</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L623-L680">(<strong>SX126xSetPacketParams</strong> is defined here)</a></p>
<p>We finish by sending the <strong>Message Payload</strong> and starting the <strong>Transmit Timer</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Send message payload
  SX126xSendPayload( buffer, size, 0 );

  //  Start Transmit Timer
  TimerStart( &amp;TxTimeoutTimer, TxTimeout );
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L396-L421">(<strong>TimerStart</strong> is defined here)</a></p>
<p><strong>SX126xSendPayload</strong> is defined below: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L162-L166">sx126x.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>///  Send message payload
void SX126xSendPayload( uint8_t *payload, uint8_t size, uint32_t timeout ) {
  //  Copy message payload to Transmit Buffer
  SX126xSetPayload( payload, size );

  //  Transmit the buffer
  SX126xSetTx( timeout );
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L289-L299">(<strong>SX126xSetTx</strong> is defined here)</a></p>
<p>This code copies the Message Payload to the SX1262 <strong>Transmit Buffer</strong> and transmits the message.</p>
<p><strong>SX126xSetPayload</strong> copies to the Transmit Buffer by calling <strong>SX126xWriteBuffer</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L144-L147">sx126x.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Copy message payload to Transmit Buffer
void SX126xSetPayload( uint8_t *payload, uint8_t size ) {
  //  Copy message payload to Transmit Buffer
  SX126xWriteBuffer( 0x00, payload, size );
}</code></pre></div>
<p><strong>SX126xWriteBuffer</strong> wakes up the LoRa Module, writes to the Transmit Buffer and waits for the operation to be completed: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L283-L289">sx126x.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Copy message payload to Transmit Buffer
void SX126xWriteBuffer( uint8_t offset, uint8_t *buffer, uint8_t size ) {
  //  Wake up SX1262 if sleeping
  SX126xCheckDeviceReady( );

  //  Copy message payload to Transmit Buffer
  int rc = sx126x_write_buffer(NULL, offset, buffer, size);
  assert(rc == 0);

  //  Wait for SX1262 to be ready
  SX126xWaitOnBusy( );
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L133-L142">(<strong>SX126xCheckDeviceReady</strong> is defined here)</a></p>
<p><a href="https://lupyuen.github.io/articles/sx1262#transmit-long-message">(<strong>sx126x_write_buffer</strong> is explained here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L171-L182">(<strong>SX126xWaitOnBusy</strong> is defined here)</a></p>
<p>When the LoRa Message is transmitted (successfully or unsuccessfully), the LoRa Module triggers a <strong>DIO1 Interrupt</strong>.</p>
<p>Our driver calls <strong>RadioIrqProcess</strong> to process the interrupt. <a href="https://lupyuen.github.io/articles/sx1262#radioirqprocess-process-transmit-and-receive-interrupts">(See this)</a></p>
<h2 id="radiorx-receive-message" class="section-header"><a href="#radiorx-receive-message">14.6 RadioRx: Receive Message</a></h2>
<p>TODO</p>
<p><strong>RadioRx</strong> receives a single LoRa Message: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1117-L1138">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void RadioRx( uint32_t timeout ) {

  //  Set the DIO Interrupt Events:
  //  All LoRa Events will trigger interrupts on DIO1
  SX126xSetDioIrqParams(
    IRQ_RADIO_ALL,   //  Interrupt Mask
    IRQ_RADIO_ALL,   //  Interrupt Events for DIO1
    IRQ_RADIO_NONE,  //  Interrupt Events for DIO2
    IRQ_RADIO_NONE   //  Interrupt Events for DIO3
  );</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L457-L470">(<strong>SX126xSetDioIrqParams</strong> is defined here)</a></p>
<p>We begin by configuring which <strong>LoRa Events will trigger interrupts</strong> on each DIO Pin.</p>
<p>(All LoRa Events will trigger interrupts on DIO1)</p>
<p>We start the <strong>Receive Timer</strong> to catch Receive Timeouts‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Start the Receive Timer
  if( timeout != 0 ) {
    TimerStart( &amp;RxTimeoutTimer, timeout );
  }</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L396-L421">(<strong>TimerStart</strong> is defined here)</a></p>
<p>Now we begin to <strong>receive a LoRa Message</strong> continuously, or until a timeout occurs‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  if( RxContinuous == true ) {
    //  Receive continuously
    SX126xSetRx( 0xFFFFFF ); // Rx Continuous
  } else {
    //  Receive with timeout
    SX126xSetRx( RxTimeout &lt;&lt; 6 );
  }
}</code></pre></div>
<p><strong>SX126xSetRx</strong> enters Receive Mode like so: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L301-L313">sx126x.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>void SX126xSetRx( uint32_t timeout ) {
  uint8_t buf[3];

  //  Remember we&#39;re in Receive Mode
  SX126xSetOperatingMode( MODE_RX );

  //  Configure Receive Gain
  SX126xWriteRegister( REG_RX_GAIN, 0x94 ); // default gain

  //  Enter Receive Mode
  buf[0] = ( uint8_t )( ( timeout &gt;&gt; 16 ) &amp; 0xFF );
  buf[1] = ( uint8_t )( ( timeout &gt;&gt; 8 ) &amp; 0xFF );
  buf[2] = ( uint8_t )( timeout &amp; 0xFF );
  SX126xWriteCommand( RADIO_SET_RX, buf, 3 );
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L126-L147">(<strong>SX126xSetOperatingMode</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L263-L266">(<strong>SX126xWriteRegister</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L204-L217">(<strong>SX126xWriteCommand</strong> is defined here)</a></p>
<p>When a LoRa Message is received (successfully or unsuccessfully), the LoRa Module triggers a <strong>DIO1 Interrupt</strong>.</p>
<p>Our driver calls <strong>RadioIrqProcess</strong> to process the interrupt, which is explained next‚Ä¶</p>
<h2 id="radioirqprocess-process-transmit-and-receive-interrupts" class="section-header"><a href="#radioirqprocess-process-transmit-and-receive-interrupts">14.7 RadioIrqProcess: Process Transmit and Receive Interrupts</a></h2>
<p>TODO</p>
<p><strong>RadioIrqProcess</strong> processes the interrupts that are triggered when a LoRa Message is transmitted and received: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1314-L1460">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Process Transmit and Receive Interrupts.
/// For BL602: Must be run in the Application
/// Task Context, not Interrupt Context because 
/// we will call printf and SPI Functions here.
void RadioIrqProcess( void ) {

  //  Remember and clear Interrupt Flag
  CRITICAL_SECTION_BEGIN( );
  const bool isIrqFired = IrqFired;
  IrqFired = false;
  CRITICAL_SECTION_END( );</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/include/sx126x-board.h#L58-L60">(Note: Critical Sections are not yet implemented)</a></p>
<p>The function begins by copying the <strong>Interrupt Flag</strong> and clearing the flag.</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#radioondioirq">(The Interrupt Flag is set by <strong>RadioOnDioIrq</strong>)</a></p>
<p>The rest of the function will run only if the <strong>Interrupt Flag was originally set</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  IrqFired must be true to process interrupts
  if( isIrqFired == true ) {
    //  Get the Interrupt Status
    uint16_t irqRegs = SX126xGetIrqStatus( );

    //  Clear the Interrupt Status
    SX126xClearIrqStatus( irqRegs );</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L472-L478">(<strong>SX126xGetIrqStatus</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L803-L810">(<strong>SX126xClearIrqStatus</strong> is defined here)</a></p>
<p>This code fetches the <strong>Interrupt Status</strong> from the LoRa Module and clears the Interrupt Status.</p>
<p>If DIO1 is still High, we set the <strong>Interrupt Flag</strong> for future processing‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>    //  Check if DIO1 pin is High. If it is the case revert IrqFired to true
    CRITICAL_SECTION_BEGIN( );
    if( SX126xGetDio1PinState( ) == 1 ) {
      IrqFired = true;
    }
    CRITICAL_SECTION_END( );</code></pre></div>
<p><strong>Interrupt Status</strong> tells us which LoRa Events have just occurred. We handle the LoRa Events accordingly‚Ä¶</p>
<ul>
<li>
<p>Transmit Done</p>
</li>
<li>
<p>Receive Done</p>
</li>
<li>
<p>CAD Done</p>
</li>
<li>
<p>Transmit / Receive Timeout</p>
</li>
<li>
<p>Preamble Detected</p>
</li>
<li>
<p>Sync Word Valid</p>
</li>
<li>
<p>Header Valid</p>
</li>
<li>
<p>Header Error</p>
</li>
</ul>
<h3 id="transmit-done" class="section-header"><a href="#transmit-done">14.7.1 Transmit Done</a></h3>
<p>TODO</p>
<p>When the LoRa Module has transmitted a LoRa Message successfully, we stop the Transmit Timer and call the <strong>Callback Function for Transmit Done</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1339-L1349">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If a LoRa Message was transmitted successfully...
    if( ( irqRegs &amp; IRQ_TX_DONE ) == IRQ_TX_DONE ) {

      //  Stop the Transmit Timer
      TimerStop( &amp;TxTimeoutTimer );

      //!&lt; Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
      SX126xSetOperatingMode( MODE_STDBY_RC );

      //  Call the Callback Function for Transmit Done
      if( ( RadioEvents.TxDone != NULL ) ) {
        RadioEvents.TxDone( );
      }
    }</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L382-L394">(<strong>TimerStop</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L126-L147">(<strong>SX126xSetOperatingMode</strong> is defined here)</a></p>
<p><strong>TxDone</strong> points to the <strong>on_tx_done</strong> Callback Function that we‚Äôve seen earlier.</p>
<h3 id="receive-done" class="section-header"><a href="#receive-done">14.7.2 Receive Done</a></h3>
<p>TODO</p>
<p>When the LoRa Module receives a LoRa Message, we stop the Receive Timer: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1351-L1389">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If a LoRa Message was received...
    if( ( irqRegs &amp; IRQ_RX_DONE ) == IRQ_RX_DONE ) {

      //  Stop the Receive Timer
      TimerStop( &amp;RxTimeoutTimer );</code></pre></div>
<p>In case of CRC Error, we call the <strong>Callback Function for Receive Error</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      if( ( irqRegs &amp; IRQ_CRC_ERROR ) == IRQ_CRC_ERROR ) {

        //  If the received message has CRC Error...
        if( RxContinuous == false ) {
          //!&lt; Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
          SX126xSetOperatingMode( MODE_STDBY_RC );
        }

        //  Call the Callback Function for Receive Error
        if( ( RadioEvents.RxError ) ) {
          RadioEvents.RxError( );
        }</code></pre></div>
<p><strong>RxError</strong> points to the <strong>on_rx_error</strong> Callback Function that we‚Äôve seen earlier.</p>
<p>If the received message has no CRC Error, we do this Workaround for <strong>Implicit Header Mode Timeout Behavior</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      } else {
        //  If the received message has no CRC Error...
        uint8_t size;

        //  If we are receiving continously...
        if( RxContinuous == false ) {
          //!&lt; Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
          SX126xSetOperatingMode( MODE_STDBY_RC );

          // WORKAROUND - Implicit Header Mode Timeout Behavior, see DS_SX1261-2_V1.2 datasheet chapter 15.3
          SX126xWriteRegister( REG_RTC_CTRL, 0x00 );
          SX126xWriteRegister( 
            REG_EVT_CLR, 
            SX126xReadRegister( REG_EVT_CLR ) | ( 1 &lt;&lt; 1 ) 
          );
          // WORKAROUND END
        }</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L263-L266">(<strong>SX126xWriteRegister</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L276-L281">(<strong>SX126xReadRegister</strong> is defined here)</a></p>
<p>Then we copy the <strong>Received Message Payload</strong> and get the <strong>Packet Status</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>        //  Copy the Received Message Payload (max 255 bytes)
        SX126xGetPayload( RadioRxPayload, &amp;size , 255 );
        
        //  Get the Packet Status:
        //  Packet Signal Strength (RSSI), Signal-to-Noise Ratio (SNR),
        //  Signal RSSI, Frequency Error
        SX126xGetPacketStatus( &amp;RadioPktStatus );</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L746-L778">(<strong>SX126xGetPacketStatus</strong> is defined here)</a></p>
<p>And we call the <strong>Callback Function for Receive Done</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>        //  Call the Callback Function for Receive Done
        if( ( RadioEvents.RxDone != NULL ) ) {
          RadioEvents.RxDone( 
            RadioRxPayload, 
            size, 
            RadioPktStatus.Params.LoRa.RssiPkt, 
            RadioPktStatus.Params.LoRa.SnrPkt 
          );
        }
      }
    }</code></pre></div>
<p><strong>RxDone</strong> points to the <strong>on_rx_done</strong> Callback Function that we‚Äôve seen earlier.</p>
<p><strong>SX126xGetPayload</strong> copies the received message payload from the SX1262 <strong>Receive Buffer</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L149-L160">sx126x.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Copy message payload from Receive Buffer
uint8_t SX126xGetPayload( uint8_t *buffer, uint8_t *size,  uint8_t maxSize ) {
  uint8_t offset = 0;

  //  Get the size and offset of the received message
  //  in the Receive Buffer
  SX126xGetRxBufferStatus( size, &amp;offset );
  if( *size &gt; maxSize ) {
    return 1;
  }

  //  Copy message payload from Receive Buffer
  SX126xReadBuffer( offset, buffer, *size );
  return 0;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L727-L744">(<strong>SX126xGetRxBufferStatus</strong> is defined here)</a></p>
<p><strong>SX126xReadBuffer</strong> wakes up the LoRa Module, reads from the Receive Buffer and waits for the operation to be completed: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L291-L297">sx126x-nuttx.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Copy message payload from Receive Buffer
void SX126xReadBuffer( uint8_t offset, uint8_t *buffer, uint8_t size ) {
  //  Wake up SX1262 if sleeping
  SX126xCheckDeviceReady( );

  //  Copy message payload from Receive Buffer
  int rc = sx126x_read_buffer(NULL, offset, buffer, size);
  assert(rc == 0);

  //  Wait for SX1262 to be ready
  SX126xWaitOnBusy( );
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L133-L142">(<strong>SX126xCheckDeviceReady</strong> is defined here)</a></p>
<p><a href="https://lupyuen.github.io/articles/sx1262#long-messages">(<strong>sx126x_read_buffer</strong> is explained here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L171-L182">(<strong>SX126xWaitOnBusy</strong> is defined here)</a></p>
<h3 id="cad-done" class="section-header"><a href="#cad-done">14.7.3 CAD Done</a></h3>
<p>TODO</p>
<p><strong>Channel Activity Detection</strong> lets us <strong>detect whether there‚Äôs any ongoing transmission</strong> in a LoRa Radio Channel, in a power-efficient way.</p>
<p>We won‚Äôt be doing Channel Activity Detection in our driver: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1391-L1400">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If Channel Activity Detection is complete...
    if( ( irqRegs &amp; IRQ_CAD_DONE ) == IRQ_CAD_DONE ) {

      //!&lt; Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
      SX126xSetOperatingMode( MODE_STDBY_RC );

      //  Call Callback Function for CAD Done
      if( ( RadioEvents.CadDone != NULL ) ) {
        RadioEvents.CadDone( ( 
            ( irqRegs &amp; IRQ_CAD_ACTIVITY_DETECTED ) 
            == IRQ_CAD_ACTIVITY_DETECTED 
        ) );
      }
    }</code></pre></div><h3 id="transmit--receive-timeout" class="section-header"><a href="#transmit--receive-timeout">14.7.4 Transmit / Receive Timeout</a></h3>
<p>TODO</p>
<p>When the LoRa Module <strong>fails to transmit</strong> a LoRa Message due to Timeout, we stop the Transmit Timer and call the <strong>Callback Function for Transmit Timeout</strong>: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1402-L1425">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If a LoRa Message failed to Transmit or Receive due to Timeout...
    if( ( irqRegs &amp; IRQ_RX_TX_TIMEOUT ) == IRQ_RX_TX_TIMEOUT ) {

      //  If the message failed to Transmit due to Timeout...
      if( SX126xGetOperatingMode( ) == MODE_TX ) {

        //  Stop the Transmit Timer
        TimerStop( &amp;TxTimeoutTimer );

        //!&lt; Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
        SX126xSetOperatingMode( MODE_STDBY_RC );

        //  Call the Callback Function for Transmit Timeout
        if( ( RadioEvents.TxTimeout != NULL ) ) {
          RadioEvents.TxTimeout( );
        }
      }</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L121-L124">(<strong>SX126xGetOperatingMode</strong> is defined here)</a></p>
<p><strong>TxTimeout</strong> points to the <strong>on_tx_timeout</strong> Callback Function that we‚Äôve seen earlier.</p>
<p>When the LoRa Module <strong>fails to receive</strong> a LoRa Message due to Timeout, we stop the Receive Timer and call the <strong>Callback Function for Receive Timeout</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>      //  If the message failed to Receive due to Timeout...
      else if( SX126xGetOperatingMode( ) == MODE_RX ) {

        //  Stop the Receive Timer
        TimerStop( &amp;RxTimeoutTimer );

        //!&lt; Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
        SX126xSetOperatingMode( MODE_STDBY_RC );

        //  Call the Callback Function for Receive Timeout
        if( ( RadioEvents.RxTimeout != NULL ) ) {
          RadioEvents.RxTimeout( );
        }
      }
    }</code></pre></div>
<p><strong>RxTimeout</strong> points to the <strong>on_rx_timeout</strong> Callback Function that we‚Äôve seen earlier.</p>
<h3 id="preamble-detected" class="section-header"><a href="#preamble-detected">14.7.5 Preamble Detected</a></h3>
<p>TODO</p>
<p>Preamble is the Radio Signal that <strong>precedes the LoRa Message</strong>. When the LoRa Module detects the Preamble Signal, it knows that it‚Äôs about to receive a LoRa Message.</p>
<p>We don‚Äôt need to handle the Preamble Signal, the LoRa Module does it for us: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1427-L1431">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If LoRa Preamble was detected...
    if( ( irqRegs &amp; IRQ_PREAMBLE_DETECTED ) == IRQ_PREAMBLE_DETECTED ) {
      //__NOP( );
    }</code></pre></div>
<p>Our <a href="https://github.com/lupyuen/lora-sx1262#receive-message"><strong>Receive Message Log</strong></a> shows that the Preamble Signal (<strong>IRQ_PREAMBLE_DETECTED</strong>) is always detected before receiving a LoRa Message.</p>
<p>(<strong>IRQ_PREAMBLE_DETECTED</strong> appears just before the LoRa Header: <strong>IRQ_HEADER_VALID</strong>)</p>
<p><a href="https://www.link-labs.com/blog/what-is-lora">(More about LoRa Preamble)</a></p>
<h3 id="sync-word-valid" class="section-header"><a href="#sync-word-valid">14.7.6 Sync Word Valid</a></h3>
<p>TODO</p>
<p><strong>Sync Words</strong> are 16-bit values that differentiate the types of LoRa Networks.</p>
<p>The LoRa Module detects the Sync Words when it receive a LoRa Message: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1433-L1437">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If a valid Sync Word was detected...
    if( ( irqRegs &amp; IRQ_SYNCWORD_VALID ) == IRQ_SYNCWORD_VALID ) {
      //__NOP( );
    }</code></pre></div>
<p>Note that the <strong>Sync Word differs for LoRaWAN</strong> vs Private LoRa Networks‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Syncword for Private LoRa networks
#define LORA_MAC_PRIVATE_SYNCWORD                   0x1424

//  Syncword for Public LoRa networks (LoRaWAN)
#define LORA_MAC_PUBLIC_SYNCWORD                    0x3444</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/lorawan#appendix-lora-sync-word">(More about Sync Words)</a></p>
<h3 id="header-valid" class="section-header"><a href="#header-valid">14.7.7 Header Valid</a></h3>
<p>TODO</p>
<p>The LoRa Module checks for a <strong>valid LoRa Header</strong> when receiving a LoRa Message: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1439-L1443">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If a valid Header was received...
    if( ( irqRegs &amp; IRQ_HEADER_VALID ) == IRQ_HEADER_VALID ) {
      //__NOP( );
    }</code></pre></div>
<p>Our <a href="https://github.com/lupyuen/lora-sx1262#receive-message"><strong>Receive Message Log</strong></a> shows that the LoRa Header (<strong>IRQ_HEADER_VALID</strong>) is always detected before receiving a LoRa Message.</p>
<p>(<strong>IRQ_HEADER_VALID</strong> appears right after the Preamble Signal: <strong>IRQ_PREAMBLE_DETECTED</strong>)</p>
<h3 id="header-error" class="section-header"><a href="#header-error">14.7.8 Header Error</a></h3>
<p>TODO</p>
<p>When the LoRa Module detects a <strong>LoRa Header with CRC Error</strong>, we stop the Receive Timer and call the Callback Function for Receive Timeout: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1445-L1458">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>    //  If a Header with CRC Error was received...
    if( ( irqRegs &amp; IRQ_HEADER_ERROR ) == IRQ_HEADER_ERROR ) {

      //  Stop the Receive Timer
      TimerStop( &amp;RxTimeoutTimer );

      if( RxContinuous == false ) {
        //!&lt; Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
        SX126xSetOperatingMode( MODE_STDBY_RC );
      }

      //  Call the Callback Function for Receive Timeout
      if( ( RadioEvents.RxTimeout != NULL ) ) {
        RadioEvents.RxTimeout( );
      }
    }
  }
}</code></pre></div>
<p><strong>RxTimeout</strong> points to the <strong>on_rx_timeout</strong> Callback Function that we‚Äôve seen earlier.</p>
<h3 id="radioondioirq" class="section-header"><a href="#radioondioirq">14.7.9 RadioOnDioIrq</a></h3>
<p>TODO</p>
<p><strong>RadioIrqProcess</strong> (as defined above) is called by <strong>RadioOnDioIrq</strong> to handle LoRa Transmit and Receive Events: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1300-L1312">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Callback Function for Transmit and Receive Interrupts.
/// For BL602: This function runs in the context of the 
/// Background Application Task. So we are safe to call 
/// printf and SPI Functions now.
void RadioOnDioIrq( struct ble_npl_event *ev ) {
  //  Set the Interrupt Flag
  IrqFired = true;

  //  BL602 Note: It&#39;s OK to process the interrupt here because we are in
  //  Application Task Context, not Interrupt Context.
  //  The Reference Implementation processes the interrupt in the main loop.
  RadioIrqProcess();
}</code></pre></div><h2 id="radiosleep-switch-to-sleep-mode" class="section-header"><a href="#radiosleep-switch-to-sleep-mode">14.8 RadioSleep: Switch to Sleep Mode</a></h2>
<p>TODO</p>
<p><strong>RadioSleep</strong> switches SX1262 to low-power sleep mode: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/radio.c#L1100-L1109">radio.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Switch to Sleep Mode
void RadioSleep( void ) {
  SleepParams_t params = { 0 };
  params.Fields.WarmStart = 1;

  //  Switch to Sleep Mode and wait 2 milliseconds
  SX126xSetSleep( params );
  DelayMs( 2 );
}</code></pre></div>
<p><strong>SX126xSetSleep</strong> executes the Sleep Command on the LoRa Module: <a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L253-L268">sx126x.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Switch to Sleep Mode
void SX126xSetSleep( SleepParams_t sleepConfig ) {
  //  Switch off antenna (not used)
  SX126xAntSwOff( );

  //  Compute Sleep Parameter
  uint8_t value = ( 
      ( ( uint8_t )sleepConfig.Fields.WarmStart &lt;&lt; 2 ) |
      ( ( uint8_t )sleepConfig.Fields.Reset &lt;&lt; 1 ) |
      ( ( uint8_t )sleepConfig.Fields.WakeUpRTC ) 
  );

  if( sleepConfig.Fields.WarmStart == 0 ) {
    // Force image calibration
    ImageCalibrated = false;
  }

  //  Run Sleep Command
  SX126xWriteCommand( RADIO_SET_SLEEP, &amp;value, 1 );
  SX126xSetOperatingMode( MODE_SLEEP );
}</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L324-L329">(<strong>SX126xAntSwOff</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L204-L217">(<strong>SX126xWriteCommand</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L126-L147">(<strong>SX126xSetOperatingMode</strong> is defined here)</a></p>
<p>TODO5</p>
<p><img src="https://lupyuen.github.io/images/sx1262-clone8.png" alt="" /></p>
<p>TODO25</p>
<p><img src="https://lupyuen.github.io/images/sx1262-library2.jpg" alt="" /></p>

    
</body>
</html>