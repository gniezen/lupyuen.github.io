<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>BL602 Bootloader</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="BL602 Bootloader" 
    data-rh="true">
<meta property="og:description" 
    content="All about the BL602 RISC-V Bootloader... And how it loads the Application Firmware into XIP Flash Memory"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/boot-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">BL602 Bootloader</h1>
    <nav id="TOC"><ul>
<li><a href="#bl602-boot2-bootloader">1 BL602 Boot2 Bootloader</a><ul></ul></li>
<li><a href="#inside-the-bootloader">2 Inside the Bootloader</a><ul></ul></li>
<li><a href="#install-application-firmware">3 Install Application Firmware</a><ul></ul></li>
<li><a href="#write-firmware-to-xip-flash">4 Write Firmware to XIP Flash</a><ul></ul></li>
<li><a href="#bl602-partition-table">5 BL602 Partition Table</a><ul></ul></li>
<li><a href="#bl602-rom-driver-api">6 BL602 ROM Driver API</a><ul></ul></li>
<li><a href="#locating-the-rom-driver-api">7 Locating the ROM Driver API</a><ul></ul></li>
<li><a href="#bootloader-overwrites-itself">8 Bootloader Overwrites Itself</a><ul></ul></li>
<li><a href="#efuse-security">9 EFuse Security</a><ul></ul></li>
<li><a href="#bl602-firmware-boot-code">10 BL602 Firmware Boot Code</a><ul></ul></li>
<li><a href="#other-bootloaders">11 Other Bootloaders</a><ul></ul></li>
<li><a href="#whats-next">12 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">13 Notes</a><ul></ul></li></ul></nav><p>üìù <em>10 Jun 2021</em></p>
<p><em>How is our firmware loaded into BL602‚Äôs flash memory?</em></p>
<p><em>How does BL602 prevent tampering of firmware?</em></p>
<p>All this and much, much more shall be explained as we learn about the <strong>BL602 Boot2 Bootloader</strong>.</p>
<h1 id="bl602-boot2-bootloader" class="section-header"><a href="#bl602-boot2-bootloader">1 BL602 Boot2 Bootloader</a></h1>
<p>Let‚Äôs ponder what happens when we flash to BL602 the firmware that we have built‚Ä¶</p>
<p>(We‚Äôll call it the <strong>Application Firmware</strong>)</p>
<p><em>Sounds easy! We transfer the Application Firmware from our computer to BL602 (over USB)‚Ä¶</em></p>
<p><em>Then BL602 writes the Application Firmware to flash memory. Right?</em></p>
<p>Not quite. We talked about flashing Application Firmware in the article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/flash"><strong>‚ÄúFlashing Firmware to PineCone BL602‚Äù</strong></a></li>
</ul>
<p>During flashing, we transfer a <strong>Flashing Image</strong> from our computer to BL602 over USB.</p>
<p>The Flashing Image contains‚Ä¶</p>
<ol>
<li>
<p><strong>Boot2 Bootloader <code>blsp_boot2.bin</code></strong></p>
<p>(Written to the Flashing Image as <code>boot2image.bin</code>)</p>
</li>
<li>
<p><strong>Application Firmware <code>bl602.bin</code></strong></p>
<p>(Written to the Flashing Image as <code>fwimage.bin</code>)</p>
</li>
<li>
<p><strong>Partition Table <code>partition.bin</code></strong> and <strong>Device Tree <code>ro_params.dtb</code></strong></p>
</li>
</ol>
<p>Here‚Äôs how the Flashing Image is constructed‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/boot-title.jpg" alt="Flashing BL602 firmware" /></p>
<p><em>Why is the Boot2 Bootloader transferred to BL602 during flashing?</em></p>
<p>During flashing, our Application Firmware isn‚Äôt written directly to BL602‚Äôs <strong>XIP Flash Memory</strong>.</p>
<p>Instead, <strong>BL602 runs the Boot2 Bootloader</strong> which‚Ä¶</p>
<ol>
<li>
<p><strong>Extracts our Application Firmware</strong> from the transferred Flashing Image</p>
</li>
<li>
<p><strong>Writes our Application Firmware</strong> to XIP Flash Memory at address <strong><code>0x2300 0000</code></strong>.</p>
</li>
</ol>
<p>(XIP means ‚ÄúExecute In Place‚Äù, it refers to the BL602 Flash Memory that will store our executable firmware code)</p>
<p><em>Where is the Boot2 Bootloader located?</em></p>
<p>BL602 runs the Boot2 Bootloader from XIP Flash Memory at address <strong><code>0x2300 0000</code></strong>.</p>
<p>Yep it‚Äôs the <strong>same address as our Application Firmware</strong>!</p>
<p><em>So the Bootloader overwrites itself by our Application Firmware?</em></p>
<p>Yes indeed. We‚Äôll learn later how the <strong>Boot2 Bootloader overwrites itself</strong> by the Application Firmware.</p>
<p><em>Is Boot2 really a Bootloader?</em></p>
<p>On other microcontrollers, the Bootloader is the first thing that runs when powered on. (Before jumping to the Application Firmware)</p>
<p>On BL602, the Boot2 Bootloader <strong>runs only when we flash new Application Firmware</strong>. (So that the Application Firmware may be loaded into XIP Flash Memory)</p>
<p>So the Bootloader concept is a little different for BL602‚Ä¶ It‚Äôs more like an <strong>‚ÄúApplication Firmware Loader‚Äù</strong></p>
<p><em>Why so complicated?</em></p>
<p>BL602‚Äôs Boot2 Bootloader allows Application Firmware to be <strong>flashed securely</strong> to XIP Flash Memory‚Ä¶</p>
<ol>
<li>
<p>Boot2 Bootloader supports <strong>flashing of AES-Encrypted Application Firmware</strong></p>
<p>(So it‚Äôs possible to push encrypted firmware updates over-the-air)</p>
</li>
<li>
<p>Boot2 Bootloader can use <strong>Digital Signatures</strong> to verify that the Application Firmware is authentic</p>
<p>(Prevents tampering of firmware updates)</p>
</li>
</ol>
<p>We‚Äôll learn more about firmware security.</p>
<p><img src="https://lupyuen.github.io/images/boot-loader.png" alt="BL602 Boot2 Bootloader runs at address 0x2300 0000" /></p>
<p><em>BL602 Boot2 Bootloader runs at address <code>0x2300 0000</code></em></p>
<h1 id="inside-the-bootloader" class="section-header"><a href="#inside-the-bootloader">2 Inside the Bootloader</a></h1>
<p>To understand the BL602 Bootloader, let‚Äôs look at the code inside‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/boot-main.png" alt="Bootloader Main Function" /></p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_boot2.c#L389-L571"><code>bl602_boot2/blsp_boot2.c</code></a></p>
<ol>
<li>
<p>The Bootloader starts by fetching the <strong>Clock Configuration and SPI Flash Configuration</strong> from the Flashing Image <a href="https://lupyuen.github.io/articles/flash#appendix-bl602-efuse-configuration">(See this)</a></p>
<pre><code class="language-c">//  SPI Flash Configuration
SPI_Flash_Cfg_Type flashCfg;

//  EFuse Hardware Configuration
Boot_Efuse_HW_Config efuseCfg;

int main(void) {
    ...
  //  It's better not enable interrupt
  //  BLSP_Boot2_Init_Timer();

  //  Set RAM Max size
  BLSP_Boot2_Disable_Other_Cache();

  //  Flush cache to get parameter
  BLSP_Boot2_Flush_XIP_Cache();

  Boot_Clk_Config clkCfg;  //  Clock Configuration
  ret = BLSP_Boot2_Get_Clk_Cfg(&amp;clkCfg);

  ret |= SF_Cfg_Get_Flash_Cfg_Need_Lock(0, &amp;flashCfg);
  BLSP_Boot2_Flush_XIP_Cache();
</code></pre>
</li>
<li>
<p>Next the Bootloader <strong>initialises the Hardware Platform</strong>‚Ä¶</p>
<pre><code class="language-c">  bflb_platform_print_set(BLSP_Boot2_Get_Log_Disable_Flag());

  bflb_platform_init(BLSP_Boot2_Get_Baudrate());

  bflb_platform_deinit_time();
</code></pre>
</li>
<li>
<p>We fetch the <strong>EFuse Configuration</strong> (for decrypting the Application Firmware and for verifying the firmware signature)</p>
<pre><code class="language-c">  MSG_DBG(&quot;Get efuse config\r\n&quot;);
  BLSP_Boot2_Get_Efuse_Cfg(&amp;efuseCfg);
</code></pre>
</li>
<li>
<p>We <strong>reset the Security Engine</strong> (for AES Encryption operations)</p>
<pre><code class="language-c">  //  Reset Sec_Eng for using
  BLSP_Boot2_Reset_Sec_Eng();
</code></pre>
</li>
<li>
<p>The Bootloader supports <strong>multicore CPUs</strong>.  (Each core will start the Application Firmware with different parameters)</p>
<p>BL602 is a single-core CPU, so the <strong>CPU Count</strong> will be set to 1‚Ä¶</p>
<pre><code class="language-c">  if (BLSP_Boot2_Get_Feature_Flag() != BLSP_BOOT2_SP_FLAG) {
    //  Get CPU count info
    cpuCount = BLSP_Boot2_Get_CPU_Count();
  } else {
    cpuCount = 1;
  }
</code></pre>
</li>
<li>
<p>We <strong>fetch the Application Firmware Name</strong> from the Flashing Image.</p>
<p>Our Application Firmware is always named <strong>‚Äú<code>FW</code>‚Äù</strong> <a href="https://lupyuen.github.io/articles/flash#appendix-bl602-partition-table">(See this)</a></p>
<pre><code class="language-c">  //  Get power save mode
  psMode = BLSP_Read_Power_Save_Mode();

  //  Get User specified firmware
  uint8_t userFwName[9] = {0};  //  Firmware Name
  ARCH_MemCpy_Fast(
    userFwName,
    BLSP_Get_User_Specified_Fw(),
    4);
</code></pre>
</li>
<li>
<p>We register the functions that will be called to <strong>Erase, Write and Read the Partition Table</strong>‚Ä¶</p>
<pre><code class="language-c">  if (BLSP_Boot2_8M_Support_Flag()) {
    //  Set flash operation function, read via sbus
    PtTable_Set_Flash_Operation(PtTable_Flash_Erase,
      PtTable_Flash_Write, PtTable_Flash_Read);
  } else {
    //  Set flash operation function, read via xip
    PtTable_Set_Flash_Operation(PtTable_Flash_Erase,
      PtTable_Flash_Write, PtTable_Flash_Read);
  }
</code></pre>
<p>(Yes the parameters for both calls of <code>PtTable_Set_Flash_Operation</code> are identical)</p>
</li>
<li>
<p>The Bootloader enters two loops‚Ä¶</p>
<ul>
<li>
<p><strong>Outer Loop ‚Äú<code>while</code>‚Äù</strong>: Loops until the writing (or rollback) of Application Firmware is complete</p>
</li>
<li>
<p><strong>Inner Loop ‚Äú<code>do</code>‚Äù</strong>: Loops through the Partition Table Entries until the writing of Application Firmware to XIP Flash Memory is complete </p>
</li>
</ul>
<pre><code class="language-c">  while (1) {
    tempMode = 0;
    do {
</code></pre>
<p>Let‚Äôs probe the inner loop‚Ä¶</p>
</li>
<li>
<p>We fetch the next <strong>Partition Table Entry</strong> from the Flashing Image‚Ä¶</p>
<pre><code class="language-c">      activeID = PtTable_Get_Active_Partition_Need_Lock(ptTableStuff);
      if (PT_TABLE_ID_INVALID==activeID){ BLSP_Boot2_On_Error(&quot;No valid PT\r\n&quot;); }

      BLSP_Boot2_Get_MFG_StartReq(
        activeID,
        &amp;ptTableStuff[activeID], 
        &amp;ptEntry[0],
        userFwName);
</code></pre>
</li>
<li>
<p>We skip these two conditions because our Application Firmware is named ‚Äú<code>FW</code>‚Äù and we‚Äôre running on a single-core CPU‚Ä¶</p>
<pre><code class="language-c">      //  Get entry and boot
      if (userFwName[0] == '0') {
        //  Skip this code because our Firmware Name is &quot;FW&quot;
        ...
      } else if (userFwName[0] == '1' &amp;&amp; cpuCount &gt; 1) {
        //  Skip this code because our CPU Count is 1 (single core)
        ...
      } 
</code></pre>
</li>
<li>
<p>Now comes the fun part!</p>
<p>The Bootloader <strong>extracts the Application Firmware</strong> (from the Flashing Image) and <strong>writes it to XIP Flash Memory</strong>‚Ä¶</p>
<pre><code class="language-c">      else {
        ptParsed = BLSP_Boot2_Deal_One_FW(
          activeID,
          &amp;ptTableStuff[activeID],
          &amp;ptEntry[0],
          NULL,
          PT_ENTRY_FW_CPU0);

        if (ptParsed == 0) { continue; }
        if (cpuCount &gt; 1) {
          //  Skip this code because our CPU Count is 1 (single core)
          ...
        }
      }
</code></pre>
<p>We‚Äôll study <strong><code>BLSP_Boot2_Deal_One_FW</code></strong> in the next chapter.</p>
</li>
<li>
<p>The Inner Loop repeats until it has located and processed the Application Firmware‚Ä¶</p>
<pre><code class="language-c">      ptParsed = 1;
    } while (ptParsed == 0);
</code></pre>
</li>
<li>
<p>Now that the Application Firmware has been written to XIP Flash Memory, let‚Äôs get ready to start the Application Firmware!</p>
<p>We stage the <strong>Partition Table Entry</strong> that will be passed to the firmware‚Ä¶</p>
<pre><code class="language-c">    //  Pass data to App
    BLSP_Boot2_Pass_Parameter(NULL, 0);

    //  Pass active partition table ID
    BLSP_Boot2_Pass_Parameter(&amp;activeID, 4);

    //  Pass active partition table content: table header + entries + crc32
    BLSP_Boot2_Pass_Parameter(
      &amp;ptTableStuff[activeID],
      sizeof(PtTable_Config) + 4
        + ptTableStuff[activeID].ptTable.entryCnt
          * sizeof(PtTable_Entry_Config));
</code></pre>
</li>
<li>
<p>We pass the <strong>Flash Configuration</strong> too‚Ä¶</p>
<pre><code class="language-c">    //  Pass flash config
    if (ptEntry[0].Address[ptEntry[0].activeIndex] != 0) {
      XIP_SFlash_Read_Via_Cache_Need_Lock(
        BLSP_BOOT2_XIP_BASE 
          + ptEntry[0].Address[ptEntry[0].activeIndex] 
          + 8,
        flashCfgBuf,
        sizeof(flashCfgBuf));

      //  Include magic and CRC32
      BLSP_Boot2_Pass_Parameter(
        flashCfgBuf,
        sizeof(flashCfgBuf));
    }
</code></pre>
</li>
<li>
<p>We initialise the <strong>Boot Header</strong> for each core (in a multicore CPU)</p>
<pre><code class="language-c">    MSG_DBG(&quot;Boot start\r\n&quot;);
    for (i = 0; i &lt; cpuCount; i++) {
      bootHeaderAddr[i] = ptEntry[i].Address[ptEntry[i].activeIndex];
    }
</code></pre>
</li>
<li>
<p>Finally we <strong>jump to the Application Firmware</strong> that has been written to XIP Flash Memory‚Ä¶</p>
<pre><code class="language-c">#ifdef BLSP_BOOT2_ROLLBACK  //  This is true
    //  Test mode is not need roll back
    if (rollBacked == 0 &amp;&amp; tempMode == 0) {
      ret = BLSP_MediaBoot_Main(bootHeaderAddr, bootRollback, 1);
    } else {
      ret = BLSP_MediaBoot_Main(bootHeaderAddr, bootRollback, 0);
    }
#else  //  This is false
    ...
#endif
    //  Fail in temp mode, continue to boot normal image
    if (tempMode == 1) { continue; }
</code></pre>
<p>(<strong><code>BLSP_BOOT2_ROLLBACK</code></strong> is defined because the Bootloader supports firmware rollback)</p>
<p>We‚Äôll cover <strong><code>BLSP_MediaBoot_Main</code></strong> in a while.</p>
</li>
<li>
<p>What happens if the Bootloader fails to update or start the new Application Firmware?</p>
<p>The Bootloader will <strong>rollback the Application Firmware</strong> and restore the previous version into XIP Flash Memory‚Ä¶</p>
<pre><code class="language-c">#ifdef BLSP_BOOT2_ROLLBACK  //  This is true
    //  If rollback is done, we still fail, break
    if (rollBacked) { break; }
    for (i = 0; i &lt; cpuCount; i++) {
      if (bootRollback[i] != 0) {
        if (BFLB_BOOT2_SUCCESS == BLSP_Boot2_Rollback_PtEntry(
          activeID, &amp;ptTableStuff[activeID], &amp;ptEntry[i])) {
          rollBacked = 1;
        }
      }
    }
    //  If need no rollback, boot fail due to other reseaon instead of imgae issue, break
    if (rollBacked == 0) { break; }
#else  //  This is false
    ...
#endif
  }
</code></pre>
<p>(The Outer Loop ends here)</p>
</li>
<li>
<p>The Main Function of the Bootloader will never return, because the Bootloader <strong>always jumps to the Application Firmware</strong>‚Ä¶</p>
<pre><code class="language-c">  //  We should never get here unless boot fail
  MSG_ERR(&quot;Media boot return %d\r\n&quot;,ret);
  while (1) {
    MSG_ERR(&quot;BLSP boot2 fail\r\n&quot;);
    ARCH_Delay_MS(500);
  }
}
</code></pre>
</li>
</ol>
<p>That‚Äôs how the Bootloader installs our Application Firmware and starts the firmware!</p>
<p><img src="https://lupyuen.github.io/images/boot-main2.png" alt="Bootloader Main Function" /></p>
<h1 id="install-application-firmware" class="section-header"><a href="#install-application-firmware">3 Install Application Firmware</a></h1>
<p>As we‚Äôve seen, the Bootloader calls <strong><code>BLSP_Boot2_Deal_One_FW</code></strong> to‚Ä¶</p>
<ol>
<li>
<p><strong>Extract the Application Firmware</strong> from the Flashing Image</p>
</li>
<li>
<p><strong>Write the Application Firmware to XIP Flash Memory</strong> at <code>0x2300 0000</code></p>
</li>
</ol>
<p>Here‚Äôs how it works: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_boot2.c#L271-L313"><code>blsp_boot2.c</code></a></p>
<pre><code class="language-c">//  Boot2 deal with one firmware.
//  Return 0 for partition table changed, need re-parse.
//  Return 1 for partition table or entry parsed successfully.
static int BLSP_Boot2_Deal_One_FW(
  PtTable_ID_Type activeID,       //  Active partition table ID
  PtTable_Stuff_Config *ptStuff,  //  Pointer of partition table stuff
  PtTable_Entry_Config *ptEntry,  //  Pointer of active entry
  uint8_t *fwName,                //  Firmware name pointer
  PtTable_Entry_Type type) {      //  Firmware name ID
  uint32_t ret;

  if (fwName != NULL) {
    MSG_DBG(&quot;Get FW:%s\r\n&quot;, fwName);
    ret = PtTable_Get_Active_Entries_By_Name(ptStuff, fwName, ptEntry);
  } else {
    MSG_DBG(&quot;Get FW ID:%d\r\n&quot;, type);
    ret = PtTable_Get_Active_Entries_By_ID(ptStuff, type, ptEntry);
  }
</code></pre>
<p><strong><code>BLSP_Boot2_Deal_One_FW</code></strong> starts by fetching the <strong>Partition Table Entry</strong> for our Application Firmware named ‚Äú<code>FW</code>‚Äù.</p>
<p>Then it <strong>extracts the Application Firmware</strong> from the Flashing Image‚Ä¶</p>
<pre><code class="language-c">  if (PT_ERROR_SUCCESS != ret) {
    MSG_ERR(&quot;Entry not found\r\n&quot;);
  } else {
    BLSP_Dump_PtEntry(ptEntry);
    MSG_DBG(&quot;Check Img\r\n&quot;);
    if (BLSP_Boot2_Check_XZ_FW(activeID, ptStuff, ptEntry) == 1) {
      return 0;
    }
</code></pre>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_boot2.c#L190-L224"><strong><code>BLSP_Boot2_Check_XZ_FW</code></strong></a> extracts and decompresses the Application Firmware. <a href="https://en.wikipedia.org/wiki/XZ_Utils">(XZ Compression)</a></p>
<p>Now that we have the decompressed Application Firmware, we <strong>write the firmware to XIP Flash Memory</strong> at <code>0x2300 0000</code>‚Ä¶</p>
<pre><code class="language-c">    //  Check if this partition need copy
    if (ptEntry-&gt;activeIndex &gt;= 2) {
      if (BFLB_BOOT2_SUCCESS == BLSP_Boot2_Do_FW_Copy(
        activeID, 
        ptStuff, 
        ptEntry)) {
        return 0;
      }
    }
  }
  return 1;
}
</code></pre>
<p>In the next chapter we study <strong><code>BLSP_Boot2_Do_FW_Copy</code></strong>.</p>
<p><img src="https://lupyuen.github.io/images/boot-install.png" alt="Bootloader installing Application Firmware" /></p>
<h1 id="write-firmware-to-xip-flash" class="section-header"><a href="#write-firmware-to-xip-flash">4 Write Firmware to XIP Flash</a></h1>
<p>Previously on ‚ÄúDays Of Our Lives‚Äù‚Ä¶ The Bootloader decompresses the Application Firmware and calls <strong><code>BLSP_Boot2_Do_FW_Copy</code></strong> to write the firmware to XIP Flash Memory.</p>
<p>Watch what happens next: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_boot2.c#L226-L269"><code>blsp_boot2.c</code></a></p>
<pre><code class="language-c">//  Buffer for writing to XIP Flash Memory
#define BFLB_BOOT2_READBUF_SIZE  4 * 1024
uint8_t boot2ReadBuf[BFLB_BOOT2_READBUF_SIZE] __attribute__((section(&quot;.system_ram&quot;)));

//  Boot2 copy firmware from OTA region to normal region
static int BLSP_Boot2_Do_FW_Copy(
  PtTable_ID_Type activeID,         //  Active partition table ID
  PtTable_Stuff_Config *ptStuff,    //  Pointer of partition table stuff
  PtTable_Entry_Config *ptEntry) {  //  Pointer of active entry

  uint8_t activeIndex = ptEntry-&gt;activeIndex;
  uint32_t srcAddress = ptEntry-&gt;Address[activeIndex&amp;0x01];
  uint32_t destAddress = ptEntry-&gt;Address[!(activeIndex&amp;0x01)];
  uint32_t destMaxSize = ptEntry-&gt;maxLen[!(activeIndex&amp;0x01)];
  uint32_t totalLen = ptEntry-&gt;len;
  uint32_t dealLen = 0;
  uint32_t curLen = 0;
</code></pre>
<p><strong><code>BLSP_Boot2_Do_FW_Copy</code></strong> starts by fetching the <strong>Partition Table Entry</strong> for the Application Firmware, containing <strong>Source Address, Destination Address (<code>0x2300 0000</code>) and Firmware Length</strong>.</p>
<p>(More about the Partition Table in the next chapter)</p>
<p>Then it <strong>erases the XIP Flash Memory</strong> at the Destination Address <code>0x2300 0000</code></p>
<pre><code class="language-c">  if (SUCCESS != XIP_SFlash_Erase_Need_Lock(
    &amp;flashCfg,
    destAddress,
    destAddress+destMaxSize - 1)) {
    MSG_ERR(&quot;Erase flash fail&quot;);
    return BFLB_BOOT2_FLASH_ERASE_ERROR;
  }
</code></pre>
<p>Next we handle the decompressed Application Firmware, chunk by chunk (4 KB)</p>
<pre><code class="language-c">  while (dealLen &lt; totalLen) {
    curLen = totalLen - dealLen;
    if (curLen &gt; sizeof(boot2ReadBuf)) {
      curLen = sizeof(boot2ReadBuf);
    }
</code></pre>
<p>We <strong>read the decompressed Application Firmware</strong> (4 KB chunk)</p>
<pre><code class="language-c">    if (BFLB_BOOT2_SUCCESS != BLSP_MediaBoot_Read(
      srcAddress,
      boot2ReadBuf,
      curLen)) {
      MSG_ERR(&quot;Read FW fail when copy\r\n&quot;);
      return BFLB_BOOT2_FLASH_READ_ERROR;
    }
</code></pre>
<p>We <strong>write the firmware to XIP Flash Memory</strong> (4 KB chunk) starting at <code>0x2300 0000</code></p>
<pre><code class="language-c">    if (SUCCESS != XIP_SFlash_Write_Need_Lock(
      &amp;flashCfg,
      destAddress,
      boot2ReadBuf,
      curLen)) {
      MSG_ERR(&quot;Write flash fail&quot;);
      return BFLB_BOOT2_FLASH_WRITE_ERROR;
    }
</code></pre>
<p>Finally we repeat the steps with the <strong>next 4 KB chunk</strong>, until the entire decompressed Application Firmware is written to XIP Flash Memory‚Ä¶</p>
<pre><code class="language-c">    srcAddress += curLen;
    destAddress += curLen;
    dealLen += curLen;
  }
  return BFLB_BOOT2_SUCCESS;
}
</code></pre>
<p><img src="https://lupyuen.github.io/images/boot-write.png" alt="Bootloader writing firmware to XIP flash" /></p>
<h1 id="bl602-partition-table" class="section-header"><a href="#bl602-partition-table">5 BL602 Partition Table</a></h1>
<p><em>The Bootloader appears to be driven by the Partition Table (from the Flashing Image). What‚Äôs inside the Partition Table?</em></p>
<p>Each entry of the <strong>Partition Table</strong> describes a <strong>section of the Flashing Image</strong>.</p>
<p>Here‚Äôs the <strong>Partition Table Entry</strong> that describes our <strong>Application Firmware</strong>‚Ä¶</p>
<pre><code class="language-text">[[pt_entry]]
type     = 0
name     = &quot;FW&quot;
device   = 0
address0 = 0x10000
size0    = 0xC8000
address1 = 0xD8000
size1    = 0x88000
len      = 0
</code></pre>
<p><a href="https://lupyuen.github.io/articles/flash#appendix-bl602-partition-table">(From this BL602 Partition Table)</a></p>
<p>This Partition Table Entry says that our Application Firmware (compressed) is located in the Flash Image at <strong>offset <code>0x10000</code> with size <code>0xC8000</code></strong> (compressed).</p>
<p>(But why are there two firmware sections <code>0x10000</code> and <code>0xD8000</code>?)</p>
<p>With this information, our Bootloader will be able to decompress the Application Firmware and write to XIP Flash Memory‚Ä¶ </p>
<pre><code class="language-c">static int BLSP_Boot2_Do_FW_Copy( ... ) {
  //  Fetch the Partition Table Entry for the Application Firmware
  uint8_t activeIndex = ptEntry-&gt;activeIndex;
  uint32_t srcAddress = ptEntry-&gt;Address[activeIndex&amp;0x01];
  uint32_t destAddress = ptEntry-&gt;Address[!(activeIndex&amp;0x01)];
  uint32_t destMaxSize = ptEntry-&gt;maxLen[!(activeIndex&amp;0x01)];
  uint32_t totalLen = ptEntry-&gt;len;
</code></pre>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_boot2.c#L226-L269">(We‚Äôve seen this earlier in <code>blsp_boot2.c</code>)</a></p>
<p><strong>Exercise for the Reader:</strong> Please take these two things‚Ä¶</p>
<ol>
<li>
<p><strong><code>pt_entry</code></strong> Partition Table Entry above</p>
</li>
<li>
<p><strong><code>BLSP_Boot2_Do_FW_Copy</code></strong> code above</p>
</li>
</ol>
<p>Match them and verify that the code makes sense!</p>
<p>(Maybe we‚Äôll figure out why there are two firmware sections <code>0x10000</code> and <code>0xD8000</code>)</p>
<p><a href="https://lupyuen.github.io/articles/flash#partition-table">More about BL602 Partition Table</a></p>
<p><img src="https://lupyuen.github.io/images/boot-partition.png" alt="Matching the BL602 Partition Table" /></p>
<h1 id="bl602-rom-driver-api" class="section-header"><a href="#bl602-rom-driver-api">6 BL602 ROM Driver API</a></h1>
<p>Earlier we‚Äôve seen these functions called by the Bootloader to <strong>access XIP Flash Memory</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>XIP_SFlash_Erase_Need_Lock</strong>: Erase XIP Flash Memory</p>
</li>
<li>
<p><strong>XIP_SFlash_Read_Via_Cache_Need_Lock</strong>: Read XIP Flash Memory</p>
</li>
<li>
<p><strong>XIP_SFlash_Write_Need_Lock</strong>: Write XIP Flash Memory</p>
</li>
</ul>
<p><em>These XIP Flash Memory Functions are defined in the Bootloader right?</em></p>
<p>Not quite‚Ä¶ The XIP Flash Memory Functions are located in the <strong>BL602 Boot ROM</strong>!</p>
<p><em>Shiver me timbers and call me Shirley! What‚Äôs the BL602 Boot ROM?</em></p>
<p><strong>BL602 Boot ROM</strong> is the region of <strong>Read-Only Memory at <code>0x2100 0000</code></strong> that contains‚Ä¶</p>
<ol>
<li>
<p><strong>Boot Code</strong> that‚Äôs run whenever we power on (or reset) BL602</p>
<p>(The Boot Code runs just before the Bootloader)</p>
</li>
<li>
<p><strong>ROM Driver API</strong> called by the Bootloader</p>
<p>(Like the XIP Flash Memory Functions above)</p>
</li>
</ol>
<p><em>Why put the ROM Driver API in the Boot ROM?</em></p>
<ul>
<li>
<p>We <strong>reduce the Bootloader size</strong> by placing the low-level functions in Boot ROM</p>
</li>
<li>
<p>Some ROM Driver Functions need to run in a <strong>secure, tamper-proof ROM environment</strong></p>
<p>(Like the functions for decrypting and verifying Application Firmware)</p>
</li>
</ul>
<p><em>Wait this sounds familiar‚Ä¶?</em></p>
<p>Our computers have a similar Boot ROM‚Ä¶ It‚Äôs called the <a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface"><strong>Unified Extensible Firmware Interface (UEFI)</strong></a></p>
<p>It contains secure boot code that‚Äôs run whenever we power on our computer.</p>
<p>In the next chapter we shall explore the <strong>Table of ROM Driver API Functions</strong> located in ROM API at <strong><code>0x2101 0800</code></strong></p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Inc/bl602_romdriver.h"><code>bl602_romdriver.h</code></a> ‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/boot-driver5.png" alt="ROM Driver API in Boot ROM" /></p>
<h1 id="locating-the-rom-driver-api" class="section-header"><a href="#locating-the-rom-driver-api">7 Locating the ROM Driver API</a></h1>
<p><em>How did we find out that the ROM Driver API is located in Boot ROM?</em></p>
<p>Let‚Äôs look at the <strong>RISC-V Disassembly for the Bootloader</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/releases/download/v8.0.2/bl602_boot2.S"><code>bl602_boot2.S</code></a></p>
<pre><code class="language-c">__ALWAYS_INLINE BL_Err_Type ATTR_TCM_SECTION 
XIP_SFlash_Read_Via_Cache_Need_Lock(
  uint32_t addr,
  uint8_t *data, 
  uint32_t len) {
  return RomDriver_XIP_SFlash_Read_Via_Cache_Need_Lock(
    addr, 
    data, 
    len);
}
</code></pre>
<p>That‚Äôs the C definition of the function <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_romapi.c#L833-L836"><strong>XIP_SFlash_Read_Via_Cache_Need_Lock</strong></a>.</p>
<p>(Which is called by the Bootloader to read XIP Flash Memory)</p>
<p><em>The function looks kinda empty?</em></p>
<p>Yes, because <strong>XIP_SFlash_Read_Via_Cache_Need_Lock</strong> is a <strong>Stub Function</strong>.</p>
<p>It forwards the Function Call to the _<em>Real Function: RomDriver_XIP_SFlash_Read_Via_Cache <em>Need_Lock</em></em>.</p>
<p><em>Where is the Real Function for reading XIP Flash Memory?</em></p>
<p>After the code above we see the RISC-V Assembly Code that the GCC Compiler has emitted for our Stub Function‚Ä¶</p>
<pre><code class="language-text">2201050a &lt;XIP_SFlash_Read_Via_Cache_Need_Lock&gt;:
2201050a:	210117b7          	lui	a5,0x21011
2201050e:	aa47a303          	lw	t1,-1372(a5) # 21010aa4 &lt;StackSize+0x210106a4&gt;
22010512:	8302                	jr	t1
</code></pre>
<p><em>So the Real Function is located at <code>0x2101 0aa4</code>?</em></p>
<p>Right! _<em>RomDriver_XIP_SFlash_Read_Via_Cache <em>Need_Lock</em></em> is located in the Boot ROM at <code>0x2101 0aa4</code>.</p>
<p>(Remember that the Boot ROM lives at <code>0x2100 0000</code> to <code>0x2101 FFFF</code>)</p>
<p>Hence when the Bootloader reads XIP Flash Memory‚Ä¶</p>
<ol>
<li>
<p>Bootloader calls the <strong>Stub Function</strong> at <code>0x2201 050a</code></p>
<p>(Located in ITCM)</p>
</li>
<li>
<p>Stub Function calls the <strong>Real Function</strong> at <code>0x2101 0aa4</code></p>
<p>(Located in Boot ROM)</p>
</li>
</ol>
<p><em>What‚Äôs ITCM?</em></p>
<p>ITCM means <strong>Instruction Tightly Coupled Memory</strong>.</p>
<p>This is <strong>Cache Memory</strong> (RAM) that has been configured (via the Level 1 Cache Controller) for code execution.</p>
<p>(See ‚ÄúChapter 7: L1C (Level 1 Cache)‚Äù in the BL602 Reference Manual)</p>
<p><em>What are the functions in the ROM Driver API?</em></p>
<p>The <strong>ROM Driver Functions</strong> are listed in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_romdriver.c#L80-L269"><code>bl602_romdriver.c</code></a> and <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Inc/bl602_romdriver.h"><code>bl602_romdriver.h</code></a></p>
<p>The functions cover‚Ä¶</p>
<ul>
<li>
<p>Power On / Off, Power Management, Reset</p>
</li>
<li>
<p>Memory Access, Flash Memory</p>
</li>
<li>
<p>GPIO, EFuse and Delay</p>
</li>
</ul>
<p>The <strong>Bootloader Linker Map <a href="https://github.com/lupyuen/bl_iot_sdk/releases/download/v8.0.2/bl602_boot2.map"><code>bl602_boot2.map</code></a></strong> reveals the <strong>Table of ROM Driver Stub Functions</strong> at ITCM address <code>0x2201 0000</code>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/boot-driver.png" alt="ROM Driver Functions" /></p>
<h1 id="bootloader-overwrites-itself" class="section-header"><a href="#bootloader-overwrites-itself">8 Bootloader Overwrites Itself</a></h1>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_media_boot.c#L337-L434"><strong><code>BLSP_MediaBoot_Main</code></strong> is defined here</a></p>
<p>BLSP_Boot2_Set_Cache</p>
<p>https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_port.c#L423-L485</p>
<p><a href="https://twitter.com/__9names">9names</a></p>
<p><a href="https://twitter.com/__9names/status/1401152245693960193">Comment on Twitter</a></p>
<blockquote>
<p>It doesn‚Äôt overwrite itself, that‚Äôs the trick.
What is at <code>0x23000000</code> depends on how the cache is configured, you can change it! See <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/bl602_boot2/bl602_boot2/blsp_common.c#L165-L257"><code>BLSP_Boot2_Jump_Entry</code> in <code>blsp_common.c</code></a> for an example.
This is what makes it possible to boot multiple applications without patching the firmware</p>
</blockquote>
<h1 id="efuse-security" class="section-header"><a href="#efuse-security">9 EFuse Security</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/boot-efuse.png" alt="" /></p>
<p>TODO</p>
<h1 id="bl602-firmware-boot-code" class="section-header"><a href="#bl602-firmware-boot-code">10 BL602 Firmware Boot Code</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/boot-code.png" alt="" /></p>
<p>TODO</p>
<h1 id="other-bootloaders" class="section-header"><a href="#other-bootloaders">11 Other Bootloaders</a></h1>
<p>TODO</p>
<p>Check out this interview that explains why the PineTime Bootloader is designed that way‚Ä¶</p>
<ul>
<li><a href="https://www.ncartron.org/interview-with-lup-creator-of-pinetimes-bootloader.html"><strong>‚ÄúInterview with Lup, creator of PineTime‚Äôs bootloader‚Äù</strong></a></li>
</ul>
<h1 id="whats-next" class="section-header"><a href="#whats-next">12 What‚Äôs Next</a></h1>
<p>TODO</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/boot.md"><code>lupyuen.github.io/src/boot.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">13 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1398855867030593538">this Twitter Thread</a></p>
</li>
<li>
<p>Checking the bootloader</p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/boot-compare.png" alt="" /></p>
<p>TODO</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/boot-driver2.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/boot-driver3.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/boot-driver4.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/boot-rust.png" alt="" /></p>
<p>TODO</p>
<p><code>BLSP_Boot2_Deal_One_FW</code></p>
<p><code>BLSP_Boot2_Check_XZ_FW</code></p>
<p><code>BLSP_Boot2_Do_FW_Copy</code></p>
<p><code>BLSP_MediaBoot_Read</code></p>
<p><code>BLSP_MediaBoot_Main</code></p>

    
</body>
</html>