<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Simulate RISC-V BL602 with WebAssembly, uLisp and Blockly</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Simulate RISC-V BL602 with WebAssembly, uLisp and Blockly" 
    data-rh="true">
<meta property="og:description" 
    content="How we simulate the BL602 RISC-V SoC with uLisp in WebAssembly... And preview Blockly uLisp Apps in the Web Browser"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/wasm-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Simulate RISC-V BL602 with WebAssembly, uLisp and Blockly</h1>
    <nav id="TOC"><ul>
<li><a href="#emscripten-and-webassembly">1 Emscripten and WebAssembly</a><ul></ul></li>
<li><a href="#repl-in-a-web-browser">2 REPL in a Web Browser</a><ul></ul></li>
<li><a href="#render-the-bl602-simulator">3 Render the BL602 Simulator</a><ul></ul></li>
<li><a href="#simulate-bl602-hardware">4 Simulate BL602 Hardware</a><ul></ul></li>
<li><a href="#add-a-simulation-event">5 Add a Simulation Event</a><ul></ul></li>
<li><a href="#get-the-simulation-events">6 Get the Simulation Events</a><ul></ul></li>
<li><a href="#flip-the-simulated-led">7 Flip the Simulated LED</a><ul></ul></li>
<li><a href="#simulate-delays">8 Simulate Delays</a><ul></ul></li>
<li><a href="#simulate-loops">9 Simulate Loops</a><ul></ul></li>
<li><a href="#add-simulator-to-blockly">10 Add Simulator to Blockly</a><ul></ul></li>
<li><a href="#simulate-blockly-programs">11 Simulate Blockly Programs</a><ul></ul></li>
<li><a href="#can-we-simulate-any-bl602-firmware">12 Can We Simulate Any BL602 Firmware?</a><ul></ul></li>
<li><a href="#why-simulate-a-stream-of-events">13 Why Simulate A Stream Of Events?</a><ul></ul></li>
<li><a href="#whats-next">14 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">15 Notes</a><ul></ul></li></ul></nav><p>üìù <em>27 May 2021</em></p>
<p><em>Drag-and-drop uLisp programs for microcontrollers‚Ä¶ And run them WITHOUT a microcontroller!</em></p>
<p>What if we‚Ä¶</p>
<ol>
<li>
<p>Compile the <strong>uLisp Interpreter <a href="https://lupyuen.github.io/articles/lisp">(from the last article)</a> to WebAssembly</strong>‚Ä¶</p>
</li>
<li>
<p>Use the WebAssembly version of uLisp to <strong>simulate BL602 in a Web Browser</strong>‚Ä¶</p>
<p>(Including GPIO, I2C, SPI, Display Controller, Touch Controller, LoRaWAN‚Ä¶ <a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/simulator">Similar to this</a>)</p>
</li>
<li>
<p>Integrate the <strong>BL602 Simulator with Blockly</strong>‚Ä¶</p>
</li>
<li>
<p>To allow embedded developers to <strong>preview their BL602 Blockly Apps in the Web Browser</strong>?</p>
</li>
</ol>
<p>Today we shall build a <strong>Simulator for the BL602 RISC-V SoC</strong> that runs in a Web Browser. And we‚Äôll use it to <strong>preview Blockly uLisp Apps in the browser</strong>!</p>
<ul>
<li><a href="https://youtu.be/Ag2CERd1OzQ"><strong>Watch the BL602 Simulator demo on YouTube</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/wasm-title.png" alt="BL602 Simulator with Blockly and uLisp in WebAssembly" /></p>
<p><em>BL602 Simulator with Blockly and uLisp in WebAssembly</em></p>
<h1 id="emscripten-and-webassembly" class="section-header"><a href="#emscripten-and-webassembly">1 Emscripten and WebAssembly</a></h1>
<p><em>What is Emscripten?</em></p>
<p><strong>Emscripten compiles C programs into WebAssembly</strong> so that we can run them in a Web Browser.</p>
<p>(Think of WebAssembly as a kind of Machine Code that runs natively in any Web Browser)</p>
<p>Here‚Äôs how we compile our uLisp Interpreter <code>ulisp.c</code> <a href="https://lupyuen.github.io/articles/lisp">(from the last article)</a> with the <strong>Emscripten Compiler <code>emcc</code></strong>‚Ä¶</p>
<pre><code class="language-bash">emcc -g -s WASM=1 \
    src/ulisp.c wasm/wasm.c \
    -o ulisp.html \
    -I include \
    -s &quot;EXPORTED_FUNCTIONS=[ '_setup_ulisp', '_execute_ulisp', '_clear_simulation_events', '_get_simulation_events' ]&quot; \
    -s &quot;EXTRA_EXPORTED_RUNTIME_METHODS=[ 'cwrap', 'allocate', 'intArrayFromString', 'UTF8ToString' ]&quot;
</code></pre>
<p>(More about <code>wasm.c</code> in a while)</p>
<p>C programs that call the <strong>Standard C Libraries</strong> should build OK with Emscripten: <code>printf</code>, <code>&lt;stdio.h&gt;</code>, <code>&lt;stdlib.h&gt;</code>, <code>&lt;string.h&gt;</code>, ‚Ä¶ </p>
<p>The Emscripten Compiler generates 3 output files‚Ä¶</p>
<ul>
<li>
<p><strong><code>ulisp.wasm</code></strong>: Contains the <strong>WebAssembly Code</strong> generated for our C program. </p>
</li>
<li>
<p><strong><code>ulisp.js</code></strong>: JavaScript module that <strong>loads the WebAssembly Code</strong> into a Web Browser and runs it</p>
</li>
<li>
<p><strong><code>ulisp.html</code></strong>: HTML file that we may open in a Web Browser to <strong>load the JavaScript module</strong> and run the WebAssembly Code</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/lisp-wasm.png" alt="Compiling uLisp to WebAssembly with Emscripten" /></p>
<p><em>What are the <code>EXPORTED_FUNCTIONS</code>?</em></p>
<pre><code class="language-text">-s &quot;EXPORTED_FUNCTIONS=[ '_setup_ulisp', '_execute_ulisp', '_clear_simulation_events', '_get_simulation_events' ]&quot;
</code></pre>
<p>These are the C functions from our uLisp Interpreter <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c#L5312-L5384"><code>ulisp.c</code></a> that will be <strong>exported to JavaScript</strong>. </p>
<p>Our uLisp Interpreter won‚Äôt do anything meaningful in a Web Browser unless these 2 functions are called‚Ä¶</p>
<ol>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c#L5312-L5319"><strong><code>_setup_ulisp</code></strong></a>: Initialise the uLisp Interpreter</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c#L5377-L5384"><strong><code>_execute_ulisp</code></strong></a>: Execute a uLisp script</p>
</li>
</ol>
<p>(We‚Äôll see the other 2 functions later)</p>
<p><em>How do we call the <code>EXPORTED_FUNCTIONS</code> from JavaScript?</em></p>
<p>Here‚Äôs how we call the WebAssembly functions <code>_setup_ulisp</code> and <code>_execute_ulisp</code> from JavaScript: <a href="https://github.com/lupyuen/ulisp-bl602/blob/f520d0d8bb1583828a0ab456c90df187cd1eef68/docs/ulisp.html#L1300-L1321"><code>ulisp.html</code></a></p>
<pre><code class="language-javascript">/// Wait for emscripten to be initialised
Module.onRuntimeInitialized = function() {
  //  Init uLisp interpreter
  Module._setup_ulisp();

  //  Set the uLisp script 
  var scr = &quot;( list 1 2 3 )&quot;;

  //  Allocate WebAssembly memory for the script
  var ptr = Module.allocate(intArrayFromString(scr), ALLOC_NORMAL);

  //  Execute the uLisp script in WebAssembly
  Module._execute_ulisp(ptr);

  //  Free the WebAssembly memory allocated for the script
  Module._free(ptr);
};
</code></pre>
<p><a href="https://emscripten.org/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html">(More about <code>allocate</code> and <code>free</code>)</a></p>
<p>To run this in a Web Browser, we browse to <code>ulisp.html</code> in a Local Web Server. (Sorry, WebAssembly won‚Äôt run from a Local Filesystem)</p>
<p>Our uLisp Interpreter in WebAssembly shows the result‚Ä¶</p>
<pre><code class="language-text">(1 2 3)
</code></pre>
<p><img src="https://lupyuen.github.io/images/lisp-wasm2.png" alt="Testing uLisp compiled with Emscripten" /></p>
<p><em>But <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c"><code>ulisp.c</code></a> contains references to the BL602 IoT SDK, so it won‚Äôt compile for WebAssembly?</em></p>
<p>For now, we replace the <strong>hardware-specific functions for BL602</strong> by Stub Functions (which will be fixed in a while)‚Ä¶</p>
<pre><code class="language-c">#ifdef __EMSCRIPTEN__  //  If building for WebAssembly...
//  Use stubs for BL602 functions, will fix later.
int bl_gpio_enable_input(uint8_t pin, uint8_t pullup, uint8_t pulldown) 
    { return 0; }
int bl_gpio_enable_output(uint8_t pin, uint8_t pullup, uint8_t pulldown) 
    { return 0; }
int bl_gpio_output_set(uint8_t pin, uint8_t value) 
    { return 0; }
uint32_t time_ms_to_ticks32(uint32_t millisec) 
    { return millisec; }
void time_delay(uint32_t millisec)
    {}

#else                    //  If building for BL602...
#include &lt;bl_gpio.h&gt;     //  For BL602 GPIO Hardware Abstraction Layer
#include &quot;nimble_npl.h&quot;  //  For NimBLE Porting Layer (mulitasking functions)
#endif  //  __EMSCRIPTEN__
</code></pre>
<p>The symbol <code>__EMSCRIPTEN__</code> is defined when we use the Emscripten compiler.</p>
<p>(Yep it‚Äôs possible to reuse the same <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c"><code>ulisp.c</code></a> for BL602 and WebAssembly!)</p>
<p><img src="https://lupyuen.github.io/images/wasm-stub.png" alt="BL602 IoT SDK stubbed out" /></p>
<h1 id="repl-in-a-web-browser" class="section-header"><a href="#repl-in-a-web-browser">2 REPL in a Web Browser</a></h1>
<p><em>uLisp in WebAssembly looks underwhelming. Where‚Äôs the REPL (Read-Evaluate-Print Loop)?</em></p>
<p>As we‚Äôve seen, <strong><code>printf</code> works perfectly fine</strong> in WebAssembly‚Ä¶ The output appears automagically in the HTML Text Box provided by Emscripten.</p>
<p>Console Input is a little more tricky. Let‚Äôs‚Ä¶</p>
<ol>
<li>
<p><strong>Add a HTML Text Box</strong> for input</p>
</li>
<li>
<p><strong>Execute the input text</strong> with uLisp</p>
</li>
</ol>
<p>Here‚Äôs how we add the HTML Text Box: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1242-L1248"><code>ulisp.html</code></a></p>
<pre><code class="language-html">&lt;!-- HTML Text Box for input --&gt;
&lt;textarea id=&quot;input&quot;&gt;&lt;/textarea&gt;

&lt;!-- HTML Button that runs the uLisp script --&gt;
&lt;input id=&quot;run&quot; type=&quot;button&quot; value=&quot;Run&quot; onclick=&quot;runScript()&quot;&gt;&lt;/input&gt;
</code></pre>
<p>Also we add a <strong>‚Äú<code>Run</code>‚Äù Button</strong> that will execute the uLisp Script entered into the Text Box.</p>
<p>Let‚Äôs refactor our JavaScript to <strong>separate the uLisp Initialisation and Execution</strong>.</p>
<p>Here‚Äôs how we initialise the uLisp Interpreter: <a href="https://github.com/lupyuen/ulisp-bl602/blob/88e4fb6fad8025ceb7a88ff7154db053cc2ab861/docs/ulisp.html#L1324-L1350"><code>ulisp.html</code></a></p>
<pre><code class="language-javascript">/// Wait for emscripten to be initialised
Module.onRuntimeInitialized = function() {
  //  Init uLisp interpreter
  Module._setup_ulisp();
};
</code></pre>
<p>In the <strong><code>runScript</code></strong> function (called by the ‚Äú<code>Run</code>‚Äù Button), we grab the uLisp Script from the text box and run it‚Ä¶</p>
<pre><code class="language-javascript">/// Run the script in the input box
function runScript() {
  //  Get the uLisp script from the input text box
  var scr = document.getElementById(&quot;input&quot;).value;

  //  Allocate WebAssembly memory for the script
  var ptr = Module.allocate(intArrayFromString(scr), ALLOC_NORMAL);

  //  Execute the uLisp script
  Module._execute_ulisp(ptr);

  //  Free the WebAssembly memory allocated for the script
  Module._free(ptr);
}
</code></pre>
<p>And our <strong>uLisp REPL in WebAssembly</strong> is done!</p>
<ul>
<li>
<p><a href="https://youtu.be/9uegWNcokxY"><strong>Watch the uLisp WebAssembly REPL demo on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/ulisp-bl602/ulisp.html"><strong>Try the uLisp WebAssembly REPL</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/wasm-repl.png" alt="uLisp REPL in WebAssembly" /></p>
<h1 id="render-the-bl602-simulator" class="section-header"><a href="#render-the-bl602-simulator">3 Render the BL602 Simulator</a></h1>
<p><em>How shall we render the Simulated BL602 Board?</em></p>
<p>Remember how we built the uLisp REPL with <strong>HTML and JavaScript</strong>?</p>
<p>Let‚Äôs do the same for the <strong>BL602 Simulator</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-simulator2.png" alt="BL602 Simulator in HTML and JavaScript" /></p>
<p>First we save this sketchy image of a PineCone BL602 Board as a <strong>PNG file</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wasm-photoshop.png" alt="Creating the BL602 simulator image" /></p>
<p>We <strong>load the PNG file</strong> in our web page: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1336-L1360"><code>ulisp.html</code></a></p>
<pre><code class="language-javascript">/// Wait for emscripten to be initialised
Module.onRuntimeInitialized = function() {
  //  Omitted: Init uLisp interpreter
  ...
  // Load the simulator pic and render it
  const image = new Image();
  image.onload = renderSimulator;  //  Draw when image has loaded
  image.src = 'pinecone.png';      //  Image to be loaded
};
</code></pre>
<p>This code calls the <strong><code>renderSimulator</code></strong> function when our BL602 image has been loaded into memory.</p>
<p>Emscripten has helpfully generated a <strong>HTML Canvas</strong> in <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1238-L1240"><code>ulisp.html</code></a> ‚Ä¶</p>
<pre><code class="language-html">&lt;canvas id=&quot;canvas&quot; class=&quot;emscripten&quot; oncontextmenu=&quot;event.preventDefault()&quot; tabindex=-1&gt;&lt;/canvas&gt;
</code></pre>
<p>In the <strong><code>renderSimulator</code></strong> function, let‚Äôs <strong>render our BL602 image</strong> onto the HTML Canvas: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1348-L1360"><code>ulisp.html</code></a></p>
<pre><code class="language-javascript">/// Render the simulator pic. Based on https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
function renderSimulator() {
  //  Get the HTML canvas and context
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  //  Resize the canvas
  canvas.width  = 400;
  canvas.height = 300;

  //  Draw the image to fill the canvas
  ctx.drawImage(this, 0, 0, canvas.width, canvas.height);
}
</code></pre>
<p>Our <strong>rendered BL602 Simulator</strong> looks like this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wasm-image.png" alt="Rendering the BL602 simulator image" /></p>
<p><em>What about the LED?</em></p>
<p>To simulate the LED switching on, let‚Äôs draw a <strong>blue rectangle</strong> onto the HTML Canvas: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1447-L1470"><code>ulisp.html</code></a></p>
<pre><code class="language-javascript">//  Get the HTML Canvas Context
const ctx = document.getElementById('canvas').getContext('2d');

//  LED On: Set the fill colour to Blue
ctx.fillStyle = '#B0B0FF';  //  Blue

//  Draw the LED colour
ctx.fillRect(315, 116, 35, 74);
</code></pre>
<p>Our <strong>rendered BL602 LED</strong> looks good‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/wasm-led.png" alt="Rendering the LED" /></p>
<p>And to simulate the LED switching off, we draw a <strong>grey rectangle</strong>: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1447-L1470"><code>ulisp.html</code></a></p>
<pre><code class="language-javascript">//  LED Off: Set the fill colour to Grey
ctx.fillStyle = '#CCCCCC';  //  Grey

//  Draw the LED colour
ctx.fillRect(315, 116, 35, 74);
</code></pre>
<p>Now we wire up the Simulated BL602 LED to uLisp!</p>
<h1 id="simulate-bl602-hardware" class="section-header"><a href="#simulate-bl602-hardware">4 Simulate BL602 Hardware</a></h1>
<p>Our story so far‚Ä¶</p>
<ol>
<li>
<p>Our <strong>uLisp Interpreter lives in WebAssembly</strong> (compiled from C with Emscripten)</p>
</li>
<li>
<p>Our <strong>BL602 Simulator lives in JavaScript</strong> (rendered onto a HTML Canvas)</p>
</li>
</ol>
<p><em>How shall we connect uLisp to the BL602 Simulator‚Ä¶ And blink the Simulated LED?</em></p>
<p>Oh yes we have ways of <strong>making uLisp talk to BL602 Simulator</strong>‚Ä¶ From WebAssembly to JavaScript!</p>
<p>Here‚Äôs one way: A <strong>JSON Stream of BL602 Simulation Events</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-simulator.png" alt="BL602 Simulator Design" /></p>
<p><em>What‚Äôs a BL602 Simulation Event?</em></p>
<p>When uLisp needs to <strong>set the GPIO Output</strong> to High or Low (to flip an LED On/Off)‚Ä¶</p>
<pre><code class="language-text">( digitalwrite 11 :high )
</code></pre>
<p>It sends a <strong>Simulation Event</strong> to the BL602 Simulator (in JSON format)‚Ä¶</p>
<pre><code class="language-json">{ &quot;gpio_output_set&quot;: { 
  &quot;pin&quot;: 11, 
  &quot;value&quot;: 1 
} }
</code></pre>
<p>Which is handled by the BL602 Simulator to <strong>flip the Simulated LED</strong> on or off.</p>
<p>(Yes the blue LED we‚Äôve seen earlier)</p>
<p><em>Is uLisp directly controlling the BL602 Simulator?</em></p>
<p>Not quite. uLisp is <strong>indirectly controlling the BL602 Simulator</strong> by sending Simulation Events.</p>
<p>(There are good reasons for doing this <a href="https://en.wikipedia.org/wiki/Inversion_of_control"><strong>Inversion of Control</strong></a>, as well shall learn in a while)</p>
<p><em>What about time delays like <code>( delay 1000 )</code>?</em></p>
<p>uLisp generates <strong>Simulation Events for time delays</strong>. To handle such events, our BL602 Simulator pauses for the specified duration.</p>
<p>(It‚Äôs like playing a MIDI Stream)</p>
<p>Hence this uLisp script‚Ä¶</p>
<pre><code class="language-text">( delay 1000 )
</code></pre>
<p>Will generate this Simulation Event‚Ä¶</p>
<pre><code class="language-json">{ &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }
</code></pre>
<p><em>What‚Äôs a JSON Stream of Simulation Events?</em></p>
<p>To simulate a uLisp program on the BL602 Simulator, we shall pass an <strong>array of Simulation Events</strong> (in JSON format) from uLisp to the BL602 Simulator.</p>
<p>This (partial) uLisp program that sets the GPIO Output and waits 1 second‚Ä¶</p>
<pre><code class="language-text">( list
  ( digitalwrite 11 :high )
  ( delay 1000 )
  ...
)
</code></pre>
<p>Will generate this <strong>JSON Stream of Simulation Events</strong>‚Ä¶</p>
<pre><code class="language-json">[ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
  { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }, 
  ... 
]
</code></pre>
<p>That will simulate a blinking BL602 LED (eventually).</p>
<h1 id="add-a-simulation-event" class="section-header"><a href="#add-a-simulation-event">5 Add a Simulation Event</a></h1>
<p>Let‚Äôs watch how uLisp <strong>adds an event</strong> to the JSON Stream of Simulation Events.</p>
<p>We <strong>define a string buffer</strong> for the JSON array of events: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c#L8-L17"><code>wasm.c</code></a></p>
<pre><code class="language-c">/// Buffer for JSON Stream of Simulation Events
static char events[1024] = &quot;[]&quot;;
</code></pre>
<p>To <strong>append a GPIO Output Event</strong> to the buffer, uLisp calls the function <strong><code>bl_gpio_output_set</code></strong> from <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c#L60-L77"><code>wasm.c</code></a></p>
<pre><code class="language-c">/// Add a GPIO event to set output (0 for low, 1 for high)
int bl_gpio_output_set(uint8_t pin, uint8_t value) {
    //  How many chars in the Simulation Events buffer to keep
    int keep = 
        strlen(events)  //  Keep the existing events
        - 1;            //  Skip the trailing &quot;]&quot;

    //  Append the GPIO Output Event to the buffer
    snprintf(
        events + keep,
        sizeof(events) - keep,
        &quot;, { \&quot;gpio_output_set\&quot;: { &quot;
            &quot;\&quot;pin\&quot;: %d, &quot;
            &quot;\&quot;value\&quot;: %d &quot;
        &quot;} } ]&quot;,
        pin,
        value
    );
    return 0; 
}
</code></pre>
<p>This code appends a JSON event to the string buffer, which will look like this‚Ä¶</p>
<pre><code class="language-json">[, { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } } ]
</code></pre>
<p>We‚Äôll fix the leading comma ‚Äú<code>,</code>‚Äù in a while.</p>
<p><img src="https://lupyuen.github.io/images/wasm-add.png" alt="Add an event to the JSON Stream of Simulation Events" /></p>
<p><em>How is <code>bl_gpio_output_set</code> called by uLisp?</em></p>
<p>When we enter this uLisp script to set the GPIO Output‚Ä¶</p>
<pre><code class="language-text">( digitalwrite 11 :high )
</code></pre>
<p>The uLisp Interpreter calls <code>fn_digitalwrite</code> defined in <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c#L3544-L3562"><code>ulisp.c</code></a> ‚Ä¶</p>
<pre><code class="language-c">/// Set the GPIO Output to High or Low
object *fn_digitalwrite (object *args, object *env) {
    //  Omitted: Parse the GPIO pin number and High / Low
    ...
    //  Set the GPIO output (from BL602 GPIO HAL)
    int rc = bl_gpio_output_set(
        pin,  //  GPIO pin number
        mode  //  0 for low, 1 for high
    );
</code></pre>
<p>Which calls our function <code>bl_gpio_output_set</code> to add the GPIO Output Event.</p>
<p><em>Will this work when running on real BL602 hardware?</em></p>
<p>Yep it does! <code>bl_gpio_output_set</code> is a real function defined in the <strong>BL602 IoT SDK</strong> for setting the GPIO Output.</p>
<p>Thus <code>fn_digitalwrite</code> (and the rest of uLisp) works fine on <strong>Real BL602 (hardware) and Simulated BL602 (WebAssembly)</strong>.</p>
<h1 id="get-the-simulation-events" class="section-header"><a href="#get-the-simulation-events">6 Get the Simulation Events</a></h1>
<p><em>uLisp (in WebAssembly) has generated the JSON Stream of BL602 Simulation Events. How will our BL602 Simulator (in JavaScript) fetch the Simulation Events?</em></p>
<p>To <strong>fetch the Simulation Events</strong>, we expose a getter function in WebAssembly like so: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c#L24-L32"><code>wasm.c</code></a></p>
<pre><code class="language-c">/// Return the JSON Stream of Simulation Events
const char *get_simulation_events(void) {
  assert(events[0] == '[');
  assert(events[strlen(events) - 1] == ']');

  //  Erase the leading comma: &quot;[,...]&quot; becomes &quot;[ ...]&quot;
  if (events[1] == ',') { events[1] = ' '; }
  return events;
}
</code></pre>
<p><strong><code>get_simulation_events</code></strong> returns the WebAssembly string buffer that contains the Simulation Events (in JSON format).</p>
<p><img src="https://lupyuen.github.io/images/wasm-stream2.png" alt="Clearing and getting Simulation Events" /></p>
<p>Switching over from uLisp WebAssembly to our <strong>BL602 Simulator in JavaScript</strong>‚Ä¶</p>
<p>Remember the <strong><code>runScript</code></strong> function we wrote for our uLisp REPL?</p>
<p>Let‚Äôs rewrite <code>runScript</code> to <strong>fetch the Simulation Events</strong> by calling <code>get_simulation_events</code>. From <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1362-L1407"><code>ulisp.html</code></a> ‚Ä¶</p>
<pre><code class="language-javascript">/// JSON Stream of Simulation Events emitted by uLisp Interpreter. Looks like...
///  [ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
///    { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }, ... ]
let simulation_events = [];

/// Run the script in the input box
function runScript() {
  //  Get the uLisp script 
  //  var scr = &quot;( list 1 2 3 )&quot;;
  const scr = document.getElementById(&quot;input&quot;).value;

  //  Allocate WebAssembly memory for the script
  const scr_ptr = Module.allocate(intArrayFromString(scr), ALLOC_NORMAL);

  //  Catch any errors so that we can free the allocated memory
  try {
    //  Clear the JSON Stream of Simulation Events in WebAssembly
    Module._clear_simulation_events();

    //  Execute the uLisp script in WebAssembly
    Module.print(&quot;\nExecute uLisp: &quot; + scr + &quot;\n&quot;);
    Module._execute_ulisp(scr_ptr);
</code></pre>
<p>This is similar to the earlier version of <code>runScript</code> except‚Ä¶</p>
<ol>
<li>
<p>We now have a static variable <strong><code>simulation_events</code></strong> that will store the Simulation Events</p>
</li>
<li>
<p>We use a <strong><code>try...catch...finally</code></strong> block to deallocate the WebAssembly memory. </p>
<p>(In case we hit errors in the JSON parsing)</p>
</li>
<li>
<p>We call <strong><code>_clear_simulation_events</code></strong> to erase the buffer of Simulation Events (in WebAssembly).</p>
<p>(More about this later)</p>
</li>
</ol>
<p>After calling <code>_execute_ulisp</code> to execute the uLisp Script, we <strong>fetch the generated Simulation Events</strong> by calling <code>_get_simulation_events</code> (which we‚Äôve seen earlier)‚Ä¶</p>
<pre><code class="language-javascript">    //  Get the JSON string of Simulation Events from WebAssembly. Looks like...
    //  [ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
    //    { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }, ... ]
    const json_ptr = Module._get_simulation_events();

    //  Convert the JSON string from WebAssembly to JavaScript
    const json = Module.UTF8ToString(json_ptr);
</code></pre>
<p><code>_get_simulation_events</code> returns a <strong>pointer to a WebAssembly String</strong>.</p>
<p>Here we call <strong><code>UTF8ToString</code></strong> (from Emscripten) to convert the pointer to a <strong>JavaScript String</strong>.</p>
<p>We <strong>parse the returned string</strong> as a JSON array of Simulation Events‚Ä¶</p>
<pre><code class="language-javascript">    //  Parse the JSON Stream of Simulation Events
    simulation_events = JSON.parse(json);
    Module.print(&quot;Events: &quot; + JSON.stringify(simulation_events, null, 2) + &quot;\n&quot;);
</code></pre>
<p>And we store the parsed array of events into the static variable <strong><code>simulation_events</code></strong></p>
<p>In case the JSON Parsing fails, we have a <strong><code>try...catch...finally</code></strong> block to ensure that the WebAssembly memory is properly deallocated‚Ä¶</p>
<pre><code class="language-javascript">  } catch(err) {
    //  Catch and show any errors
    console.error(err);
  } finally {
    //  Free the WebAssembly memory allocated for the script
    Module._free(scr_ptr);
  }
</code></pre>
<p>Now we‚Äôre ready to <strong>run the Simulated BL602 Events</strong> and blink the Simulated BL602 LED!</p>
<pre><code class="language-javascript">  //  Start a timer to simulate the returned events
  if (simulation_events.length &gt; 0) {
    window.setTimeout(&quot;simulateEvents()&quot;, 1);
  }
}
</code></pre>
<p>We call a JavaScript Timer to trigger the function <strong><code>simulateEvents</code></strong>.</p>
<p>This simulates the events in <code>simulation_events</code> (like flipping the Simulated LED), one event at a time.</p>
<p><img src="https://lupyuen.github.io/images/wasm-stream.png" alt="GPIO Simulation Events" /></p>
<p><em>What‚Äôs inside the WebAssembly function <code>clear_simulation_events</code>?</em></p>
<p>Before running a uLisp Script, our BL602 Simulator calls <strong><code>clear_simulation_events</code></strong> to erase the buffer of Simulation Events: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c#L19-L22"><code>wasm.c</code></a></p>
<pre><code class="language-c">/// Clear the JSON Stream of Simulation Events
void clear_simulation_events(void) {
  strcpy(events, &quot;[]&quot;);
}
</code></pre>
<h1 id="flip-the-simulated-led" class="section-header"><a href="#flip-the-simulated-led">7 Flip the Simulated LED</a></h1>
<p><strong><code>simulateEvents</code></strong> is the <strong>Event Loop</strong> for our BL602 Simulator. It calls itself repeatedly to <strong>simulate each event</strong> generated by uLisp.</p>
<p>Here‚Äôs how it works: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1409-L1445"><code>ulisp.html</code></a></p>
<pre><code class="language-javascript">/// Simulate the BL602 Simulation Events recorded in simulate_events, which contains...
///  [ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
///    { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }, ... ]
function simulateEvents() {
  //  Take the first event and update the queue
  if (simulation_events.length == 0) { return; }
  const event = simulation_events.shift();
  //  event looks like:
  //  { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }

  //  Get the event type (gpio_output_set)
  //  and parameters ({ &quot;pin&quot;: 11, &quot;value&quot;: 1 })
  const event_type = Object.keys(event)[0];
  const args = event[event_type];
</code></pre>
<p><strong><code>simulateEvents</code></strong> starts by fetching the <strong>next event to be simulated</strong> (from <code>simulation_events</code>).</p>
<p>It decodes the event into‚Ä¶</p>
<ol>
<li>
<p><strong>Event Type</strong>: Like‚Ä¶</p>
<p><code>gpio_output_set</code></p>
</li>
<li>
<p><strong>Event Parameters</strong>: Like‚Ä¶</p>
<p><code>{ &quot;pin&quot;: 11, &quot;value&quot;: 1 }</code></p>
</li>
</ol>
<p>Next it <strong>handles each Event Type</strong>‚Ä¶</p>
<pre><code class="language-javascript">  //  Timeout in milliseconds to the next event
  let timeout = 1;

  //  Handle each event type
  switch (event_type) {

    //  Set GPIO output
    //  { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }
    case &quot;gpio_output_set&quot;: 
      timeout += gpio_output_set(args.pin, args.value); 
      break;
</code></pre>
<p>If we‚Äôre simulating a GPIO Output Event, we call the function <strong><code>gpio_output_set</code></strong> and pass the Event Parameters (<code>pin</code> and <code>value</code>).</p>
<p>(We‚Äôll talk about <code>gpio_output_set</code> and the timeout in a while)</p>
<pre><code class="language-javascript">    //  Delay
    //  { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }
    case &quot;time_delay&quot;: 
      timeout += time_delay(args.ticks); 
      break;

    //  Unknown event type
    default: 
      throw new Error(&quot;Unknown event type: &quot; + event_type);
  }
</code></pre>
<p>This code simulates time delays, which we‚Äôll see later.</p>
<pre><code class="language-javascript">  //  Simulate the next event
  if (simulation_events.length &gt; 0) {
    window.setTimeout(&quot;simulateEvents()&quot;, timeout);
  }
}
</code></pre>
<p>Finally we <strong>simulate the next event</strong> (from <code>simulation_events</code>), by triggering <code>simulateEvents</code> with a JavaScript Timer.</p>
<p>And that‚Äôs how we simulate every event generated by uLisp!</p>
<p><em>What‚Äôs inside the function <code>gpio_output_set</code>?</em></p>
<p><strong><code>gpio_output_set</code></strong> is called by <code>simulateEvents</code> to simulate a GPIO Output Event: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1447-L1470"><code>ulisp.html</code></a></p>
<pre><code class="language-javascript">/// Simulate setting GPIO pin output to value 0 (Low) or 1 (High):
/// { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }
function gpio_output_set(pin, value) {
  //  Get the HTML Canvas Context
  const ctx = document.getElementById('canvas').getContext('2d');
</code></pre>
<p>First we fetch the <strong>HTML Canvas and its Context</strong>.</p>
<p>Then we <strong>set the Fill Colour</strong> to Blue or Grey, depending on GPIO Output Value‚Ä¶</p>
<pre><code class="language-javascript">  //  Set the simulated LED colour depending on value
  switch (value) {
    //  Set GPIO to Low (LED on)
    case 0: ctx.fillStyle = '#B0B0FF'; break;  //  Blue

    //  Set GPIO to High (LED off)
    case 1: ctx.fillStyle = '#CCCCCC'; break;  //  Grey

    //  Unknown value
    default: throw new Error(&quot;Unknown gpio_output_set value: &quot; + args.value);
  }
</code></pre>
<p>(Yes we‚Äôve seen this code earlier)</p>
<p>Finally we <strong>draw the Simulated LED</strong> with the Fill Colour (Blue or Grey)‚Ä¶</p>
<pre><code class="language-javascript">  //  Draw the LED colour
  ctx.fillRect(315, 116, 35, 74);

  //  Simulate next event in 0 milliseconds
  return 0;
}
</code></pre>
<p>Here‚Äôs what we see in the BL602 Simulator when we set the <strong>GPIO Output to Low</strong> (LED on)‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
( <span class="ident">digitalwrite</span> <span class="number">11</span> :<span class="ident">low</span> )</pre></div>
<ul>
<li>
<p><a href="https://youtu.be/KpvqCmFtPgc"><strong>Watch the demo on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/ulisp-bl602/ulisp.html"><strong>Try it here</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/wasm-led.png" alt="Flip the simulated LED" /></p>
<h1 id="simulate-delays" class="section-header"><a href="#simulate-delays">8 Simulate Delays</a></h1>
<p><em>Now our BL602 Simulator flips the Simulated LED on and off. We‚Äôre ready to blink the Simulated LED right?</em></p>
<p>Not quite. We need to <strong>simulate Time Delays</strong> too!</p>
<p><em>Can‚Äôt we implement Time Delays by sleeping inside uLisp?</em></p>
<p>Not really. From what we‚Äôve seen, uLisp <strong>doesn‚Äôt run our script in real time</strong>.</p>
<p>uLisp merely generates a bunch of Simulation Events. The events need to be <strong>simulated in the correct time sequence</strong> by our BL602 Simulator.</p>
<p>Hence we also need to <strong>simulate Time Delays</strong> with a Simulation Event.</p>
<p><em>How does uLisp generate a Simulation Event for Time Delay?</em></p>
<p>When we run this uLisp Script‚Ä¶</p>
<pre><code class="language-text">( delay 1000 )
</code></pre>
<p>Our uLisp Intepreter in WebAssembly <strong>generates a Time Delay Event</strong> like so: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c#L79-L93"><code>wasm.c</code></a></p>
<pre><code class="language-c">/// Add a delay event. 1 tick is 1 millisecond
void time_delay(uint32_t ticks) { 
  //  How many chars in the Simulation Events buffer to keep
  int keep = 
    strlen(events)  //  Keep the existing events
    - 1;            //  Skip the trailing &quot;]&quot;

  //  Append the Time Delay Event to the buffer
  snprintf(
    events + keep,
    sizeof(events) - keep,
    &quot;, { \&quot;time_delay\&quot;: { &quot;
      &quot;\&quot;ticks\&quot;: %d &quot;
    &quot;} } ]&quot;,
    ticks
  );
}
</code></pre>
<p>This code adds a <strong>Time Delay Event</strong> that looks like‚Ä¶</p>
<pre><code class="language-text">{ &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }
</code></pre>
<p>(We define <strong>1 tick as 1 millisecond</strong>, so this event sleeps for 1 second)</p>
<p><em>How does our BL602 Simulator handle a Time Delay Event in JavaScript?</em></p>
<p>Earlier we‚Äôve seen <strong><code>simulateEvents</code></strong>, the Event Loop for our BL602 Simulator: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1409-L1445"><code>ulisp.html</code></a></p>
<pre><code class="language-javascript">function simulateEvents() {
  //  Take the first event
  const event = simulation_events.shift();
  ...
  //  Get the event type and parameters
  const event_type = Object.keys(event)[0];
  const args = event[event_type];
  ...
  //  Handle each event type
  switch (event_type) {
    ...
    //  Delay
    //  { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }
    case &quot;time_delay&quot;: 
      timeout += time_delay(args.ticks); 
      break;
</code></pre>
<p><code>simulateEvents</code> handles the Time Delay Event by calling <strong><code>time_delay</code></strong> with the number of ticks (milliseconds) to delay: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1472-L1477"><code>ulisp.html</code></a></p>
<pre><code class="language-javascript">/// Simulate a delay for the specified number of ticks (1 tick = 1 millisecond)
/// { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }
function time_delay(ticks) {
  //  Simulate the next event in &quot;ticks&quot; milliseconds
  return ticks;
}
</code></pre>
<p><strong><code>time_delay</code></strong> doesn‚Äôt do much‚Ä¶ It returns the <strong>number of ticks (milliseconds) to delay</strong>.</p>
<p>The magic actually happens in the calling function <code>simulateEvents</code>. From <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1409-L1445"><code>ulisp.html</code></a> ‚Ä¶</p>
<pre><code class="language-javascript">function simulateEvents() {
  ...
  //  Get the delay in ticks / milliseconds
  timeout += time_delay(args.ticks);
  ...
  //  Simulate the next event
  if (simulation_events.length &gt; 0) {
    //  Timer expires in timeout milliseconds
    window.setTimeout(&quot;simulateEvents()&quot;, timeout);
  }
}
</code></pre>
<p><code>simulateEvents</code> takes the returned value (number of ticks to wait) and <strong>sets the timeout of the JavaScript Timer</strong>.</p>
<p>(When the timer expires, it calls <code>simulateEvents</code> to handle the next Simulation Event)</p>
<p>Let‚Äôs watch <strong>Time Delay Events</strong> in action! Guess what happens when we run this uLisp Script with our BL602 Simulator‚Ä¶</p>
<pre><code class="language-text">( list
  ( digitalwrite 11 :low )
  ( delay 1000 )
  ( digitalwrite 11 :high )
  ( delay 1000 )
)
</code></pre>
<ul>
<li>
<p><a href="https://youtu.be/piRLuBYSjTw"><strong>Watch the demo on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/ulisp-bl602/ulisp.html"><strong>Try it here</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/wasm-delay.png" alt="Simulating delays" /></p>
<h1 id="simulate-loops" class="section-header"><a href="#simulate-loops">9 Simulate Loops</a></h1>
<p>Let‚Äôs ponder this uLisp Script that <strong>blinks the LED in a loop</strong>‚Ä¶</p>
<pre><code class="language-text">( loop
  ( digitalwrite 11 :low )
  ( delay 1000 )
  ( digitalwrite 11 :high )
  ( delay 1000 )
)
</code></pre>
<p><em>Wait a minute‚Ä¶ Won‚Äôt this uLisp Script generate an Infinite Stream of Simulation Events? And overflow our 1024-byte event buffer?</em></p>
<p>Righto! We <strong>can‚Äôt allow uLisp Loops and Recursion to run forever</strong> in our simulator. We must stop them! (Eventually)</p>
<p>We <strong>stop runaway Loops and Recursion</strong> here: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c#L34-L46"><code>wasm.c</code></a></p>
<pre><code class="language-c">/// Preempt the uLisp task and allow background tasks to run.
/// Called by eval() and sp_loop() in src/ulisp.c
void yield_ulisp(void) {
  //  If uLisp is running a loop or recursion,
  //  the Simulation Events buffer may overflow.
  //  We stop before the buffer overflows.
  if (strlen(events) + 100 &gt;= sizeof(events)) {  //  Assume 100 bytes of leeway

    //  Cancel the loop or recursion by jumping to loop_ulisp() in src/ulisp.c
    puts(&quot;Too many iterations, stopping the loop&quot;);
    extern jmp_buf exception;  //  Defined in src/ulisp.c
    longjmp(exception, 1);
  }
}
</code></pre>
<p>uLisp calls <strong><code>yield_ulisp</code></strong> when it <strong>iterates through a loop</strong> or evaluates a recursive expression.</p>
<p>If <code>yield_ulisp</code> detects that the <strong>buffer for Simulation Events is about to overflow</strong>, it stops the uLisp Loop / Recursion by jumping out (<code>longjmp</code>) and reporting an exception.</p>
<p>(Which will return a <strong>truncated stream of Simulation Events</strong> to the BL602 Simulator)</p>
<p><em>Looks kinda simplistic?</em></p>
<p>Yes this solution might not work for some kinds of uLisp Loops and Recursion. But it‚Äôs sufficient to <strong>simulate a blinking LED</strong> (for a short while).</p>
<p><em>How does uLisp call <code>yield_ulisp</code>?</em></p>
<p>uLisp calls <code>yield_ulisp</code> when <strong>iterating through a loop</strong> in <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c#L1698-L1702"><code>ulisp.c</code></a> ‚Ä¶</p>
<pre><code class="language-c">///  Execute uLisp Loop
object *sp_loop (object *args, object *env) {
  ...
  for (;;) {
    //  Preempt the uLisp task and allow background tasks to run
    yield_ulisp();
</code></pre>
<p>And when it <strong>evaluates a (potentially) recursive expression</strong>: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/src/ulisp.c#L4658-L4664"><code>ulisp.c</code></a></p>
<pre><code class="language-c">///  Main uLisp Evaluator
object *eval (object *form, object *env) {
  ...
  // Preempt the uLisp task and allow background tasks to run
  yield_ulisp();
</code></pre>
<p><em>So now we‚Äôre all set to run this uLisp loop?</em></p>
<pre><code class="language-text">( loop
  ( digitalwrite 11 :low )
  ( delay 1000 )
  ( digitalwrite 11 :high )
  ( delay 1000 )
)
</code></pre>
<p>Yes! Here‚Äôs our BL602 Simulator running the <strong>LED Blinky Loop</strong>. Watch how the <strong>Simulated LED stops blinking</strong> after a while‚Ä¶</p>
<ul>
<li>
<p><a href="https://youtu.be/IUmVa3vNpRs"><strong>Watch the demo on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/ulisp-bl602/ulisp.html"><strong>Try it here</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/wasm-loop.png" alt="Simulating loops" /></p>
<h1 id="add-simulator-to-blockly" class="section-header"><a href="#add-simulator-to-blockly">10 Add Simulator to Blockly</a></h1>
<p>Today we‚Äôve created two things that run in a Web Browser‚Ä¶</p>
<ol>
<li>
<p><strong>uLisp REPL</strong> (based on WebAssembly)</p>
</li>
<li>
<p><strong>BL602 Simulator</strong> (based on JavaScript)</p>
</li>
</ol>
<p><em>Can we drag-and-drop Blockly Programs in a Web Browser‚Ä¶ And run them with uLisp REPL and BL602 Simulator?</em></p>
<p><img src="https://lupyuen.github.io/images/wasm-blockly.png" alt="Blockly Web Editor for uLisp WebAssembly and BL602 Simulator" /></p>
<p>Yes we can! Just do this‚Ä¶</p>
<ol>
<li>
<p>Click this link to run the <strong>Blockly Web Editor for uLisp WebAssembly and BL602 Simulator</strong>‚Ä¶</p>
<ul>
<li><a href="https://appkaki.github.io/blockly-ulisp/demos/simulator/"><strong><code>blockly-ulisp</code> Web Editor and Simulator</strong></a></li>
</ul>
<p>(This website contains HTML, JavaScript and WebAssembly, no server-side code. We‚Äôll explain <a href="https://github.com/AppKaki/blockly-ulisp"><code>blockly-ulisp</code></a> in a while)</p>
</li>
<li>
<p>Drag-and-drop this Blockly Program‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-edit3.png" alt="Blockly Web Editor: Blinky" /></p>
<p>By snapping these blocks together‚Ä¶</p>
<ul>
<li>
<p><strong><code>forever</code></strong> from <strong><code>Loops</code></strong> (in the left bar)</p>
</li>
<li>
<p><strong><code>digital write</code></strong> from <strong><code>GPIO</code></strong> (in the left bar)</p>
</li>
<li>
<p><strong><code>wait</code></strong> from <strong><code>Loops</code></strong> (in the left bar)</p>
</li>
</ul>
<p>Make sure they fit snugly. (Not floaty)</p>
<p><a href="https://youtu.be/LNkmUIv7ZZc">(Stuck? Check the video)</a></p>
</li>
<li>
<p>Set the parameters for the blocks as shown above‚Ä¶</p>
<ul>
<li>
<p><strong><code>digital write</code></strong>: Set the output to <strong><code>HIGH</code></strong> for the first block, <strong><code>LOW</code></strong> for the second block</p>
</li>
<li>
<p><strong><code>wait</code></strong>: Wait 1 second for both blocks</p>
</li>
</ul>
</li>
<li>
<p>Click the <strong><code>Lisp</code></strong> tab at the top.</p>
<p>We should see this <strong>uLisp code generated by Blockly</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-edit4.png" alt="Blockly Web Editor: uLisp code for Blinky" /></p>
</li>
<li>
<p>Click the <strong>Run Button [ ‚ñ∂ ]</strong> at top right.</p>
<p>The <strong>Simulated LED blinks every second!</strong></p>
<p>(And stops after a while, because we don‚Äôt simulate infinite loops)</p>
<p><a href="https://youtu.be/Ag2CERd1OzQ"><strong>Watch the demo on YouTube</strong></a></p>
</li>
</ol>
<p><em>Yes indeed we can drag-and-drop Blockly Programs‚Ä¶ And run them with the uLisp REPL and BL602 Simulator!</em></p>
<p>Read on to find out how we connected Blockly to uLisp REPL (in WebAssembly) and BL602 Simulator (in JavaScript).</p>
<p><img src="https://lupyuen.github.io/images/wasm-title.png" alt="BL602 Simulator with uLisp and Blockly in WebAssembly" /></p>
<h1 id="simulate-blockly-programs" class="section-header"><a href="#simulate-blockly-programs">11 Simulate Blockly Programs</a></h1>
<p><strong>Adding the BL602 Simulator to Blockly</strong> (from the previous article) was surprisingly painless.</p>
<p>Here‚Äôs what we did‚Ä¶</p>
<ol>
<li>
<p>We <strong>create a Blockly folder</strong> for our new web page (based on the Blockly folder from the previous article)‚Ä¶</p>
<p>Copy the folder <a href="https://github.com/AppKaki/blockly-ulisp/tree/wasm/demos/code"><code>demos/code</code></a> to <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator"><code>demos/simulator</code></a></p>
</li>
<li>
<p>We <strong>copy the WebAssembly files</strong> to the Blockly folder‚Ä¶</p>
<p>Copy <code>ulisp.js</code> and <code>ulisp.wasm</code> from <a href="https://github.com/lupyuen/ulisp-bl602/tree/wasm/docs"><code>ulisp-bl602/docs</code></a> to <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator"><code>demos/simulator</code></a></p>
</li>
<li>
<p>Insert the <strong>HTML Canvas and the Output Box</strong> (for the uLisp log): <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator/index.html#L110-L120"><code>index.html</code></a></p>
<pre><code class="language-html">&lt;!-- Canvas for Simulator --&gt;
&lt;tr&gt;
  &lt;td colspan=2 align=&quot;center&quot;&gt;
    &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;
    &lt;textarea id=&quot;output&quot; style=&quot;width: 300px; height: 300px;&quot;&gt;&lt;/textarea&gt;
    &lt;div class=&quot;spinner&quot; id='spinner'&gt;&lt;/div&gt;
    &lt;div class=&quot;emscripten&quot; id=&quot;status&quot;&gt;&lt;/div&gt;    
    &lt;progress value=&quot;0&quot; max=&quot;100&quot; id=&quot;progress&quot; hidden=1&gt;&lt;/progress&gt;
  &lt;/td&gt;
&lt;/tr&gt;
&lt;!-- End --&gt;
</code></pre>
<p>(<code>spinner</code>, <code>status</code> and <code>progress</code> are needed by the Emscripten JavaScript)</p>
</li>
<li>
<p>Copy the <strong>Emscripten JavaScript</strong> from <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1250-L1326"><code>ulisp.html</code></a> to <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator/index.html#L482-L562"><code>index.html</code></a></p>
<pre><code class="language-html">&lt;!--  Emscripten Script: From ulisp.html  --&gt;
&lt;script type='text/javascript'&gt;
  var statusElement   = ...
  var progressElement = ...
  var spinnerElement  = ...

  var Module = {
    preRun:  [],
    postRun: [],
    print:     ... ,
    printErr:  ... ,
    canvas:    ... ,
    setStatus: ... ,
    monitorRunDependencies: ...
  };
  Module.setStatus( ... );
  window.onerror = ...
&lt;/script&gt;
&lt;!--  End of Emscripten Script  --&gt;
</code></pre>
</li>
<li>
<p>Copy the <strong>BL602 Simulator JavaScript</strong> from <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/ulisp.html#L1328-L1480"><code>ulisp.html</code></a> to <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator/index.html#L564-L716"><code>index.html</code></a></p>
<pre><code class="language-html">&lt;!--  Custom Script: TODO Sync with ulisp.html  --&gt;
&lt;script type=&quot;text/javascript&quot;&gt;

  /// JSON Stream of Simulation Events emitted by uLisp Interpreter
  let simulation_events = [];

  /// Wait for emscripten to be initialised
  Module.onRuntimeInitialized = ...

  /// Render the simulator pic
  function renderSimulator() { ... }

  /// Run the provided script
  function runScript(scr) { /* See changes below */ }

  /// Simulate the BL602 Simulation Events recorded in simulate_events
  function simulateEvents() { ... }

  /// Simulate setting GPIO pin output to value 0 (Low) or 1 (High)
  function gpio_output_set(pin, value) { ... }

  /// Simulate a delay for the specified number of ticks
  function time_delay(ticks) { ... }

&lt;/script&gt;    
&lt;!--  End of Custom Script  --&gt;
</code></pre>
</li>
<li>
<p>Modify the <code>runScript</code> function above‚Ä¶</p>
<pre><code class="language-javascript">/// Run the uLisp script from Input Box
function runScript() {
  //  Get the uLisp script from Input Box
  const scr = document.getElementById(&quot;input&quot;).value;

  //  Allocate WebAssembly memory for the script
  const scr_ptr = Module.allocate(intArrayFromString(scr), ALLOC_NORMAL);
</code></pre>
<p>So that it runs the <strong>script from the provided parameter</strong> (instead of the REPL Input Box): <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator/index.html#L598-L643"><code>index.html</code></a></p>
<pre><code class="language-javascript">/// Run the provided uLisp script
function runScript(scr) {
  //  Allocate WebAssembly memory for the script
  const scr_ptr = Module.allocate(intArrayFromString(scr), ALLOC_NORMAL);
</code></pre>
</li>
<li>
<p>Load our <strong>Emscripten WebAssembly</strong> into Blockly: <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator/index.html#L718-L722"><code>index.html</code></a></p>
<pre><code class="language-html">&lt;!--  Load Emscripten WebAssembly: From ulisp.html  --&gt;
&lt;script async type=&quot;text/javascript&quot; src=&quot;ulisp.js&quot;&gt;&lt;/script&gt;
&lt;!--  End of Emscripten WebAssembly  --&gt;
</code></pre>
</li>
<li>
<p>Previously we ran the uLisp code on a real BL602 with the Web Serial API.</p>
<p>Now we <strong>run the uLisp code on BL602 Simulator</strong>: <a href="https://github.com/AppKaki/blockly-ulisp/blob/wasm/demos/simulator/code.js#L575-L582"><code>code.js</code></a></p>
<pre><code class="language-javascript">///  Run the uLisp code on BL602 Simulator
Code.runJS = function() {
  //  Generate the uLisp code by calling the Blockly Code Generator for uLisp
  var code = Blockly.Lisp.workspaceToCode(Code.workspace);

  //  Run the uLisp code on BL602 Simulator
  runScript(code);   //  Defined in index.html
}    
</code></pre>
</li>
</ol>
<p>And that‚Äôs how we <strong>added uLisp WebAssembly and BL602 Simulator to Blockly</strong>‚Ä¶</p>
<p><em>Dragging-and-dropping uLisp programs for microcontrollers‚Ä¶ And running them WITHOUT a microcontroller!</em></p>
<h1 id="can-we-simulate-any-bl602-firmware" class="section-header"><a href="#can-we-simulate-any-bl602-firmware">12 Can We Simulate Any BL602 Firmware?</a></h1>
<p><em>Our BL602 Simulator works OK for simulating a uLisp Program. Will it work for simulating BL602 Firmware coded in C?</em></p>
<p>Our BL602 Simulator <strong>might work for BL602 Firmware coded in C</strong>! </p>
<p>Let‚Äôs look at this <strong>BL602 Blinky Firmware</strong> in C: <a href="https://lupyuen.github.io/articles/rust#bl602-blinky-in-c"><code>sdk_app_blinky/demo.c</code></a></p>
<pre><code class="language-c">/// Blink the BL602 LED
void blinky(char *buf, int len, int argc, char **argv) {
  //  Configure the LED GPIO for output (instead of input)
  int rc = bl_gpio_enable_output(
    LED_GPIO,  //  GPIO pin number (11)
    0,         //  No GPIO pullup
    0          //  No GPIO pulldown
  );
  assert(rc == 0);  //  Halt on error

  //  Blink the LED 5 times
  for (int i = 0; i &lt; 10; i++) {

    //  Toggle the LED GPIO between 0 (on) and 1 (off)
    rc = bl_gpio_output_set(  //  Set the GPIO output (from BL602 GPIO HAL)
      LED_GPIO,               //  GPIO pin number (11)
      i % 2                   //  0 for low, 1 for high
    );
    assert(rc == 0);  //  Halt on error

    //  Sleep 1 second
    time_delay(                 //  Sleep by number of ticks (from NimBLE Porting Layer)
      time_ms_to_ticks32(1000)  //  Convert 1,000 milliseconds to ticks (from NimBLE Porting Layer)
    );
  }
}
</code></pre>
<p>To get this C code running on our BL602 Simulator, we need to <strong>compile the code to WebAssembly</strong>.</p>
<p><em>Will this C code compile to WebAssembly?</em></p>
<p>Remember earlier we created these <strong>C Functions for our WebAssembly Interface</strong>‚Ä¶</p>
<pre><code class="language-c">/// Add a GPIO event to set output (0 for low, 1 for high)
int bl_gpio_output_set(uint8_t pin, uint8_t value) { ... }

/// Configure the GPIO pin for output
int bl_gpio_enable_output(uint8_t pin, uint8_t pullup, uint8_t pulldown) { return 0; }

/// Add a delay event. 1 tick is 1 millisecond
void time_delay(uint32_t ticks) { ... }

/// Convert milliseconds to ticks
uint32_t time_ms_to_ticks32(uint32_t millisec) { return millisec; }
</code></pre>
<p>These <strong>C Function Signatures are 100% identical</strong> to the BL602 Functions from the BL602 IoT SDK: <code>bl_gpio_output_set</code>, <code>bl_gpio_enable_output</code>, ‚Ä¶</p>
<p>So yep, the above <strong>BL602 Firmware Code will compile to WebAssembly</strong>!</p>
<p>Similar to a uLisp Program, the BL602 Firmware Code (running in WebAssebly) will generate a <strong>JSON Stream of Simulation Events</strong>. </p>
<p>(Which we‚Äôll feed to our <strong>BL602 Simulator</strong> in JavaScript)</p>
<p><em>But can we simulate ALL functions from the BL602 IoT SDK: GPIO, I2C, SPI, ADC, DAC, LVGL, LoRa, ‚Ä¶?</em></p>
<p>This needs work of course. </p>
<p>To simulate any uLisp Program or BL602 Firmware we need to <strong>code the necessary Simulation Functions in JavaScript</strong> (like <code>gpio_output_set</code> and <code>time_delay</code>) for GPIO, I2C, SPI, ADC, DAC, LVGL, LoRa, ‚Ä¶</p>
<p>(Sounds like an interesting challenge!)</p>
<h1 id="why-simulate-a-stream-of-events" class="section-header"><a href="#why-simulate-a-stream-of-events">13 Why Simulate A Stream Of Events?</a></h1>
<p>TODO</p>
<p>Inversion of control</p>
<p>Loose coupling</p>
<p>Time compression</p>
<p>Time reversal</p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">14 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Porting uLisp and Blockly to BL602 has been a fun experience.</p>
<p>But more work needs to be done, I hope the Community can help.</p>
<p>Could this be the better way to learn Embedded Programming on modern microcontrollers?</p>
<p>Let‚Äôs build it and find out! üôè üëç üòÄ</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/wasm.md"><code>lupyuen.github.io/src/wasm.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">15 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1393554618924212224">this Twitter Thread</a></li>
</ol>
<p><img src="https://lupyuen.github.io/images/wasm-error.png" alt="" /></p>
<p><img src="https://lupyuen.github.io/images/wasm-string.png" alt="Passing simulation events from WebAssembly to WebAssembly" /></p>

    
</body>
</html>