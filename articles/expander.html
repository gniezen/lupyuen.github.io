<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>NuttX GPIO Expander for PineDio Stack BL604</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="NuttX GPIO Expander for PineDio Stack BL604" 
    data-rh="true">
<meta property="og:description" 
    content="PineDio Stack BL604 RISC-V Board has an interesting problem on Apache NuttX RTOS... Too many GPIOs! Let's fix this with a GPIO Expander"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/expander-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">NuttX GPIO Expander for PineDio Stack BL604</h1>
    <nav id="TOC"><ul>
<li><a href="#bl602-evb-limitations">1 BL602 EVB Limitations</a><ul>
<li><a href="#pin-definitions">1.1 Pin Definitions</a><ul></ul></li></ul></li>
<li><a href="#overcome-the-limitations">2 Overcome The Limitations</a><ul></ul></li>
<li><a href="#gpio-expander">3 GPIO Expander</a><ul>
<li><a href="#gpio-operations">3.1 GPIO Operations</a><ul></ul></li></ul></li>
<li><a href="#gpio-interrupt">4 GPIO Interrupt</a><ul>
<li><a href="#bl602-evb-interrupt">4.1 BL602 EVB Interrupt</a><ul></ul></li>
<li><a href="#attach-interrupt-handler">4.2 Attach Interrupt Handler</a><ul></ul></li>
<li><a href="#gpio-command">4.3 GPIO Command</a><ul></ul></li>
<li><a href="#other-callers">4.4 Other Callers</a><ul></ul></li></ul></li>
<li><a href="#load-gpio-expander">5 Load GPIO Expander</a><ul></ul></li>
<li><a href="#validate-gpio">6 Validate GPIO</a><ul>
<li><a href="#pin-functions">6.1 Pin Functions</a><ul></ul></li></ul></li>
<li><a href="#test-gpio-expander">7 Test GPIO Expander</a><ul>
<li><a href="#test-touch-panel">7.1 Test Touch Panel</a><ul></ul></li>
<li><a href="#test-push-button">7.2 Test Push Button</a><ul></ul></li>
<li><a href="#test-lorawan">7.3 Test LoRaWAN</a><ul></ul></li></ul></li>
<li><a href="#whats-next">8 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">9 Notes</a><ul></ul></li>
<li><a href="#appendix-validate-pin-function">10 Appendix: Validate Pin Function</a><ul>
<li><a href="#validate-at-compile-time">10.1 Validate at Compile-Time</a><ul></ul></li>
<li><a href="#validate-at-startup">10.2 Validate at Startup</a><ul></ul></li></ul></li>
<li><a href="#appendix-initialise-gpio-expander">11 Appendix: Initialise GPIO Expander</a><ul></ul></li>
<li><a href="#appendix-set-gpio-direction">12 Appendix: Set GPIO Direction</a><ul></ul></li>
<li><a href="#appendix-set-gpio-option">13 Appendix: Set GPIO Option</a><ul></ul></li>
<li><a href="#appendix-write-gpio">14 Appendix: Write GPIO</a><ul></ul></li>
<li><a href="#appendix-read-gpio">15 Appendix: Read GPIO</a><ul></ul></li>
<li><a href="#appendix-attach-gpio-interrupt">16 Appendix: Attach GPIO Interrupt</a><ul></ul></li>
<li><a href="#appendix-detach-gpio-interrupt">17 Appendix: Detach GPIO Interrupt</a><ul></ul></li>
<li><a href="#appendix-handle-gpio-interrupt">18 Appendix: Handle GPIO Interrupt</a><ul></ul></li>
<li><a href="#appendix-gpio-interrupt">19 Appendix: GPIO Interrupt</a><ul>
<li><a href="#attach-interrupt-handler-1">19.1 Attach Interrupt Handler</a><ul></ul></li>
<li><a href="#enable-gpio-interrupt">19.2 Enable GPIO Interrupt</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>5 May 2022</em></p>
<p><img src="https://lupyuen.github.io/images/expander-title.jpg" alt="NuttX GPIO Expander for PineDio Stack BL604" /></p>
<p><a href="https://lupyuen.github.io/articles/pinedio2"><strong>PineDio Stack BL604</strong></a> (Pine64‚Äôs newest RISC-V board) has an interesting problem on <a href="https://lupyuen.github.io/articles/nuttx"><strong>Apache NuttX RTOS</strong></a>‚Ä¶</p>
<p><em><strong>Too Many GPIOs!</strong></em></p>
<p>Let‚Äôs fix this with a <strong>GPIO Expander</strong>.</p>
<p><em>Why too many GPIOs?</em></p>
<p>All <strong>23 GPIOs</strong> on PineDio Stack BL604 are wired up‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/pinedio2#appendix-gpio-assignment"><strong>‚ÄúPineDio Stack GPIO Assignment‚Äù</strong></a></li>
</ul>
<p>And we need easy access to all GPIOs as our devs create <strong>NuttX Drivers and Apps</strong> for PineDio Stack.</p>
<p>(See pic below)</p>
<p><em>NuttX can‚Äôt handle 23 GPIOs?</em></p>
<p>Well it gets messy. Without GPIO Expander, BL604 on NuttX supports one <strong>GPIO Input</strong>, one <strong>GPIO Output</strong> and one <strong>GPIO Interrupt</strong>.</p>
<p>And they are <strong>named sequentially</strong> (Input first, then Output, then Interrupt)‚Ä¶</p>
<ul>
<li>
<p><strong>/dev/gpio0</strong>: GPIO Input</p>
</li>
<li>
<p><strong>/dev/gpio1</strong>: GPIO Output</p>
</li>
<li>
<p><strong>/dev/gpio2</strong>: GPIO Interrupt</p>
</li>
</ul>
<p>(See pic above)</p>
<p><em>This looks OK?</em></p>
<p>Until we realise that they map to <strong>totally different GPIO Pins</strong> on PineDio Stack!</p>
<div><table><thead><tr><th>GPIO Device</th><th style="text-align: center">BL604 GPIO Pin</th><th>Function</th></tr></thead><tbody>
<tr><td><strong>/dev/gpio0</strong></td><td style="text-align: center">GPIO Pin <strong><code>10</code></strong></td><td>SX1262 Busy</td></tr>
<tr><td><strong>/dev/gpio1</strong></td><td style="text-align: center">GPIO Pin <strong><code>15</code></strong></td><td>SX1262 Chip Select</td></tr>
<tr><td><strong>/dev/gpio2</strong></td><td style="text-align: center">GPIO Pin <strong><code>19</code></strong></td><td>SX1262 Interrupt</td></tr>
</tbody></table>
</div>
<p>Extend this to <strong>23 GPIOs</strong> and we have a mapping disaster!</p>
<p>Let‚Äôs simplify this setup and map GPIO Pins 0 to 22 as ‚Äú<strong>/dev/gpio0</strong>‚Äù to ‚Äú<strong>/dev/gpio22</strong>‚Äù. We‚Äôll do this with a <strong>GPIO Expander</strong>.</p>
<p>(See pic above)</p>
<p><em>What‚Äôs a GPIO Expander?</em></p>
<p>NuttX lets us create <strong>I/O Expander Drivers</strong> that will manage many GPIOs‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/incubator-nuttx/blob/master/include/nuttx/ioexpander/ioexpander.h"><strong>NuttX I/O Expander Driver Interface</strong></a></li>
</ul>
<p>Well BL604 looks like a <strong>Big Bag o‚Äô GPIOs</strong>. Why not create a <strong>GPIO Expander</strong> that will manage all 23 GPIOs?</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602_expander"><strong>BL602 / BL604 GPIO Expander</strong></a></li>
</ul>
<p>(Other microcontrollers might also need a GPIO Expander‚Ä¶ Like <a href="https://github.com/openwch/ch32v307"><strong>CH32V307</strong></a>, which has 80 GPIOs!)</p>
<p><em>So we‚Äôre just renumbering GPIOs?</em></p>
<p>Above and beyond that, our BL604 GPIO Expander serves other functions‚Ä¶</p>
<ul>
<li>
<p>Attach and detach <strong>GPIO Interrupt Handlers</strong></p>
</li>
<li>
<p><strong>Validate GPIO Pin Numbers</strong> at startup</p>
</li>
<li>
<p>But skip the GPIOs reserved for <strong>UART, I2C and SPI</strong></p>
<p>(That‚Äôs why we have GPIO gaps in the pic above)</p>
</li>
</ul>
<p>Let‚Äôs dive in!</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/expander-pinedio1a.png" alt="All 23 GPIOs on PineDio Stack BL604 are wired up" /></p>
</blockquote>
<blockquote>
<p><a href="https://lupyuen.github.io/articles/pinedio2#appendix-gpio-assignment">(Source)</a></p>
</blockquote>
<h1 id="bl602-evb-limitations"><a href="#bl602-evb-limitations">1 BL602 EVB Limitations</a></h1>
<p><em>What‚Äôs this BL602 EVB?</em></p>
<p>In NuttX, <strong>BL602 EVB</strong> (‚ÄúEvaluation Board‚Äù) provides the <strong>Board-Specific Functions</strong> for PineDio Stack and other BL602 / BL604 boards‚Ä¶</p>
<ul>
<li><strong>NuttX BL602 EVB:</strong> <a href="https://github.com/lupyuen/incubator-nuttx/tree/pinedio/boards/risc-v/bl602/bl602evb/src"><strong>boards/risc-v/bl602/bl602evb</strong></a></li>
</ul>
<p><em>What‚Äôs inside BL602 EVB?</em></p>
<p>The important parts of BL602 EVB are‚Ä¶</p>
<ul>
<li>
<p><strong>Pin Definitions:</strong> <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h"><strong>board.h</strong></a></p>
<p>Defines the pins for the GPIO, UART, I2C, SPI and PWM ports.</p>
</li>
<li>
<p><strong>Bring-Up:</strong> <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c"><strong>bl602_bringup.c</strong></a></p>
<p>Starts the NuttX Drivers and the GPIO / UART / I2C / SPI / PWM ports.</p>
</li>
<li>
<p><strong>EVB GPIO Driver:</strong> <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c"><strong>bl602_gpio.c</strong></a></p>
<p>Implements the GPIO Input, Output and Interrupt ports.</p>
<p>Calls the <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c"><strong>BL602 GPIO Driver</strong></a>.</p>
</li>
</ul>
<p>In a while we‚Äôll study the <strong>limitations of BL602 EVB</strong>, to understand why we created the BL602 GPIO Expander.</p>
<p><em>Wait‚Ä¶ Where‚Äôs the rest of the BL602 stuff?</em></p>
<p>The <strong>Architecture-Specific Functions</strong> for BL602 and BL604 are located at‚Ä¶</p>
<ul>
<li><strong>NuttX BL602:</strong> <a href="https://github.com/lupyuen/incubator-nuttx/tree/pinedio/arch/risc-v/src/bl602"><strong>arch/risc-v/src/bl602</strong></a></li>
</ul>
<p>This includes the low-level drivers for GPIO, UART, I2C, SPI, PWM, ‚Ä¶</p>
<p>We‚Äôre hunky dory with these drivers, though we‚Äôve made tiny mods like for <a href="https://lupyuen.github.io/articles/pinedio2#spi-device-table"><strong>SPI Device Table</strong></a>.</p>
<p><img src="https://lupyuen.github.io/images/expander-title1a.png" alt="BL602 EVB always maps sequentially the GPIO Pins" /></p>
<h2 id="pin-definitions"><a href="#pin-definitions">1.1 Pin Definitions</a></h2>
<p>In BL602 EVB, this is how we <strong>define the pins</strong> for GPIO / UART / I2C / SPI / PWM: <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L38-L59">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define BOARD_NGPIOIN  1  //  Number of GPIO Input pins
#define BOARD_NGPIOOUT 1  //  Number of GPIO Output pins
#define BOARD_NGPIOINT 1  //  Number of GPIO Interrupt pins

//  GPIO Input: GPIO 10
#define BOARD_GPIO_IN1  (GPIO_PIN10 | GPIO_INPUT | GPIO_FLOAT | GPIO_FUNC_SWGPIO)

//  GPIO Output: GPIO 15
#define BOARD_GPIO_OUT1 (GPIO_PIN15 | GPIO_OUTPUT | GPIO_PULLUP | GPIO_FUNC_SWGPIO)

//  GPIO Interrupt: GPIO 19
#define BOARD_GPIO_INT1 (GPIO_PIN19 | GPIO_INPUT | GPIO_FLOAT | GPIO_FUNC_SWGPIO)</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L61-L145">(See the UART / I2C / SPI / PWM Pins)</a></p>
<p>A couple of issues‚Ä¶</p>
<ul>
<li>
<p>BL602 EVB strangely limits us to <strong>one GPIO Input, one GPIO Output and one GPIO Interrupt</strong></p>
</li>
<li>
<p>We could extend this GPIO Limit, but we‚Äôll have to <strong>modify the EVB GPIO Driver</strong>, which sounds odd</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L106-L137">(See this)</a></p>
</li>
<li>
<p>BL602 EVB always <strong>maps sequentially</strong> the GPIO Pins like so: GPIO Input, then GPIO Output, then GPIO Interrupt (pic above)‚Ä¶</p>
<p><strong>/dev/gpio0</strong>: GPIO Input <em>(GPIO 10)</em></p>
<p><strong>/dev/gpio1</strong>: GPIO Output <em>(GPIO 15)</em></p>
<p><strong>/dev/gpio2</strong>: GPIO Interrupt <em>(GPIO 19)</em></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L550-L604">(See this)</a></p>
</li>
<li>
<p>Which becomes super confusing when we <strong>map all 23 GPIOs</strong> on PineDio Stack.</p>
<p>(Especially when our new devs are now creating NuttX Drivers and Apps for PineDio Stack)</p>
</li>
<li>
<p>What happens if we <strong>reuse the GPIOs</strong> by mistake? BL602 EVB will silently allow this. Which ain‚Äôt right!</p>
<div class="example-wrap"><pre class="language-c"><code>//  GPIO Input: GPIO 10
#define BOARD_GPIO_IN1  (GPIO_PIN10 | GPIO_INPUT | GPIO_FLOAT | GPIO_FUNC_SWGPIO)

//  GPIO Output: Also GPIO 10 (Oops!)
#define BOARD_GPIO_OUT1 (GPIO_PIN10 | GPIO_OUTPUT | GPIO_PULLUP | GPIO_FUNC_SWGPIO)</code></pre></div></li>
</ul>
<p>Thus we see that <strong>BL602 EVB is somewhat limited</strong>‚Ä¶</p>
<p>BL602 EVB works great for 3 GPIOs, but <strong>doesn‚Äôt scale well</strong> beyond that.</p>
<p>Let‚Äôs make this better.</p>
<p><em>Shouldn‚Äôt the pins be defined in Kconfig / menuconfig?</em></p>
<p>Perhaps. NuttX on ESP32 defines the pins in <strong>Kconfig and menuconfig.</strong> <a href="https://github.com/apache/incubator-nuttx/blob/master/arch/xtensa/src/esp32/Kconfig#L938-L984">(See this)</a></p>
<p>But for now, let‚Äôs keep the Pin Definitions in <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L38-L59"><strong>board.h</strong></a>.</p>
<p><img src="https://lupyuen.github.io/images/expander-title2a.jpg" alt="Overcome The Limitations" /></p>
<h1 id="overcome-the-limitations"><a href="#overcome-the-limitations">2 Overcome The Limitations</a></h1>
<p>We plan to make BL602 EVB <strong>work great with PineDio Stack</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>Support 23 GPIOs</strong> with any mix of GPIO Inputs / Outputs / Interrupts</p>
<p>(Perfect for PineDio Stack‚Äôs SPI Display, I2C Touch Panel, SX1262 Transceiver, Accelerometer, Push Button, ‚Ä¶)</p>
</li>
<li>
<p>Renumber the GPIOs as ‚Äú<strong>/dev/gpio0</strong>‚Äù to ‚Äú<strong>/dev/gpio22</strong>‚Äù</p>
<p>(‚Äú<strong>/dev/gpioN</strong>‚Äù will simply map to <strong>GPIO Pin N</strong>)</p>
</li>
<li>
<p>Allow <strong>gaps in the GPIO Numbering</strong> (pic above)</p>
<p>(We skip the GPIOs reserved for UART, I2C, SPI and PWM)</p>
</li>
<li>
<p>Keep the <strong>Pin Definitions</strong></p>
<p>(Original BL602 EVB will still build OK for plain old BL602)</p>
</li>
<li>
<p><strong>Validate the GPIOs</strong> at startup</p>
<p>(No more reusing GPIOs by mistake!)</p>
</li>
</ul>
<p>We make this happen by extending BL602 EVB with an (optional) <strong>GPIO Expander</strong>.</p>
<p><em>Why not make an EVB for PineDio Stack?</em></p>
<p>Yes we could create a new <strong>EVB for PineDio Stack</strong>.</p>
<p>(And do away with BL602 EVB altogether)</p>
<p>But we‚Äôll save that for later because it might lead to <strong>fragmentation of BL602 / BL604 Support</strong> in NuttX.</p>
<p>(Let‚Äôs do the <strong>bare minimum</strong> that will make NuttX decently usable on PineDio Stack!)</p>
<p><img src="https://lupyuen.github.io/images/expander-code1a.png" alt="NuttX I/O Expander Driver Interface" /></p>
<h1 id="gpio-expander"><a href="#gpio-expander">3 GPIO Expander</a></h1>
<p><em>So our GPIO Expander works like a NuttX I/O Expander?</em></p>
<p>Yep, NuttX lets us create <strong>I/O Expander Drivers</strong> that will manage many Input, Output and Interrupt GPIOs‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/incubator-nuttx/blob/master/include/nuttx/ioexpander/ioexpander.h"><strong>NuttX I/O Expander Driver Interface</strong></a></li>
</ul>
<p>I/O Expanders will support reading and writing to GPIOs, also attaching and detaching Interrupt Handlers. (Pic above)</p>
<p><em>Isn‚Äôt an I/O Expander Driver supposed to be Platform-Independent?</em></p>
<p>Yeah, we‚Äôre borrowing (misappropriating?) this NuttX Abstraction
because it meets our needs for PineDio Stack.</p>
<p>Other RISC-V microcontrollers might also need a GPIO Expander‚Ä¶ Like <a href="https://github.com/openwch/ch32v307"><strong>CH32V307</strong></a>, which has 80 GPIOs!</p>
<p><em>Great! How will we get started on GPIO Expander?</em></p>
<p>NuttX helpfully provides a <strong>Skeleton Driver</strong> for I/O Expander (pic below)‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/incubator-nuttx/blob/master/drivers/ioexpander/skeleton.c"><strong>Skeleton Driver for I/O Expander</strong></a></li>
</ul>
<p>Let‚Äôs flesh out the Skeleton Driver for our GPIO Expander.</p>
<p><img src="https://lupyuen.github.io/images/expander-code4a.png" alt="Skeleton Driver for I/O Expander" /></p>
<h2 id="gpio-operations"><a href="#gpio-operations">3.1 GPIO Operations</a></h2>
<p>Our GPIO Expander supports these <strong>GPIO Operations</strong>‚Ä¶</p>
<ul>
<li>
<p>Set <strong>GPIO Direction</strong></p>
<p>(Input or Output)</p>
</li>
<li>
<p>Set <strong>GPIO Interrupt Options</strong></p>
<p>(Trigger by Rising or Falling Edge)</p>
</li>
<li>
<p>Read a <strong>GPIO Input</strong></p>
</li>
<li>
<p>Write to a <strong>GPIO Output</strong></p>
</li>
<li>
<p>Attach / Detach a <strong>GPIO Interrupt Handler</strong></p>
</li>
</ul>
<p>We define the GPIO Operations like so: <a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L141-L159">bl602_expander.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  GPIO Expander Operations
static const struct ioexpander_ops_s g_bl602_expander_ops = {
  bl602_expander_direction,  //  Set GPIO Direction
  bl602_expander_option,     //  Set GPIO Interrupt Options
  bl602_expander_writepin,   //  Write to GPIO Output
  bl602_expander_readpin,    //  Read from GPIO Input
  bl602_expander_readbuf,    //  (Read Buffer Not Implemented)
  ...
  bl602_expander_attach,     //  Attach GPIO Interrupt Handler
  bl602_expander_detach      //  Detach GPIO Interrupt Handler
};</code></pre></div>
<p>The <strong>implementation of the GPIO Operations</strong> is explained in the Appendix‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-initialise-gpio-expander"><strong>‚ÄúInitialise GPIO Expander‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-set-gpio-direction"><strong>‚ÄúSet GPIO Direction‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-set-gpio-option"><strong>‚ÄúSet GPIO Option‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-write-gpio"><strong>‚ÄúWrite GPIO‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-read-gpio"><strong>‚ÄúRead GPIO‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-attach-gpio-interrupt"><strong>‚ÄúAttach GPIO Interrupt‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-detach-gpio-interrupt"><strong>‚ÄúDetach GPIO Interrupt‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-handle-gpio-interrupt"><strong>‚ÄúHandle GPIO Interrupt‚Äù</strong></a></p>
</li>
</ul>
<p><em>Existing NuttX Drivers call <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L218-L230"><strong>bl602_gpioread</strong></a> and <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L197-L216"><strong>bl602_gpiowrite</strong></a> to read and write BL602 GPIOs. Will they still work?</em></p>
<p>Yep the <strong>BL602 GPIO Functions</strong> like <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L218-L230"><strong>bl602_gpioread</strong></a> and <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L197-L216"><strong>bl602_gpiowrite</strong></a> will work fine with GPIO Expander.</p>
<p>The <strong>NuttX GPIO Functions</strong> like <code>open()</code> and <code>ioctl()</code> will also work with GPIO Expander.</p>
<p>(That‚Äôs because they call the <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/drivers/ioexpander/gpio_lower_half.c"><strong>GPIO Lower Half Driver</strong></a>, which is integrated with our GPIO Expander)</p>
<p>Let‚Äôs look at GPIO Interrupts, which are more complicated‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/expander-code5a.png" alt="GPIO Operations" /></p>
<h1 id="gpio-interrupt"><a href="#gpio-interrupt">4 GPIO Interrupt</a></h1>
<p><em>BL602 EVB works OK with GPIO Interrupts?</em></p>
<p>As noted (eloquently) by Robert Lipe, it‚Äôs <strong>difficult to attach a GPIO Interrupt Handler</strong> with BL602 EVB‚Ä¶</p>
<ul>
<li><a href="https://www.robertlipe.com/buttons-on-bl602-nuttx/"><strong>‚ÄúButtons on BL602 NuttX‚Äù</strong></a></li>
</ul>
<blockquote>
<p><img src="https://lupyuen.github.io/images/expander-button.png" alt="As noted (eloquently) by Robert Lipe, attaching a BL602 GPIO Interrupt Handler is hard (because our stars are misaligned)" /></p>
</blockquote>
<blockquote>
<p><a href="https://www.robertlipe.com/buttons-on-bl602-nuttx/">(Source)</a></p>
</blockquote>
<p>Let‚Äôs find out why‚Ä¶</p>
<p>(Perhaps our stars were misaligned üòÇ)</p>
<h2 id="bl602-evb-interrupt"><a href="#bl602-evb-interrupt">4.1 BL602 EVB Interrupt</a></h2>
<p><em>Anything peculiar about GPIO Interrupts on BL602 and BL604?</em></p>
<p><strong>GPIO Interrupt Handling</strong> gets tricky for BL602 and BL604‚Ä¶</p>
<p>All GPIO Interrupts are multiplexed into <strong>One Single GPIO IRQ!</strong></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L477-L505">(<strong>BL602_IRQ_GPIO_INT0</strong> is the common GPIO IRQ)</a></p>
<p>BL602 EVB <strong>demultiplexes the GPIO IRQ</strong> and calls the GPIO Interrupt Handlers.</p>
<p><img src="https://lupyuen.github.io/images/expander-code2a.png" alt="Attaching a GPIO Interrupt with BL602 EVB" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L477-L505">(Source)</a></p>
<p><em>So we call BL602 EVB to attach our own GPIO Interrupt Handler?</em></p>
<p>Sadly we can‚Äôt. BL602 EVB <strong>doesn‚Äôt expose a Public Function</strong> that we may call to attach our Interrupt Handler.</p>
<p>(<strong>gpint_attach</strong> is a Private Function, as shown above)</p>
<p>We could call <a href="https://lupyuen.github.io/articles/sx1262#handle-dio1-interrupt"><strong><code>ioctl()</code></strong></a>, but that would be extremely awkward in the Kernel Space.</p>
<p><em>Which means we need to implement this in our GPIO Expander?</em></p>
<p>Exactly! Our <strong>GPIO Expander</strong> shall take over these duties from BL602 EVB‚Ä¶</p>
<ul>
<li>
<p>Handle the <strong>GPIO IRQ Interrupt</strong></p>
</li>
<li>
<p><strong>Demultiplex</strong> the IRQ</p>
</li>
<li>
<p>Call the right <strong>GPIO Interrupt Handler</strong></p>
</li>
</ul>
<p>More about the implementation in a moment. Let‚Äôs talk about calling the GPIO Expander‚Ä¶</p>
<h2 id="attach-interrupt-handler"><a href="#attach-interrupt-handler">4.2 Attach Interrupt Handler</a></h2>
<p><em>How do we attach a GPIO Interrupt Handler?</em></p>
<p>Because GPIO Expander implements the I/O Expander Interface, we may call <strong>IOEP_ATTACH</strong> to attach an Interrupt Handler.</p>
<p>Let‚Äôs attach an Interrupt Handler that will be called when we press the <strong>Push Button</strong> (GPIO 12) on PineDio Stack: <a href="https://github.com/lupyuen/incubator-nuttx/blob/2982b3a99057c5935ca9150b9f0f1da3565c6061/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L696-L704">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#include &lt;nuttx/ioexpander/gpio.h&gt;
#include &lt;nuttx/ioexpander/bl602_expander.h&gt;
...
//  Get the Push Button Pinset and GPIO Pin Number
gpio_pinset_t pinset = BOARD_BUTTON_INT;
uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L143-L145">(<strong>BOARD_BUTTON_INT</strong> is defined in board.h)</a></p>
<p>First we get the <strong>GPIO Pin Number</strong> for the Push Button.</p>
<p>Then we configure our GPIO Expander to trigger the GPIO Interrupt on the <strong>Falling Edge</strong> (High to Low)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Configure GPIO interrupt to be triggered on falling edge
DEBUGASSERT(bl602_expander != NULL);
IOEXP_SETOPTION(
  bl602_expander,  //  BL602 GPIO Expander
  gpio_pin,        //  GPIO Pin
  IOEXPANDER_OPTION_INTCFG,            //  Configure interrupt trigger
  (FAR void *) IOEXPANDER_VAL_FALLING  //  Trigger on falling edge
);</code></pre></div>
<p>Finally we call GPIO Expander to <strong>attach our Interrupt Handler</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Attach our GPIO interrupt handler
void *handle = IOEP_ATTACH(
  bl602_expander,                //  BL602 GPIO Expander
  (ioe_pinset_t) 1 &lt;&lt; gpio_pin,  //  GPIO Pin converted to Pinset
  button_isr_handler,            //  GPIO Interrupt Handler
  NULL                           //  TODO: Set the callback argument
);
DEBUGASSERT(handle != NULL);</code></pre></div>
<p>The <strong>Interrupt Handler</strong> is defined as‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Our GPIO Interrupt Handler
static int button_isr_handler(FAR struct ioexpander_dev_s *dev, ioe_pinset_t pinset, FAR void *arg) {
  gpioinfo(&quot;Button Pressed\n&quot;);
  return 0;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/2982b3a99057c5935ca9150b9f0f1da3565c6061/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L1038-L1044">(Source)</a></p>
<p>Note that the Interrupt Handler runs in the <strong>BL602 Interrupt Context</strong>.</p>
<p>Be careful!</p>
<h2 id="gpio-command"><a href="#gpio-command">4.3 GPIO Command</a></h2>
<p>Another way to test the Push Button Interrupt is to use the <strong>GPIO Command</strong>. </p>
<p>(This only works if we don‚Äôt call <strong>IOEP_ATTACH</strong> to attach the Interrupt Handler)</p>
<p>Enter this in the NuttX Shell‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>gpio -t 8 -w 1 /dev/gpio12</code></pre></div>
<p>Which says‚Ä¶</p>
<ul>
<li>
<p>Configure the GPIO for <strong>Rising Edge Interrupt</strong></p>
</li>
<li>
<p>And wait 5 seconds for <strong>Signal 1</strong></p>
</li>
</ul>
<p>Quickly press the <strong>Push Button</strong> on PineDio Stack. We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Interrupt pin: Value=1
Verify:        Value=1</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander#test-push-button">(See the Complete Log)</a></p>
<p>If we don‚Äôt press the button <strong>within 5 seconds</strong>, the GPIO Command reports an Interrupt Timeout‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Interrupt pin: Value=1
[Five second timeout with no signal]</code></pre></div><h2 id="other-callers"><a href="#other-callers">4.4 Other Callers</a></h2>
<p><em>Who else is calling GPIO Expander to handle interrupts?</em></p>
<p>The <strong>CST816S Driver</strong> for PineDio Stack‚Äôs Touch Panel calls GPIO Expander to attach an Interrupt Handler (that‚Äôs called when the screen is touched)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/touch#initialise-driver"><strong>‚ÄúInitialise CST816S Driver‚Äù</strong></a></li>
</ul>
<p>The <strong>Semtech SX1262 LoRa Transceiver</strong> on PineDio Stack triggers a GPIO Interrupt (on pin DIO1) when a LoRa packet is transmitted or received‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/sx1262#handle-dio1-interrupt"><strong>‚ÄúHandle DIO1 Interrupt‚Äù</strong></a></li>
</ul>
<p>This code calls <strong><code>ioctl()</code></strong> in the User Space (instead of Kernel Space), so it works OK with GPIO Expander without modification.</p>
<p>(That‚Äôs because <strong><code>ioctl()</code></strong> calls the <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/drivers/ioexpander/gpio_lower_half.c"><strong>GPIO Lower Half Driver</strong></a>, which is integrated with our GPIO Expander)</p>
<h1 id="load-gpio-expander"><a href="#load-gpio-expander">5 Load GPIO Expander</a></h1>
<p>Here‚Äôs how we <strong>load our GPIO Expander</strong> at startup: <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L742-L768">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_IOEXPANDER_BL602_EXPANDER
#include &lt;nuttx/ioexpander/gpio.h&gt;
#include &lt;nuttx/ioexpander/bl602_expander.h&gt;

//  Global Instance of GPIO Expander
FAR struct ioexpander_dev_s *bl602_expander = NULL;
#endif  //  CONFIG_IOEXPANDER_BL602_EXPANDER
...
int bl602_bringup(void) {
  ...
//  Existing Code
#if defined(CONFIG_DEV_GPIO) &amp;&amp; !defined(CONFIG_GPIO_LOWER_HALF)
  ret = bl602_gpio_initialize();
  if (ret &lt; 0) {
    syslog(LOG_ERR, &quot;Failed to initialize GPIO Driver: %d\n&quot;, ret);
    return ret;
  }
#endif

//  New Code
#ifdef CONFIG_IOEXPANDER_BL602_EXPANDER
  //  Must load BL602 GPIO Expander before other drivers
  bl602_expander = bl602_expander_initialize(
    bl602_gpio_inputs,     sizeof(bl602_gpio_inputs) / sizeof(bl602_gpio_inputs[0]),
    bl602_gpio_outputs,    sizeof(bl602_gpio_outputs) / sizeof(bl602_gpio_outputs[0]),
    bl602_gpio_interrupts, sizeof(bl602_gpio_interrupts) / sizeof(bl602_gpio_interrupts[0]),
    bl602_other_pins,      sizeof(bl602_other_pins) / sizeof(bl602_other_pins[0]));
  if (bl602_expander == NULL) {
    syslog(LOG_ERR, &quot;Failed to initialize GPIO Expander\n&quot;);
    return -ENOMEM;
  }
#endif  //  CONFIG_IOEXPANDER_BL602_EXPANDER</code></pre></div>
<p>(We‚Äôll talk about <strong>bl602_gpio_*</strong> in the next chapter)</p>
<p>We must load the GPIO Expander <strong>before other drivers</strong> (like CST816S Touch Panel), because GPIO Expander provides GPIO functions for the drivers.</p>
<p>We need to <strong>disable the BL602 EVB GPIO Driver</strong>, because GPIO Expander needs the <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/drivers/ioexpander/gpio_lower_half.c"><strong>GPIO Lower Half Driver</strong></a> (which can‚Äôt coexist with BL602 EVB GPIO)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Added CONFIG_GPIO_LOWER_HALF below
#if defined(CONFIG_DEV_GPIO) &amp;&amp; !defined(CONFIG_GPIO_LOWER_HALF)
  ret = bl602_gpio_initialize();</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L646-L653">(Source)</a></p>
<p>Check the following in menuconfig‚Ä¶</p>
<ul>
<li>
<p>Enable ‚Äú<strong>BL602 GPIO Expander</strong>‚Äù under ‚ÄúDevice Drivers ‚Üí IO Expander/GPIO Support ‚Üí Enable IO Expander Support‚Äù</p>
</li>
<li>
<p>Set ‚Äú<strong>Number Of Pins</strong>‚Äù to 23</p>
</li>
<li>
<p>Enable ‚Äú<strong>GPIO Lower Half</strong>‚Äù</p>
</li>
</ul>
<p><a href="https://github.com/lupyuen/bl602_expander#install-driver">(Full instrunctions are here)</a></p>
<p><img src="https://lupyuen.github.io/images/expander-code3a.png" alt="Tracking all 23 GPIOs used by PineDio Stack can get challenging" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L61-L145">(Source)</a></p>
<h1 id="validate-gpio"><a href="#validate-gpio">6 Validate GPIO</a></h1>
<p><em>Managing 23 GPIOs sounds mighty challenging?</em></p>
<p>Indeed! Tracking all 23 GPIOs used by PineDio Stack can get challenging‚Ä¶ We might <strong>reuse the GPIOs</strong> by mistake!</p>
<p>Thankfully our GPIO Expander can help: It <strong>validates the GPIOs</strong> at startup.</p>
<p>Here are the <strong>GPIOs currently defined</strong> for PineDio Stack (more to come)‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L61-L145">boards/risc-v/bl602/bl602evb/include/board.h</a></li>
</ul>
<p>At startup, GPIO Expander verifies that the GPIO, UART, I2C, SPI and PWM Ports <strong>don‚Äôt reuse the same GPIO</strong>.</p>
<p>If a GPIO is reused like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  SPI CLK: GPIO 11
#define BOARD_SPI_CLK    (GPIO_PIN11 | GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI)
...
//  Push Button Interrupt: Also GPIO 11 (Oops!) 
#define BOARD_BUTTON_INT (GPIO_PIN11 | GPIO_INPUT | GPIO_FLOAT | GPIO_FUNC_SWGPIO)</code></pre></div>
<p>Then GPIO Expander will <strong>halt with an error</strong> at startup‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_expander_initialize: ERROR:
GPIO pin 11 is already in use</code></pre></div>
<p><em>Awesome! How do we enable this GPIO Validation?</em></p>
<p>To enable GPIO Validation, we <strong>add all GPIOs</strong> to the arrays <strong>bl602_gpio_inputs</strong>, <strong>bl602_gpio_outputs</strong>, <strong>bl602_gpio_interrupts</strong> and <strong>bl602_other_pins</strong>: <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L126-L222">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_IOEXPANDER_BL602_EXPANDER
//  GPIO Input Pins for BL602 GPIO Expander
static const gpio_pinset_t bl602_gpio_inputs[] =
{
#ifdef BOARD_SX1262_BUSY
  BOARD_SX1262_BUSY,
#endif  //  BOARD_SX1262_BUSY
//  Omitted: Other GPIO Input Pins
...
};

//  GPIO Output Pins for BL602 GPIO Expander
static const gpio_pinset_t bl602_gpio_outputs[] =
{
#ifdef BOARD_LCD_CS
  BOARD_LCD_CS,
#endif  //  BOARD_LCD_CS
//  Omitted: Other GPIO Output Pins
...
};

//  GPIO Interrupt Pins for BL602 GPIO Expander
static const gpio_pinset_t bl602_gpio_interrupts[] =
{
#ifdef BOARD_TOUCH_INT
  BOARD_TOUCH_INT,
#endif  //  BOARD_TOUCH_INT
//  Omitted: Other GPIO Interrupt Pins
...
};

//  Other Pins for BL602 GPIO Expander (For Validation Only)
static const gpio_pinset_t bl602_other_pins[] =
{
#ifdef BOARD_UART_0_RX_PIN
  BOARD_UART_0_RX_PIN,
#endif  //  BOARD_UART_0_RX_PIN
//  Omitted: Other UART, I2C, SPI and PWM Pins
...
};
#endif  //  CONFIG_IOEXPANDER_BL602_EXPANDER</code></pre></div>
<p>At startup, we <strong>pass the pins to GPIO Expander</strong> during initialisation‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Initialise GPIO Expander at startup
bl602_expander = bl602_expander_initialize(
  bl602_gpio_inputs,     sizeof(bl602_gpio_inputs) / sizeof(bl602_gpio_inputs[0]),
  bl602_gpio_outputs,    sizeof(bl602_gpio_outputs) / sizeof(bl602_gpio_outputs[0]),
  bl602_gpio_interrupts, sizeof(bl602_gpio_interrupts) / sizeof(bl602_gpio_interrupts[0]),
  bl602_other_pins,      sizeof(bl602_other_pins) / sizeof(bl602_other_pins[0]));</code></pre></div>
<p>GPIO Expander verifies that the <strong>GPIOs are not reused</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>FAR struct ioexpander_dev_s *bl602_expander_initialize(
  const gpio_pinset_t *gpio_inputs,     uint8_t gpio_input_count,
  const gpio_pinset_t *gpio_outputs,    uint8_t gpio_output_count,
  const gpio_pinset_t *gpio_interrupts, uint8_t gpio_interrupt_count,
  const gpio_pinset_t *other_pins,      uint8_t other_pin_count) {
  ...
  //  Mark the GPIOs in use
  bool gpio_is_used[CONFIG_IOEXPANDER_NPINS];
  memset(gpio_is_used, 0, sizeof(gpio_is_used));

  //  Validate the GPIO Inputs
  for (i = 0; i &lt; gpio_input_count; i++) {
    //  Get GPIO Pinset and GPIO Pin Number
    gpio_pinset_t pinset = gpio_inputs[i];
    uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;

    //  Check that the GPIO is not in use
    DEBUGASSERT(gpio_pin &lt; CONFIG_IOEXPANDER_NPINS);
    if (gpio_is_used[gpio_pin]) {
      gpioerr(&quot;ERROR: GPIO pin %d is already in use\n&quot;, gpio_pin);
      return NULL;
    }
    gpio_is_used[gpio_pin] = true;
  }

  //  Omitted: Validate the GPIO Outputs, GPIO Interrupts and Other Pins</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L958-L1123">(Source)</a></p>
<p>There‚Äôs something else we might validate at startup: Pin Functions‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/bl602-pins1a.png" alt="Pin Functions" /></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf">(From BL602 Reference Manual)</a></p>
<h2 id="pin-functions"><a href="#pin-functions">6.1 Pin Functions</a></h2>
<p><em>We‚Äôre selecting a GPIO Pin for a UART / I2C / SPI / PWM Port‚Ä¶</em></p>
<p><em>Which pin can we use?</em></p>
<p>The <strong>Pin Functions</strong> for each GPIO Pin are documented here‚Ä¶</p>
<ul>
<li><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf"><strong>‚ÄúBL602 Reference Manual‚Äù</strong></a>, Table 3.1 ‚ÄúPin Description‚Äù (Page 26)</li>
</ul>
<p>In NuttX, we set the <strong>Pin Definitions</strong> at‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L61-L145">boards/risc-v/bl602/bl602evb/include/board.h</a></li>
</ul>
<p><em>Let‚Äôs say we‚Äôre selecting a pin for SPI MISO?</em></p>
<p>According to the pic above, <strong>SPI MISO</strong> must be either GPIO 0, 4, 8, 12, 16 or 20.</p>
<p><a href="https://lupyuen.github.io/articles/spi2#appendix-miso-and-mosi-are-swapped">(<strong>Beware:</strong> MISO and MOSI are swapped)</a></p>
<p>So this <strong>MISO Pin Definition</strong> is OK‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  GPIO 0 for MISO is OK
#define BOARD_SPI_MISO (GPIO_PIN0 | GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI)</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L104">(Source)</a></p>
<p>But this MISO Pin Definition is no-no‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  GPIO 3 for MISO is NOT OK (Oops!)
#define BOARD_SPI_MISO (GPIO_PIN3 | GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI)</code></pre></div>
<p><em>8 possible pins for MISO? Wow that‚Äôs a lot of choices!</em></p>
<p>BL602 / BL604 gives us incredible flexibility in selecting the pins‚Ä¶</p>
<p>But we might <strong>pick the wrong pin</strong> by mistake!</p>
<p>(Looks like an extreme form of STM32‚Äôs Alternate Pin Functions)</p>
<p><em>Is there a way to prevent such mistakes?</em></p>
<p>We have some ideas for <strong>validating the Pin Functions</strong> at compile-time or at startup‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/expander#appendix-validate-pin-function"><strong>‚ÄúValidate Pin Function‚Äù</strong></a></li>
</ul>
<p>But for now, be <strong>very careful when selecting pins</strong>!</p>
<h1 id="test-gpio-expander"><a href="#test-gpio-expander">7 Test GPIO Expander</a></h1>
<p><em>How shall we test our GPIO Expander on PineDio Stack?</em></p>
<p>We‚Äôll test with 3 features that are shipped with PineDio Stack‚Ä¶</p>
<ul>
<li>
<p><strong>CST816S Touch Panel</strong></p>
<p>(Which triggers a GPIO Interrupt when touched)</p>
</li>
<li>
<p><strong>Push Button</strong></p>
<p>(Which also triggers a GPIO Interrupt when pushed)</p>
</li>
<li>
<p><strong>LoRaWAN with Semtech SX1262 Transceiver</strong></p>
<p>(Which uses GPIO Input, Output and Interrupt)</p>
</li>
</ul>
<p>Follow these steps to <strong>build, flash and run</strong> NuttX on PineDio Stack‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#build-nuttx"><strong>‚ÄúBuild NuttX‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#flash-pinedio-stack"><strong>‚ÄúFlash PineDio Stack‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#boot-pinedio-stack"><strong>‚ÄúBoot PineDio Stack‚Äù</strong></a></p>
</li>
</ul>
<p>In the NuttX Shell, enter this command to <strong>list the NuttX Devices</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>ls /dev</code></pre></div>
<p>We should see <strong>more than 3 GPIOs</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/dev:
 gpio10
 gpio12
 gpio14
 gpio15
 gpio19
 gpio20
 gpio21
 gpio3
 gpio9</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander#test-touch-panel">(See the Complete Log)</a></p>
<p>Which means that our <strong>GPIO Expander is active</strong>.</p>
<p>We‚Äôre ready to test GPIO Expander!</p>
<p><img src="https://lupyuen.github.io/images/touch-title.jpg" alt="Touch Panel Calibration for Pine64 PineDio Stack BL604 RISC-V Board" /></p>
<p><a href="https://lupyuen.github.io/articles/touch">(Source)</a></p>
<h2 id="test-touch-panel"><a href="#test-touch-panel">7.1 Test Touch Panel</a></h2>
<p>At startup, we should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>gpio_pin_register: Registering /dev/gpio9
bl602_expander_option: Falling edge: pin=9
bl602_expander_attach: Attach callback for gpio=9
cst816s_register: Driver registered</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander#test-touch-panel">(See the Complete Log)</a></p>
<p>Which says that our NuttX Driver for <a href="https://lupyuen.github.io/articles/touch"><strong>CST816S Touch Panel</strong></a> has called GPIO Expander to configure GPIO 9 for <strong>Falling Edge Trigger</strong>. (High to Low)</p>
<p>And the driver has called GPIO Expander to attach an <strong>Interrupt Handler</strong> for GPIO 9.</p>
<p>In the NuttX Shell, enter this command to start the <a href="https://github.com/lupyuen/lvgltest-nuttx"><strong>LVGL Test App</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>lvgltest</code></pre></div>
<p>When prompted to calibrate the screen, <strong>tap the 4 corners</strong> of the screen. (Pic above)</p>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_expander_interrupt: Interrupt!
bl602_expander_interrupt: Call gpio=9
cst816s_get_touch_data: DOWN: id=0, touch=0, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander#test-touch-panel">(See the Complete Log)</a></p>
<p>Which says that our <strong>Interrupt Handler</strong> for GPIO 9 has been triggered.</p>
<p>GPIO Expander handles the interrupt and <strong>calls the Touch Panel Driver</strong>. (Which fetches the Touch Data later)</p>
<p>Yep GPIO Expander works great with PineDio Stack‚Äôs Touch Panel!</p>
<p><a href="https://lupyuen.github.io/articles/pinedio2#nuttx-apps">(More about the LVGL Test App)</a></p>
<p><a href="https://lupyuen.github.io/articles/touch">(More about the CST816S Touch Panel)</a></p>
<h2 id="test-push-button"><a href="#test-push-button">7.2 Test Push Button</a></h2>
<p>Earlier we spoke about running the <strong>GPIO Command</strong> to test the <strong>Push Button Interrupt</strong> (GPIO 12)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/expander#gpio-command"><strong>‚ÄúGPIO Command‚Äù</strong></a></li>
</ul>
<p>(Assuming that we don‚Äôt call <strong>IOEP_ATTACH</strong> in NuttX)</p>
<p>The GPIO Command starts by calling GPIO Expander to configure GPIO 12 for <strong>Rising Edge Trigger</strong>. (Low to High)</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; gpio -t 8 -w 1 /dev/gpio12
bl602_expander_option: Rising edge: pin=12
bl602_expander_readpin: pin=12, value=1
Interrupt pin: Value=1
bl602_expander_attach: Attach callback for gpio=12</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander#test-push-button">(See the Complete Log)</a></p>
<p>Then it calls GPIO Expander to <strong>read GPIO 12</strong>. And attach an <strong>Interrupt Handler</strong> for GPIO 12.</p>
<p>When we press the Push Button, GPIO Expander <strong>handles the interrupt</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_expander_interrupt: Interrupt!
bl602_expander_interrupt: Call gpio=12</code></pre></div>
<p>And <strong>calls the Interrupt Handler</strong> for GPIO 12.</p>
<p>Finally the GPIO Command calls GPIO Expander to <strong>detach the Interrupt Handler</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_expander_detach: Detach callback for gpio=12
bl602_expander_readpin: pin=12, value=1
Verify: Value=1</code></pre></div>
<p>And read the GPIO Input one last time.</p>
<h2 id="test-lorawan"><a href="#test-lorawan">7.3 Test LoRaWAN</a></h2>
<p><strong>LoRaWAN</strong> is the most thorough test for GPIO Expander. It depends on <strong>3 GPIOs</strong> connected to the Semtech SX1262 LoRa Transceiver‚Ä¶</p>
<ul>
<li>
<p><strong>SX1262 BUSY</strong> at <strong>/dev/gpio10</strong></p>
<p><strong>GPIO Input</strong> that tells us whether SX1262 is busy</p>
<p>(BUSY is High when SX1262 is busy)</p>
</li>
<li>
<p><strong>SX1262 Chip Select</strong> at <strong>/dev/gpio15</strong></p>
<p><strong>GPIO Output</strong> to select or deselect SX1262 on the SPI Bus</p>
<p>(Chip Select is Low when SX1262 is selected)</p>
</li>
<li>
<p><strong>SX1262 DIO1</strong> at <strong>/dev/gpio19</strong></p>
<p><strong>GPIO Interrupt</strong> for SX1262 to signal that a LoRa Packet has been transmitted or received</p>
<p>(DIO1 shifts from Low to High when that happens)</p>
</li>
</ul>
<p>In the NuttX Shell, enter this command to start the <a href="https://github.com/lupyuen/lorawan_test"><strong>LoRaWAN Test App</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>lorawan_test</code></pre></div>
<p>Our LoRaWAN App calls GPIO Expander to attach an <strong>Interrupt Handler</strong> for GPIO 19‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>init_gpio: change DIO1 to Trigger GPIO Interrupt on Rising Edge
##### =========== MLME-Request ============ ######
#####               MLME_JOIN               ######
##### ===================================== ######</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander#test-lorawan">(See the Complete Log)</a></p>
<p>And sends a <strong>Join LoRaWAN Network</strong> request to our LoRaWAN Gateway (ChipStack).</p>
<p>(Which calls GPIO Expander on <strong>GPIO 10</strong> to check if the LoRa Transceiver is busy, and <strong>GPIO 15</strong> to activate the SPI Bus)</p>
<p>After sending the request, the LoRa Transceiver <strong>triggers an interrupt</strong> on GPIO 19‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>DIO1 add event
RadioOnDioIrq
RadioIrqProcess
IRQ_TX_DONE</code></pre></div>
<p>Which is handled by GPIO Expander and our LoRaWAN App.</p>
<p>Eventually our app receives the <strong>Join Network Response</strong> from our LoRaWAN Gateway‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>##### =========== MLME-Confirm ============ ######
STATUS      : OK
##### ===========   JOINED     ============ ######
OTAA
DevAddr     : 014C9548
DATA RATE   : DR_2</code></pre></div>
<p>And sends a <strong>LoRaWAN Data Packet</strong> <em>(‚ÄúHi NuttX‚Äù)</em> to the gateway‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>##### =========== MCPS-Confirm ============ ######
STATUS      : OK
##### =====   UPLINK FRAME        1   ===== ######
CLASS       : A
TX PORT     : 1
TX DATA     : UNCONFIRMED
48 69 20 4E 75 74 74 58 00
DATA RATE   : DR_3
U/L FREQ    : 923400000
TX POWER    : 0
CHANNEL MASK: 0003</code></pre></div>
<p>The data packet appears on our LoRaWAN Gateway.</p>
<p>Congratulations we have successfully tested GPIO Input, Output and Interrupt with GPIO Expander!</p>
<p><a href="https://lupyuen.github.io/articles/lorawan3">(More about the LoRaWAN Test App)</a></p>
<h1 id="whats-next"><a href="#whats-next">8 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>I hope this article has provided everything you need to get started on creating <strong>your own NuttX Drivers and Apps</strong> on PineDio Stack.</p>
<p>Lemme know what you‚Äôre building with PineDio Stack!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/expander.md"><strong><code>lupyuen.github.io/src/expander.md</code></strong></a></p>
<h1 id="notes"><a href="#notes">9 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1518352162966802432"><strong>this Twitter Thread</strong></a></li>
</ol>
<h1 id="appendix-validate-pin-function"><a href="#appendix-validate-pin-function">10 Appendix: Validate Pin Function</a></h1>
<p>In NuttX, we set the <strong>Pin Definitions</strong> at‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L61-L145">boards/risc-v/bl602/bl602evb/include/board.h</a></li>
</ul>
<p>BL602 / BL604 gives us incredible flexibility in <strong>selecting the GPIO Pins</strong> for the UART, I2C, SPI and PWM Ports‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/expander#pin-functions"><strong>‚ÄúPin Functions‚Äù</strong></a></li>
</ul>
<p>(8 possible pins for SPI MISO!)</p>
<p>But we might <strong>pick the wrong pin</strong> by mistake!</p>
<p>For example, this <strong>MISO Pin Definition</strong> is OK‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  GPIO 0 for MISO is OK
#define BOARD_SPI_MISO (GPIO_PIN0 | GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI)</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L104">(Source)</a></p>
<p>But this MISO Pin Definition is no-no‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  GPIO 3 for MISO is NOT OK (Oops!)
#define BOARD_SPI_MISO (GPIO_PIN3 | GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI)</code></pre></div>
<p><em>Is there a way to prevent such mistakes?</em></p>
<p>We have some ideas for <strong>validating the Pin Functions</strong> at compile-time or at startup‚Ä¶</p>
<h2 id="validate-at-compile-time"><a href="#validate-at-compile-time">10.1 Validate at Compile-Time</a></h2>
<p><em>Can we validate the Pin Functions at compile-time?</em></p>
<p>Possibly. We can enumerate <strong>all valid combinations</strong> of Pin Functions and Pin Numbers‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  SPI MISO can be either GPIO 0, 4, 8, 12, 16 or 20
#define SPI_MISO_PIN0  (GPIO_PIN0  | GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI)
#define SPI_MISO_PIN4  (GPIO_PIN4  | GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI)
#define SPI_MISO_PIN8  (GPIO_PIN8  | GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI)
#define SPI_MISO_PIN12 (GPIO_PIN12 | GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI)
#define SPI_MISO_PIN16 (GPIO_PIN16 | GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI)
#define SPI_MISO_PIN20 (GPIO_PIN20 | GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI)</code></pre></div>
<p>And we select the desired combination for each pin‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Select GPIO 0 as MISO
#define BOARD_SPI_MISO SPI_MISO_PIN0</code></pre></div>
<p><em>What happens if we pick the wrong pin?</em></p>
<p>This is disallowed‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Select GPIO 3 as MISO... Not possible!
#define BOARD_SPI_MISO SPI_MISO_PIN3</code></pre></div>
<p>Because <strong>SPI_MISO_PIN3</strong> doesn‚Äôt exist!</p>
<p>But to check whether the <strong>Pin Numbers are unique</strong>, we would still need GPIO Expander to do this at runtime.</p>
<p><em>Shouldn‚Äôt the pins be defined in Kconfig / menuconfig?</em></p>
<p>Perhaps. NuttX on ESP32 uses <strong>Kconfig / menuconfig</strong> to define the pins. <a href="https://github.com/apache/incubator-nuttx/blob/master/arch/xtensa/src/esp32/Kconfig#L938-L984">(See this)</a></p>
<p>Then we would need GPIO Expander to validate the Pin Functions at runtime.</p>
<p><a href="https://mastodon.social/@Ralim/108201458447291513"><strong>@Ralim</strong></a> has an interesting suggestion‚Ä¶</p>
<blockquote>
<p>If each pin can only be used once, could we flip the arrignment matrix and instead have it always have an entry for each pin, which is either a selected value or hi-z by default; then use kconfig rules to prevent collisions ?</p>
</blockquote>
<p>Which begs the question: Shouldn‚Äôt we do the same for NuttX on ESP32? What about other NuttX platforms? ü§î</p>
<h2 id="validate-at-startup"><a href="#validate-at-startup">10.2 Validate at Startup</a></h2>
<p><em>What about validating the pins at startup?</em></p>
<p>During initialisation, GPIO Expander could validate that the UART / I2C / SPI / PWM Pin Functions are correctly assigned to the GPIO Pin Numbers.</p>
<p>So it would verify that SPI MISO (from the Pin Definitions) must be either GPIO 0, 4, 8, 12, 16 or 20.</p>
<p>Any other GPIO Pin for SPI MISO will be disallowed by our GPIO Expander. (And fail at startup)</p>
<p><em>But the Pin Definitions only tell us the Function Group (like SPI), not the specific Pin Function (like MISO)?</em></p>
<p>Yeah we might have to make the Pin Functions position-dependent. So SPI Pins will always be listed in this sequence: CS, MOSI, MISO, then CLK.</p>
<p>Here‚Äôs how <strong>bl602_other_pins</strong> might look in <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L172-L222">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Other Pins for BL602 GPIO Expander (For Validation Only) */

static const gpio_pinset_t bl602_other_pins[] =
{
#ifdef BOARD_UART_0_RX_PIN
  RX_TX
  (
    BOARD_UART_0_RX_PIN,
    BOARD_UART_0_TX_PIN
  ),
#endif  /* BOARD_UART_0_RX_PIN */

#ifdef BOARD_UART_1_RX_PIN
  RX_TX
  (
    BOARD_UART_1_RX_PIN,
    BOARD_UART_1_TX_PIN
  ),
#endif  /* BOARD_UART_1_RX_PIN */

#ifdef BOARD_PWM_CH0_PIN
  CH(
    BOARD_PWM_CH0_PIN
  ),
#endif  /* BOARD_PWM_CH0_PIN */
...
#ifdef BOARD_I2C_SCL
  SCL_SDA
  (
    BOARD_I2C_SCL, 
    BOARD_I2C_SDA 
  ),
#endif  /* BOARD_I2C_SCL */

#ifdef BOARD_SPI_CS
  CS_MOSI_MISO_CLK
  (
    BOARD_SPI_CS, 
    BOARD_SPI_MOSI, 
    BOARD_SPI_MISO, 
    BOARD_SPI_CLK
  ),
#endif  /* BOARD_SPI_CS */
};</code></pre></div>
<p>The macros are simple passthroughs‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define CH(ch)            ch
#define RX_TX(rx, tx)     rx,  tx
#define SCL_SDA(scl, sda) scl, sda
#define CS_MOSI_MISO_CLK(cs, mosi, miso, clk) cs, mosi, miso, clk</code></pre></div>
<p>At startup, GPIO Expander iterates through the pins and discovers that <strong>BOARD_SPI_MISO</strong> is the third pin (MISO) of the SPI Function Group. So it verifies that it‚Äôs either GPIO 0, 4, 8, 12, 16 or 20.</p>
<p>Which is your preferred way to validate the Pin Functions? Lemme know! üôè</p>
<h1 id="appendix-initialise-gpio-expander"><a href="#appendix-initialise-gpio-expander">11 Appendix: Initialise GPIO Expander</a></h1>
<p>At startup, our GPIO Expander does the following initialisation‚Ä¶</p>
<ul>
<li>
<p>Attach the GPIO Expander <strong>Interrupt Handler</strong> to the GPIO IRQ</p>
</li>
<li>
<p>Configure the <strong>GPIO Input / Output / Interrupt Pins</strong> by calling <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L58-L140"><strong>bl602_configgpio</strong></a></p>
</li>
<li>
<p>Register the GPIOs as ‚Äú<strong>/dev/gpioN</strong>‚Äù by calling <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/drivers/ioexpander/gpio_lower_half.c#L370-L443"><strong>gpio_lower_half</strong></a></p>
</li>
<li>
<p>Validate the GPIOs</p>
</li>
</ul>
<p>Here‚Äôs the code: <a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L956-L1121">bl602_expander.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Initialise the BL602 GPIO Expander
FAR struct ioexpander_dev_s *bl602_expander_initialize(
  const gpio_pinset_t *gpio_inputs,     uint8_t gpio_input_count,
  const gpio_pinset_t *gpio_outputs,    uint8_t gpio_output_count,
  const gpio_pinset_t *gpio_interrupts, uint8_t gpio_interrupt_count,
  const gpio_pinset_t *other_pins,      uint8_t other_pin_count)
{
  int i;
  int ret;
  uint8_t pin;
  bool gpio_is_used[CONFIG_IOEXPANDER_NPINS];
  FAR struct bl602_expander_dev_s *priv;

  DEBUGASSERT(gpio_input_count + gpio_output_count + gpio_interrupt_count +
    other_pin_count &lt;= CONFIG_IOEXPANDER_NPINS);

  /* Use the one-and-only I/O Expander driver instance */

  priv = &amp;g_bl602_expander_dev;

  /* Initialize the device state structure */

  priv-&gt;dev.ops = &amp;g_bl602_expander_ops;
  nxsem_init(&amp;priv-&gt;exclsem, 0, 1);</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Disable GPIO interrupts */

  ret = bl602_expander_irq_enable(false);
  if (ret &lt; 0) { return NULL; }

  /* Disable interrupts for all GPIO Pins */

  for (pin = 0; pin &lt; CONFIG_IOEXPANDER_NPINS; pin++)
    {
      bl602_expander_intmask(pin, 1);
    }

  /* Attach the I/O expander interrupt handler and enable interrupts */

  irq_attach(BL602_IRQ_GPIO_INT0, bl602_expander_interrupt, priv);

  ret = bl602_expander_irq_enable(true);
  if (ret &lt; 0) { return NULL; }</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Mark the GPIOs in use */

  memset(gpio_is_used, 0, sizeof(gpio_is_used));

  /* Configure and register the GPIO Inputs */

  for (i = 0; i &lt; gpio_input_count; i++)
    {
      gpio_pinset_t pinset = gpio_inputs[i];
      uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;

      DEBUGASSERT(gpio_pin &lt; CONFIG_IOEXPANDER_NPINS);
      if (gpio_is_used[gpio_pin])
        {
          gpioerr(&quot;ERROR: GPIO pin %d is already in use\n&quot;, gpio_pin);
          return NULL;
        }
      gpio_is_used[gpio_pin] = true;

      ret = bl602_configgpio(pinset);
      DEBUGASSERT(ret == OK);
      gpio_lower_half(&amp;priv-&gt;dev, gpio_pin, GPIO_INPUT_PIN, gpio_pin);
    }</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Configure and register the GPIO Outputs */

  for (i = 0; i &lt; gpio_output_count; i++)
    {
      gpio_pinset_t pinset = gpio_outputs[i];
      uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;

      DEBUGASSERT(gpio_pin &lt; CONFIG_IOEXPANDER_NPINS);
      if (gpio_is_used[gpio_pin])
        {
          gpioerr(&quot;ERROR: GPIO pin %d is already in use\n&quot;, gpio_pin);
          return NULL;
        }
      gpio_is_used[gpio_pin] = true;

      ret = bl602_configgpio(pinset);
      DEBUGASSERT(ret == OK);
      gpio_lower_half(&amp;priv-&gt;dev, gpio_pin, GPIO_OUTPUT_PIN, gpio_pin);
    }</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Configure and register the GPIO Interrupts */

  for (i = 0; i &lt; gpio_interrupt_count; i++)
    {
      gpio_pinset_t pinset = gpio_interrupts[i];
      uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;

      DEBUGASSERT(gpio_pin &lt; CONFIG_IOEXPANDER_NPINS);
      if (gpio_is_used[gpio_pin])
        {
          gpioerr(&quot;ERROR: GPIO pin %d is already in use\n&quot;, gpio_pin);
          return NULL;
        }
      gpio_is_used[gpio_pin] = true;

      ret = bl602_configgpio(pinset);
      DEBUGASSERT(ret == OK);
      gpio_lower_half(&amp;priv-&gt;dev, gpio_pin, GPIO_INTERRUPT_PIN, gpio_pin);
    }</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>  /* Validate the other pins (I2C, SPI, etc) */

  for (i = 0; i &lt; other_pin_count; i++)
    {
      gpio_pinset_t pinset = other_pins[i];
      uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;

      DEBUGASSERT(gpio_pin &lt; CONFIG_IOEXPANDER_NPINS);
      if (gpio_is_used[gpio_pin])
        {
          gpioerr(&quot;ERROR: GPIO pin %d is already in use\n&quot;, gpio_pin);
          return NULL;
        }
      gpio_is_used[gpio_pin] = true;
    }

  /* TODO: Validate the Pin Functions (e.g. MISO vs MOSI) */

  return &amp;priv-&gt;dev;
}</code></pre></div>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L164-L197">(<code>bl602_expander_intmask</code> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L301-L325">(<code>bl602_expander_irq_enable</code> is defined here)</a></p>
<p>TODO7</p>
<p><img src="https://lupyuen.github.io/images/expander-code6a.png" alt="" /></p>
<h1 id="appendix-set-gpio-direction"><a href="#appendix-set-gpio-direction">12 Appendix: Set GPIO Direction</a></h1>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L410-L454">bl602_expander.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/****************************************************************************
 * Name: bl602_expander_direction
 *
 * Description:
 *   Set the direction of an ioexpander pin. Required.
 *
 * Input Parameters:
 *   dev - Device-specific state data
 *   pin - The index of the pin to alter in this call
 *   dir - One of the IOEXPANDER_DIRECTION_ macros
 *
 * Returned Value:
 *   0 on success, else a negative error code
 *
 ****************************************************************************/

static int bl602_expander_direction(FAR struct ioexpander_dev_s *dev, uint8_t pin,
                          int direction)
{
  FAR struct bl602_expander_dev_s *priv = (FAR struct bl602_expander_dev_s *)dev;
  int ret;

  if (direction != IOEXPANDER_DIRECTION_IN &amp;&amp;
      direction != IOEXPANDER_DIRECTION_OUT)
    {
      return -EINVAL;
    }

  gpioinfo(&quot;WARNING: Unimplemented direction: pin=%u, direction=%s\n&quot;,
           pin, (direction == IOEXPANDER_DIRECTION_IN) ? &quot;IN&quot; : &quot;OUT&quot;);
  DEBUGASSERT(priv != NULL &amp;&amp; pin &lt; CONFIG_IOEXPANDER_NPINS);

  /* Get exclusive access to the I/O Expander */

  ret = bl602_expander_lock(priv);
  if (ret &lt; 0)
    {
      return ret;
    }

  /* Unlock the I/O Expander */

  bl602_expander_unlock(priv);
  return ret;
}</code></pre></div><h1 id="appendix-set-gpio-option"><a href="#appendix-set-gpio-option">13 Appendix: Set GPIO Option</a></h1>
<p>TODO</p>
<p>Our GPIO Expander will configure the GPIO Interrupts: Rising Edge Trigger vs Falling Edge Trigger‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Set GPIO Options
static int bl602_expander_option(FAR struct ioexpander_dev_s *dev, uint8_t pin,
                       int opt, FAR void *value)
{
  FAR struct bl602_expander_dev_s *priv = (FAR struct bl602_expander_dev_s *)dev;
  int ret = -ENOSYS;

  gpioinfo(&quot;pin=%u, option=%u, value=%p\n&quot;, pin, opt, value);

  DEBUGASSERT(priv != NULL);

  /* Get exclusive access to the I/O Expander */

  ret = bl602_expander_lock(priv);
  if (ret &lt; 0)
    {
      return ret;
    }

  /* Handle each option */

  switch(opt)
    {
      case IOEXPANDER_OPTION_INTCFG: /* Interrupt Trigger */
        {
          switch((uint32_t)value)
            {
              case IOEXPANDER_VAL_RISING: /* Rising Edge */
                {
                  gpioinfo(&quot;Rising edge: pin=%u\n&quot;, pin);
                  bl602_expander_set_intmod(pin, 1, GLB_GPIO_INT_TRIG_POS_PULSE);
                  break;
                }

              case IOEXPANDER_VAL_FALLING: /* Falling Edge */
                {
                  gpioinfo(&quot;Falling edge: pin=%u\n&quot;, pin);
                  bl602_expander_set_intmod(pin, 1, GLB_GPIO_INT_TRIG_NEG_PULSE);
                  break;
                }

              case IOEXPANDER_VAL_BOTH: /* Both Edge (Unimplemented) */
                {
                  gpioinfo(&quot;WARNING: Unimplemented interrupt both edge: pin=%u\n&quot;, pin);
                  break;
                }

              case IOEXPANDER_VAL_DISABLE: /* Disable (Unimplemented) */
                {
                  gpioinfo(&quot;WARNING: Unimplemented disable interrupt, use detach instead: pin=%u\n&quot;, pin);
                  break;
                }

              default: /* Unsupported Interrupt */
                {
                  gpioerr(&quot;ERROR: Unsupported interrupt: %d, pin=%u\n&quot;, value, pin);
                  ret = -EINVAL;
                  break;
                }
            }
          break;
        }

      default: /* Unsupported Option */
        {
          gpioerr(&quot;ERROR: Unsupported option: %d, pin=%u\n&quot;, opt, pin);
          ret = -ENOSYS;
        }
    }

  /* Unlock the I/O Expander */

  bl602_expander_unlock(priv);
  return ret;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L456-L548">(Source)</a></p>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L198-L246">(<code>bl602_expander_set_intmod</code> is defined here)</a></p>
<p>TODO8</p>
<p><img src="https://lupyuen.github.io/images/expander-code7a.png" alt="" /></p>
<h1 id="appendix-write-gpio"><a href="#appendix-write-gpio">14 Appendix: Write GPIO</a></h1>
<p>TODO</p>
<p>Our GPIO Expander calls the BL602 GPIO Driver to write GPIO Outputs ‚Ä¶ Wonder what happens if we flip between Input and Output ‚Ä¶ Like for PineDio Stack‚Äôs Push Button / Vibrator ü§î</p>
<div class="example-wrap"><pre class="language-c"><code>//  Write to the GPIO Output Pin
static int bl602_expander_writepin(FAR struct ioexpander_dev_s *dev,
                                   uint8_t pin,
                                   bool value)
{
  FAR struct bl602_expander_dev_s *priv = (FAR struct bl602_expander_dev_s *)dev;
  int ret;

  gpioinfo(&quot;pin=%u, value=%u\n&quot;, pin, value);

  DEBUGASSERT(priv != NULL &amp;&amp; pin &lt; CONFIG_IOEXPANDER_NPINS);

  /* Get exclusive access to the I/O Expander */

  ret = bl602_expander_lock(priv);
  if (ret &lt; 0)
    {
      return ret;
    }

  /* Write the pin value. Warning: Pin Number passed as BL602 Pinset */

  bl602_gpiowrite(pin &lt;&lt; GPIO_PIN_SHIFT, value);

  /* Unlock the I/O Expander */

  bl602_expander_unlock(priv);
  return ret;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L550-L594">(Source)</a></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L197-L216">(<code>bl602_gpiowrite</code> comes from the BL602 GPIO Driver)</a></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/expander-code9a.png" alt="" /></p>
<h1 id="appendix-read-gpio"><a href="#appendix-read-gpio">15 Appendix: Read GPIO</a></h1>
<p>TODO</p>
<p>Our GPIO Expander calls the BL602 GPIO Driver to read GPIO Inputs‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Read the GPIO Input Pin
static int bl602_expander_readpin(FAR struct ioexpander_dev_s *dev, 
                                  uint8_t pin,
                                  FAR bool *value)
{
  FAR struct bl602_expander_dev_s *priv = (FAR struct bl602_expander_dev_s *)dev;
  int ret;

  DEBUGASSERT(priv != NULL &amp;&amp; pin &lt; CONFIG_IOEXPANDER_NPINS &amp;&amp;
              value != NULL);

  /* Get exclusive access to the I/O Expander */

  ret = bl602_expander_lock(priv);
  if (ret &lt; 0)
    {
      return ret;
    }

  /* Read the pin value. Warning: Pin Number passed as BL602 Pinset */

  *value = bl602_gpioread(pin &lt;&lt; GPIO_PIN_SHIFT);

  /* Unlock the I/O Expander */

  bl602_expander_unlock(priv);
  gpioinfo(&quot;pin=%u, value=%u\n&quot;, pin, *value);
  return ret;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L596-L642">(Source)</a></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L218-L230">(<code>bl602_gpioread</code> comes from the BL602 GPIO Driver)</a></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/expander-code8a.png" alt="" /></p>
<h1 id="appendix-attach-gpio-interrupt"><a href="#appendix-attach-gpio-interrupt">16 Appendix: Attach GPIO Interrupt</a></h1>
<p>TODO</p>
<p>Here‚Äôs how our BL602 GPIO Expander attaches a GPIO Interrupt Handler‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Attach a Callback Function to a GPIO Interrupt
#ifdef CONFIG_IOEXPANDER_INT_ENABLE
static FAR void *bl602_expander_attach(FAR struct ioexpander_dev_s *dev,
                       ioe_pinset_t pinset,
                       ioe_callback_t callback, FAR void *arg)
{
  FAR struct bl602_expander_dev_s *priv = (FAR struct bl602_expander_dev_s *)dev;
  FAR struct bl602_expander_callback_s *cb = NULL;
  int ret = 0;

  gpioinfo(&quot;pinset=%x, callback=%p, arg=%p\n&quot;, pinset, callback, arg);
  DEBUGASSERT(priv != NULL);

  /* Get exclusive access to the I/O Expander */

  ret = bl602_expander_lock(priv);
  if (ret &lt; 0)
    {
      gpioerr(&quot;ERROR: Lock failed\n&quot;);
      return NULL;
    }

  /* Handle each GPIO Pin in the pinset */

  for (uint8_t gpio_pin = 0; gpio_pin &lt; CONFIG_IOEXPANDER_NPINS; gpio_pin++)
    {
      /* If GPIO Pin is set in the pinset... */

      if (pinset &amp; ((ioe_pinset_t)1 &lt;&lt; gpio_pin))
        {
          cb = &amp;priv-&gt;cb[gpio_pin];

          if (callback == NULL) /* Detach Callback */
            {
              /* Disable GPIO Interrupt and clear Interrupt Callback */

              gpioinfo(&quot;Detach callback for gpio=%d, callback=%p, arg=%p\n&quot;,
                      cb-&gt;pinset, cb-&gt;cbfunc, cb-&gt;cbarg);
              bl602_expander_intmask(gpio_pin, 1);
              cb-&gt;pinset = 0;
              cb-&gt;cbfunc = NULL;
              cb-&gt;cbarg  = NULL;
              ret = 0;
            }
          else if (cb-&gt;cbfunc == NULL) /* Attach Callback */
            {
              /* Set Interrupt Callback and enable GPIO Interrupt */

              gpioinfo(&quot;Attach callback for gpio=%d, callback=%p, arg=%p\n&quot;, 
                      gpio_pin, callback, arg);
              cb-&gt;pinset = gpio_pin;
              cb-&gt;cbfunc = callback;
              cb-&gt;cbarg  = arg;
              bl602_expander_intmask(gpio_pin, 0);
              ret = 0;
            }
          else /* Callback already attached */
            {
              gpioerr(&quot;ERROR: GPIO %d already attached\n&quot;, gpio_pin);
              ret = -EBUSY;
            }

          /* Only 1 GPIO Pin allowed */

          DEBUGASSERT(pinset == ((ioe_pinset_t)1 &lt;&lt; gpio_pin));
          break;
        }
    }

  /* Unlock the I/O Expander and return the handle */

  bl602_expander_unlock(priv);
  return (ret == 0) ? cb : NULL;
}
#endif</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L814-L906">(Source)</a></p>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L164-L197">(<code>bl602_expander_intmask</code> is defined here)</a></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/expander-code10a.png" alt="" /></p>
<h1 id="appendix-detach-gpio-interrupt"><a href="#appendix-detach-gpio-interrupt">17 Appendix: Detach GPIO Interrupt</a></h1>
<p>TODO</p>
<p>Here‚Äôs how our BL602 GPIO Expander detaches a GPIO Interrupt Handler‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Detach and disable a GPIO Interrupt
#ifdef CONFIG_IOEXPANDER_INT_ENABLE
static int bl602_expander_detach(FAR struct ioexpander_dev_s *dev, FAR void *handle)
{
  FAR struct bl602_expander_dev_s *priv = (FAR struct bl602_expander_dev_s *)dev;
  FAR struct bl602_expander_callback_s *cb =
    (FAR struct bl602_expander_callback_s *)handle;

  DEBUGASSERT(priv != NULL &amp;&amp; cb != NULL);
  DEBUGASSERT((uintptr_t)cb &gt;= (uintptr_t)&amp;priv-&gt;cb[0] &amp;&amp;
              (uintptr_t)cb &lt;=
              (uintptr_t)&amp;priv-&gt;cb[CONFIG_IOEXPANDER_NPINS - 1]);
  UNUSED(priv);
  gpioinfo(&quot;Detach callback for gpio=%d, callback=%p, arg=%p\n&quot;,
           cb-&gt;pinset, cb-&gt;cbfunc, cb-&gt;cbarg);

  /* Disable the GPIO Interrupt */

  DEBUGASSERT(cb-&gt;pinset &lt; CONFIG_IOEXPANDER_NPINS);
  bl602_expander_intmask(cb-&gt;pinset, 1);

  /* Clear the Interrupt Callback */

  cb-&gt;pinset = 0;
  cb-&gt;cbfunc = NULL;
  cb-&gt;cbarg  = NULL;
  return OK;
}
#endif</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L908-L950">(Source)</a></p>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L164-L197">(<code>bl602_expander_intmask</code> is defined here)</a></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/expander-code11a.png" alt="" /></p>
<h1 id="appendix-handle-gpio-interrupt"><a href="#appendix-handle-gpio-interrupt">18 Appendix: Handle GPIO Interrupt</a></h1>
<p>TODO</p>
<p>Here‚Äôs how our BL602 GPIO Expander handles a GPIO Interrupt‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Handle GPIO Interrupt. Based on
//  https://github.com/apache/incubator-nuttx/blob/master/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L256-L304
static int bl602_expander_interrupt(int irq, void *context, void *arg)
{
  FAR struct bl602_expander_dev_s *priv = (FAR struct bl602_expander_dev_s *)arg;
  uint32_t time_out = 0;
  uint8_t gpio_pin;

  gpioinfo(&quot;Interrupt! context=%p, priv=%p\n&quot;, context, priv);
  DEBUGASSERT(priv != NULL);

  /* TODO: Check only the GPIO Pins that have registered for interrupts */

  for (gpio_pin = 0; gpio_pin &lt; CONFIG_IOEXPANDER_NPINS; gpio_pin++)
    {
      /* Found the GPIO for the interrupt */

      if (1 == bl602_expander_get_intstatus(gpio_pin))
        {
          FAR struct bl602_expander_callback_s *cb = &amp;priv-&gt;cb[gpio_pin];
          ioe_callback_t cbfunc = cb-&gt;cbfunc;
          FAR void* cbarg = cb-&gt;cbarg;

          /* Attempt to clear the Interrupt Status */

          bl602_expander_intclear(gpio_pin, 1);

          /* Check Interrupt Status with timeout */

          time_out = 32;
          do
            {
              time_out--;
            }
          while ((1 == bl602_expander_get_intstatus(gpio_pin)) &amp;&amp; time_out);
          if (!time_out)
            {
              gpiowarn(&quot;WARNING: Clear GPIO interrupt status fail.\n&quot;);
            }

          /* If time_out==0, Interrupt Status not cleared */

          bl602_expander_intclear(gpio_pin, 0);

          /* NOTE: Callback will run in the context of Interrupt Handler */

          if (cbfunc == NULL)
            {
              gpioinfo(&quot;Missing callback for GPIO %d\n&quot;, gpio_pin);
            }
          else
            {
              gpioinfo(&quot;Call gpio=%d, callback=%p, arg=%p\n&quot;, gpio_pin, cbfunc, cbarg);
              cbfunc(&amp;priv-&gt;dev, gpio_pin, cbarg);
            }
        }
    }

  return OK;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L327-L393">(Source)</a></p>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L275-L300">(<code>bl602_expander_intclear</code> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L247-L274">(<code>bl602_expander_get_intstatus</code> is defined here)</a></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/expander-code12a.png" alt="" /></p>
<h1 id="appendix-gpio-interrupt"><a href="#appendix-gpio-interrupt">19 Appendix: GPIO Interrupt</a></h1>
<p>TODO</p>
<p>Earlier we called these functions at startup to handle GPIO Interrupts‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L731-L772"><strong>bl602_irq_attach</strong></a>: Attach our GPIO Interrupt Handler</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L774-L804"><strong>bl602_irq_enable</strong></a>: Enable GPIO Interrupt</p>
</li>
</ul>
<p>Let‚Äôs look inside the functions.</p>
<h2 id="attach-interrupt-handler-1"><a href="#attach-interrupt-handler-1">19.1 Attach Interrupt Handler</a></h2>
<p>TODO</p>
<p>We call <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L731-L772"><strong>bl602_irq_attach</strong></a> to attach our GPIO Interrupt Handler.</p>
<p><strong>bl602_irq_attach</strong> is defined below: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L686-L727">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Attach Interrupt Handler to GPIO Interrupt for Touch Controller
//  Based on https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L477-L505
static int bl602_irq_attach(gpio_pinset_t pinset, FAR isr_handler *callback, FAR void *arg)
{
  int ret = 0;
  uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;
  FAR struct bl602_gpint_dev_s *dev = NULL;  //  TODO

  DEBUGASSERT(callback != NULL);

  /* Configure the pin that will be used as interrupt input */

  #warning Check GLB_GPIO_INT_TRIG_NEG_PULSE  //  TODO
  bl602_expander_set_intmod(gpio_pin, 1, GLB_GPIO_INT_TRIG_NEG_PULSE);
  ret = bl602_configgpio(pinset);
  if (ret &lt; 0)
    {
      gpioerr(&quot;Failed to configure GPIO pin %d\n&quot;, gpio_pin);
      return ret;
    }

  /* Make sure the interrupt is disabled */

  bl602_expander_pinset = pinset;
  bl602_expander_callback = callback;
  bl602_expander_arg = arg;
  bl602_expander_intmask(gpio_pin, 1);

  irq_attach(BL602_IRQ_GPIO_INT0, bl602_expander_interrupt, dev);
  bl602_expander_intmask(gpio_pin, 0);

  gpioinfo(&quot;Attach %p\n&quot;, callback);

  return 0;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L58-L140">(<strong>bl602_configgpio</strong> is defined in the BL602 GPIO Driver)</a></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/sched/irq/irq_attach.c#L37-L136">(<strong>irq_attach</strong> comes from the BL602 IRQ Driver)</a></p>
<p>This code calls two functions from the <strong>BL602 GPIO Expander</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L890-L937"><strong>bl602_expander_set_intmod</strong></a>: Set GPIO Interrupt Mode</p>
<p><a href="https://github.com/apache/incubator-nuttx/issues/5810#issuecomment-1098633538">(We fixed this bug)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L856-L888"><strong>bl602_expander_intmask</strong></a>: Set GPIO Interrupt Mask</p>
</li>
</ul>
<h2 id="enable-gpio-interrupt"><a href="#enable-gpio-interrupt">19.2 Enable GPIO Interrupt</a></h2>
<p>TODO</p>
<p>We call <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L774-L804"><strong>bl602_irq_enable</strong></a> to enable (or disable) GPIO Interrupts.  Here‚Äôs the function: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L774-L804">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Enable or disable GPIO Interrupt for Touch Controller.
//  Based on https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L507-L535
static int bl602_irq_enable(bool enable)
{
  if (enable)
    {
      if (bl602_expander_callback != NULL)
        {
          gpioinfo(&quot;Enable interrupt\n&quot;);
          up_enable_irq(BL602_IRQ_GPIO_INT0);
        }
      else
        {
          gpiowarn(&quot;No callback attached\n&quot;);
        }
    }
  else
    {
      gpioinfo(&quot;Disable interrupt\n&quot;);
      up_disable_irq(BL602_IRQ_GPIO_INT0);
    }

  return 0;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_irq.c#L110-L170">(<strong>up_enable_irq</strong> and <strong>up_disable_irq</strong> are defined in the BL602 IRQ Driver)</a></p>

    
</body>
</html>