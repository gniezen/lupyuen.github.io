<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>NuttX GPIO Expander for PineDio Stack BL604</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="NuttX GPIO Expander for PineDio Stack BL604" 
    data-rh="true">
<meta property="og:description" 
    content="PineDio Stack BL604 RISC-V Board has an interesting problem on Apache NuttX RTOS... Too many GPIOs! Let's fix this with a GPIO Expander"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/expander-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">NuttX GPIO Expander for PineDio Stack BL604</h1>
    <nav id="TOC"><ul>
<li><a href="#bl602-evb-limitations">1 BL602 EVB Limitations</a><ul>
<li><a href="#pin-definitions">1.1 Pin Definitions</a><ul></ul></li></ul></li>
<li><a href="#overcome-the-limitations">2 Overcome The Limitations</a><ul></ul></li>
<li><a href="#gpio-expander">3 GPIO Expander</a><ul>
<li><a href="#gpio-operations">3.1 GPIO Operations</a><ul></ul></li></ul></li>
<li><a href="#gpio-interrupt">4 GPIO Interrupt</a><ul>
<li><a href="#bl602-evb-interrupt">4.1 BL602 EVB Interrupt</a><ul></ul></li>
<li><a href="#attach-interrupt-handler">4.2 Attach Interrupt Handler</a><ul></ul></li>
<li><a href="#gpio-command">4.3 GPIO Command</a><ul></ul></li>
<li><a href="#other-callers">4.4 Other Callers</a><ul></ul></li></ul></li>
<li><a href="#load-gpio-expander">5 Load GPIO Expander</a><ul></ul></li>
<li><a href="#validate-gpio">6 Validate GPIO</a><ul>
<li><a href="#pin-functions">6.1 Pin Functions</a><ul></ul></li></ul></li>
<li><a href="#test-gpio-expander">7 Test GPIO Expander</a><ul>
<li><a href="#test-touch-panel">7.1 Test Touch Panel</a><ul></ul></li>
<li><a href="#test-push-button">7.2 Test Push Button</a><ul></ul></li>
<li><a href="#test-lorawan">7.3 Test LoRaWAN</a><ul></ul></li></ul></li>
<li><a href="#whats-next">8 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">9 Notes</a><ul></ul></li>
<li><a href="#appendix-validate-pin-function">10 Appendix: Validate Pin Function</a><ul></ul></li>
<li><a href="#appendix-status">11 Appendix: Status</a><ul></ul></li>
<li><a href="#appendix-configure-gpio">12 Appendix: Configure GPIO</a><ul></ul></li>
<li><a href="#appendix-set-gpio-options">13 Appendix: Set GPIO Options</a><ul></ul></li>
<li><a href="#appendix-read-gpio">14 Appendix: Read GPIO</a><ul></ul></li>
<li><a href="#appendix-write-gpio">15 Appendix: Write GPIO</a><ul></ul></li>
<li><a href="#appendix-attach-gpio-interrupt">16 Appendix: Attach GPIO Interrupt</a><ul></ul></li>
<li><a href="#appendix-detach-gpio-interrupt">17 Appendix: Detach GPIO Interrupt</a><ul></ul></li>
<li><a href="#appendix-handle-gpio-interrupt">18 Appendix: Handle GPIO Interrupt</a><ul></ul></li>
<li><a href="#appendix-gpio-interrupt">19 Appendix: GPIO Interrupt</a><ul>
<li><a href="#attach-interrupt-handler-1">19.1 Attach Interrupt Handler</a><ul></ul></li>
<li><a href="#enable-gpio-interrupt">19.2 Enable GPIO Interrupt</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>2 May 2022</em></p>
<p><img src="https://lupyuen.github.io/images/expander-title.jpg" alt="NuttX GPIO Expander for PineDio Stack BL604" /></p>
<p><a href="https://lupyuen.github.io/articles/pinedio2"><strong>PineDio Stack BL604</strong></a> (Pine64‚Äôs newest RISC-V board) has an interesting problem on <a href="https://lupyuen.github.io/articles/nuttx"><strong>Apache NuttX RTOS</strong></a>‚Ä¶</p>
<p><em><strong>Too Many GPIOs!</strong></em></p>
<p>Let‚Äôs fix this with a <strong>GPIO Expander</strong>.</p>
<p><em>Why too many GPIOs?</em></p>
<p>All <strong>23 GPIOs</strong> on PineDio Stack BL604 are wired up‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/pinedio2#appendix-gpio-assignment"><strong>‚ÄúPineDio Stack GPIO Assignment‚Äù</strong></a></li>
</ul>
<p>And we need easy access to all GPIOs as our devs create <strong>NuttX Drivers and Apps</strong> for PineDio Stack.</p>
<p>(See pic below)</p>
<p><em>NuttX can‚Äôt handle 23 GPIOs?</em></p>
<p>Well it gets messy. Without GPIO Expander, BL604 on NuttX supports one <strong>GPIO Input</strong>, one <strong>GPIO Output</strong> and one <strong>GPIO Interrupt</strong>.</p>
<p>And they are <strong>named sequentially</strong> (Input first, then Output, then Interrupt)‚Ä¶</p>
<ul>
<li>
<p><strong>/dev/gpio0</strong>: GPIO Input</p>
</li>
<li>
<p><strong>/dev/gpio1</strong>: GPIO Output</p>
</li>
<li>
<p><strong>/dev/gpio2</strong>: GPIO Interrupt</p>
</li>
</ul>
<p>(See pic above)</p>
<p><em>This looks OK?</em></p>
<p>Until we realise that they map to <strong>totally different GPIO Pins</strong> on PineDio Stack!</p>
<div><table><thead><tr><th>GPIO Device</th><th style="text-align: center">BL604 GPIO Pin</th><th>Function</th></tr></thead><tbody>
<tr><td><strong>/dev/gpio0</strong></td><td style="text-align: center">GPIO Pin <strong><code>10</code></strong></td><td>SX1262 Busy</td></tr>
<tr><td><strong>/dev/gpio1</strong></td><td style="text-align: center">GPIO Pin <strong><code>15</code></strong></td><td>SX1262 Chip Select</td></tr>
<tr><td><strong>/dev/gpio2</strong></td><td style="text-align: center">GPIO Pin <strong><code>19</code></strong></td><td>SX1262 Interrupt</td></tr>
</tbody></table>
</div>
<p>Extend this to <strong>23 GPIOs</strong> and we have a mapping disaster!</p>
<p>Let‚Äôs simplify this setup and map GPIO Pins 0 to 22 as ‚Äú<strong>/dev/gpio0</strong>‚Äù to ‚Äú<strong>/dev/gpio22</strong>‚Äù. We‚Äôll do this with a <strong>GPIO Expander</strong>.</p>
<p>(See pic above)</p>
<p><em>What‚Äôs a GPIO Expander?</em></p>
<p>NuttX lets us create <strong>I/O Expander Drivers</strong> that will manage many GPIOs‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/incubator-nuttx/blob/master/include/nuttx/ioexpander/ioexpander.h"><strong>NuttX I/O Expander Driver Interface</strong></a></li>
</ul>
<p>Well BL604 looks like a <strong>Big Bag o‚Äô GPIOs</strong>. Why not create a <strong>GPIO Expander</strong> that will manage all 23 GPIOs?</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602_expander"><strong>BL602 / BL604 GPIO Expander</strong></a></li>
</ul>
<p>(Other microcontrollers might also need a GPIO Expander‚Ä¶ Like <a href="https://github.com/openwch/ch32v307"><strong>CH32V307</strong></a>, which has 80 GPIOs!)</p>
<p><em>So we‚Äôre just renumbering GPIOs?</em></p>
<p>Above and beyond that, our BL604 GPIO Expander serves other functions‚Ä¶</p>
<ul>
<li>
<p>Attach and detach <strong>GPIO Interrupt Handlers</strong></p>
</li>
<li>
<p><strong>Validate GPIO Pin Numbers</strong> at startup</p>
</li>
<li>
<p>But skip the GPIOs reserved for <strong>UART, I2C and SPI</strong></p>
<p>(That‚Äôs why we have GPIO gaps in the pic above)</p>
</li>
</ul>
<p>Let‚Äôs dive in!</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/expander-pinedio1a.png" alt="All 23 GPIOs on PineDio Stack BL604 are wired up" /></p>
</blockquote>
<blockquote>
<p><a href="https://lupyuen.github.io/articles/pinedio2#appendix-gpio-assignment">(Source)</a></p>
</blockquote>
<h1 id="bl602-evb-limitations"><a href="#bl602-evb-limitations">1 BL602 EVB Limitations</a></h1>
<p><em>What‚Äôs this BL602 EVB?</em></p>
<p>In NuttX, <strong>BL602 EVB</strong> (‚ÄúEvaluation Board‚Äù) provides the <strong>Board-Specific Functions</strong> for PineDio Stack and other BL602 / BL604 boards‚Ä¶</p>
<ul>
<li><strong>NuttX BL602 EVB:</strong> <a href="https://github.com/lupyuen/incubator-nuttx/tree/pinedio/boards/risc-v/bl602/bl602evb/src"><strong>boards/risc-v/bl602/bl602evb</strong></a></li>
</ul>
<p><em>What‚Äôs inside BL602 EVB?</em></p>
<p>The important parts of BL602 EVB are‚Ä¶</p>
<ul>
<li>
<p><strong>Pin Definitions:</strong> <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h"><strong>board.h</strong></a></p>
<p>Defines the pins for the GPIO, UART, I2C, SPI and PWM ports.</p>
</li>
<li>
<p><strong>Bring-Up:</strong> <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c"><strong>bl602_bringup.c</strong></a></p>
<p>Starts the NuttX Drivers and the GPIO / UART / I2C / SPI / PWM ports.</p>
</li>
<li>
<p><strong>EVB GPIO Driver:</strong> <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c"><strong>bl602_gpio.c</strong></a></p>
<p>Implements the GPIO Input, Output and Interrupt ports.</p>
<p>Calls the <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c"><strong>BL602 GPIO Driver</strong></a>.</p>
</li>
</ul>
<p>In a while we‚Äôll study the <strong>limitations of BL602 EVB</strong>, to understand why we created the BL602 GPIO Expander.</p>
<p><em>Wait‚Ä¶ Where‚Äôs the rest of the BL602 stuff?</em></p>
<p>The <strong>Architecture-Specific Functions</strong> for BL602 and BL604 are located at‚Ä¶</p>
<ul>
<li><strong>NuttX BL602:</strong> <a href="https://github.com/lupyuen/incubator-nuttx/tree/pinedio/arch/risc-v/src/bl602"><strong>arch/risc-v/src/bl602</strong></a></li>
</ul>
<p>This includes the low-level drivers for GPIO, UART, I2C, SPI, PWM, ‚Ä¶</p>
<p>We‚Äôre hunky dory with these drivers, though we‚Äôve made tiny mods like for <a href="https://lupyuen.github.io/articles/pinedio2#spi-device-table"><strong>SPI Device Table</strong></a>.</p>
<p><img src="https://lupyuen.github.io/images/expander-title1a.png" alt="BL602 EVB always maps sequentially the GPIO Pins" /></p>
<h2 id="pin-definitions"><a href="#pin-definitions">1.1 Pin Definitions</a></h2>
<p>In BL602 EVB, this is how we <strong>define the pins</strong> for GPIO / UART / I2C / SPI / PWM: <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L38-L59">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define BOARD_NGPIOIN  1  //  Number of GPIO Input pins
#define BOARD_NGPIOOUT 1  //  Number of GPIO Output pins
#define BOARD_NGPIOINT 1  //  Number of GPIO Interrupt pins

//  GPIO Input: GPIO 10
#define BOARD_GPIO_IN1  (GPIO_PIN10 | GPIO_INPUT | GPIO_FLOAT | GPIO_FUNC_SWGPIO)

//  GPIO Output: GPIO 15
#define BOARD_GPIO_OUT1 (GPIO_PIN15 | GPIO_OUTPUT | GPIO_PULLUP | GPIO_FUNC_SWGPIO)

//  GPIO Interrupt: GPIO 19
#define BOARD_GPIO_INT1 (GPIO_PIN19 | GPIO_INPUT | GPIO_FLOAT | GPIO_FUNC_SWGPIO)</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L61-L145">(See the UART / I2C / SPI / PWM Pins)</a></p>
<p>A couple of issues‚Ä¶</p>
<ul>
<li>
<p>BL602 EVB strangely limits us to <strong>one GPIO Input, one GPIO Output and one GPIO Interrupt</strong></p>
</li>
<li>
<p>We could extend this GPIO Limit, but we‚Äôll have to <strong>modify the EVB GPIO Driver</strong>, which sounds odd</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L106-L137">(See this)</a></p>
</li>
<li>
<p>BL602 EVB always <strong>maps sequentially</strong> the GPIO Pins like so: GPIO Input, then GPIO Output, then GPIO Interrupt (pic above)‚Ä¶</p>
<p><strong>/dev/gpio0</strong>: GPIO Input <em>(GPIO 10)</em></p>
<p><strong>/dev/gpio1</strong>: GPIO Output <em>(GPIO 15)</em></p>
<p><strong>/dev/gpio2</strong>: GPIO Interrupt <em>(GPIO 19)</em></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L550-L604">(See this)</a></p>
</li>
<li>
<p>Which becomes super confusing when we <strong>map all 23 GPIOs</strong> on PineDio Stack.</p>
<p>(Especially when our new devs are now creating NuttX Drivers and Apps for PineDio Stack)</p>
</li>
<li>
<p>What happens if we <strong>reuse the GPIOs</strong> by mistake? BL602 EVB will silently allow this. Which ain‚Äôt right!</p>
<div class="example-wrap"><pre class="language-c"><code>//  GPIO Input: GPIO 10
#define BOARD_GPIO_IN1  (GPIO_PIN10 | GPIO_INPUT | GPIO_FLOAT | GPIO_FUNC_SWGPIO)

//  GPIO Output: Also GPIO 10 (Oops!)
#define BOARD_GPIO_OUT1 (GPIO_PIN10 | GPIO_OUTPUT | GPIO_PULLUP | GPIO_FUNC_SWGPIO)</code></pre></div></li>
</ul>
<p>Thus we see that <strong>BL602 EVB is somewhat limited</strong>‚Ä¶</p>
<p>BL602 EVB works great for 3 GPIOs, but <strong>doesn‚Äôt scale well</strong> beyond that.</p>
<p>Let‚Äôs make this better.</p>
<p><em>Shouldn‚Äôt the pins be defined in Kconfig / menuconfig?</em></p>
<p>Perhaps. NuttX on ESP32 defines the pins in <strong>Kconfig and menuconfig.</strong> <a href="https://github.com/apache/incubator-nuttx/blob/master/arch/xtensa/src/esp32/Kconfig#L938-L984">(See this)</a></p>
<p>But for now, let‚Äôs keep the Pin Definitions in <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L38-L59"><strong>board.h</strong></a>.</p>
<p><img src="https://lupyuen.github.io/images/expander-title2a.jpg" alt="Overcome The Limitations" /></p>
<h1 id="overcome-the-limitations"><a href="#overcome-the-limitations">2 Overcome The Limitations</a></h1>
<p>We plan to make BL602 EVB <strong>work great with PineDio Stack</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>Support 23 GPIOs</strong> with any mix of GPIO Inputs / Outputs / Interrupts</p>
<p>(Perfect for PineDio Stack‚Äôs SPI Display, I2C Touch Panel, SX1262 Transceiver, Accelerometer, Push Button, ‚Ä¶)</p>
</li>
<li>
<p>Renumber the GPIOs as ‚Äú<strong>/dev/gpio0</strong>‚Äù to ‚Äú<strong>/dev/gpio22</strong>‚Äù</p>
<p>(‚Äú<strong>/dev/gpioN</strong>‚Äù will simply map to <strong>GPIO Pin N</strong>)</p>
</li>
<li>
<p>Allow <strong>gaps in the GPIO Numbering</strong> (pic above)</p>
<p>(We skip the GPIOs reserved for UART, I2C, SPI and PWM)</p>
</li>
<li>
<p>Keep the <strong>Pin Definitions</strong></p>
<p>(Original BL602 EVB will still build OK for plain old BL602)</p>
</li>
<li>
<p><strong>Validate the GPIOs</strong> at startup</p>
<p>(No more reusing GPIOs by mistake!)</p>
</li>
</ul>
<p>We make this happen by extending BL602 EVB with an (optional) <strong>GPIO Expander</strong>.</p>
<p><em>Why not make an EVB for PineDio Stack?</em></p>
<p>Yes we could create a new <strong>EVB for PineDio Stack</strong>.</p>
<p>(And do away with BL602 EVB altogether)</p>
<p>But we‚Äôll save that for later because it might lead to <strong>fragmentation of BL602 / BL604 Support</strong> in NuttX.</p>
<p>(Let‚Äôs do the <strong>bare minimum</strong> that will make NuttX decently usable on PineDio Stack!)</p>
<p><img src="https://lupyuen.github.io/images/expander-code1a.png" alt="NuttX I/O Expander Driver Interface" /></p>
<h1 id="gpio-expander"><a href="#gpio-expander">3 GPIO Expander</a></h1>
<p><em>So our GPIO Expander works like a NuttX I/O Expander?</em></p>
<p>Yep, NuttX lets us create <strong>I/O Expander Drivers</strong> that will manage many Input, Output and Interrupt GPIOs‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/incubator-nuttx/blob/master/include/nuttx/ioexpander/ioexpander.h"><strong>NuttX I/O Expander Driver Interface</strong></a></li>
</ul>
<p>I/O Expanders will support reading and writing to GPIOs, also attaching and detaching Interrupt Handlers. (Pic above)</p>
<p><em>Isn‚Äôt an I/O Expander Driver supposed to be Platform-Independent?</em></p>
<p>Yeah, we‚Äôre borrowing (misappropriating?) this NuttX Abstraction
because it meets our needs for PineDio Stack.</p>
<p>Other RISC-V microcontrollers might also need a GPIO Expander‚Ä¶ Like <a href="https://github.com/openwch/ch32v307"><strong>CH32V307</strong></a>, which has 80 GPIOs!</p>
<p><em>Great! How will we get started on GPIO Expander?</em></p>
<p>NuttX helpfully provides a <strong>Skeleton Driver</strong> for I/O Expander (pic below)‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/incubator-nuttx/blob/master/drivers/ioexpander/skeleton.c"><strong>Skeleton Driver for I/O Expander</strong></a></li>
</ul>
<p>Let‚Äôs flesh out the Skeleton Driver for our GPIO Expander.</p>
<p><img src="https://lupyuen.github.io/images/expander-code4a.png" alt="Skeleton Driver for I/O Expander" /></p>
<h2 id="gpio-operations"><a href="#gpio-operations">3.1 GPIO Operations</a></h2>
<p>Our GPIO Expander supports these <strong>GPIO Operations</strong>‚Ä¶</p>
<ul>
<li>
<p>Set <strong>GPIO Direction</strong></p>
<p>(Input or Output)</p>
</li>
<li>
<p>Set <strong>GPIO Interrupt Options</strong></p>
<p>(Trigger by Rising or Falling Edge)</p>
</li>
<li>
<p>Read a <strong>GPIO Input</strong></p>
</li>
<li>
<p>Write to a <strong>GPIO Output</strong></p>
</li>
<li>
<p>Attach / Detach a <strong>GPIO Interrupt Handler</strong></p>
</li>
</ul>
<p>We define the GPIO Operations like so: <a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L141-L159">bl602_expander.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  GPIO Expander Operations
static const struct ioexpander_ops_s g_bl602_expander_ops = {
  bl602_expander_direction,  //  Set GPIO Direction
  bl602_expander_option,     //  Set GPIO Interrupt Options
  bl602_expander_writepin,   //  Write to GPIO Output
  bl602_expander_readpin,    //  Read from GPIO Input
  bl602_expander_readbuf,    //  (Read Buffer Not Implemented)
  ...
  bl602_expander_attach,     //  Attach GPIO Interrupt Handler
  bl602_expander_detach      //  Detach GPIO Interrupt Handler
};</code></pre></div>
<p>The <strong>implementation of the GPIO Operations</strong> is explained in the Appendix‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-configure-gpio"><strong>‚ÄúConfigure GPIO‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-set-gpio-options"><strong>‚ÄúSet GPIO Options‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-read-gpio"><strong>‚ÄúRead GPIO‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-write-gpio"><strong>‚ÄúWrite GPIO‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-attach-gpio-interrupt"><strong>‚ÄúAttach GPIO Interrupt‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-detach-gpio-interrupt"><strong>‚ÄúDetach GPIO Interrupt‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/expander#appendix-handle-gpio-interrupt"><strong>‚ÄúHandle GPIO Interrupt‚Äù</strong></a></p>
</li>
</ul>
<p><em>Existing NuttX Drivers call <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L218-L230"><strong>bl602_gpioread</strong></a> and <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L197-L216"><strong>bl602_gpiowrite</strong></a> to read and write BL602 GPIOs. Will they still work?</em></p>
<p>Yep the <strong>BL602 GPIO Functions</strong> like <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L218-L230"><strong>bl602_gpioread</strong></a> and <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L197-L216"><strong>bl602_gpiowrite</strong></a> will work fine with GPIO Expander.</p>
<p>The <strong>NuttX GPIO Functions</strong> like <code>open()</code> and <code>ioctl()</code> will also work with GPIO Expander.</p>
<p>(That‚Äôs because they call the <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/drivers/ioexpander/gpio_lower_half.c"><strong>GPIO Lower Half Driver</strong></a>, which is integrated with our GPIO Expander)</p>
<p>Let‚Äôs look at GPIO Interrupts, which are more complicated‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/expander-code5a.png" alt="GPIO Operations" /></p>
<h1 id="gpio-interrupt"><a href="#gpio-interrupt">4 GPIO Interrupt</a></h1>
<p><em>BL602 EVB works OK with GPIO Interrupts?</em></p>
<p>As noted (eloquently) by Robert Lipe, it‚Äôs <strong>difficult to attach a GPIO Interrupt Handler</strong> with BL602 EVB‚Ä¶</p>
<ul>
<li><a href="https://www.robertlipe.com/buttons-on-bl602-nuttx/"><strong>‚ÄúButtons on BL602 NuttX‚Äù</strong></a></li>
</ul>
<blockquote>
<p><img src="https://lupyuen.github.io/images/expander-button.png" alt="As noted (eloquently) by Robert Lipe, attaching a BL602 GPIO Interrupt Handler is hard (because our stars are misaligned)" /></p>
</blockquote>
<blockquote>
<p><a href="https://www.robertlipe.com/buttons-on-bl602-nuttx/">(Source)</a></p>
</blockquote>
<p>Let‚Äôs find out why‚Ä¶</p>
<h2 id="bl602-evb-interrupt"><a href="#bl602-evb-interrupt">4.1 BL602 EVB Interrupt</a></h2>
<p><em>Anything peculiar about GPIO Interrupts on BL602 and BL604?</em></p>
<p><strong>GPIO Interrupt Handling</strong> gets tricky for BL602 and BL604‚Ä¶</p>
<p>All GPIO Interrupts are multiplexed into <strong>One Single GPIO IRQ!</strong></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L477-L505">(<strong>BL602_IRQ_GPIO_INT0</strong> is the common GPIO IRQ)</a></p>
<p>BL602 EVB <strong>demultiplexes the GPIO IRQ</strong> and calls the GPIO Interrupt Handlers.</p>
<p><img src="https://lupyuen.github.io/images/expander-code2a.png" alt="Attaching a GPIO Interrupt with BL602 EVB" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L477-L505">(Source)</a></p>
<p><em>So we call BL602 EVB to attach our own GPIO Interrupt Handler?</em></p>
<p>Sadly we can‚Äôt. BL602 EVB <strong>doesn‚Äôt expose a Public Function</strong> that we may call to attach our Interrupt Handler.</p>
<p>(<strong>gpint_attach</strong> is a Private Function, as shown above)</p>
<p>We could call <a href="https://lupyuen.github.io/articles/sx1262#handle-dio1-interrupt"><strong><code>ioctl()</code></strong></a>, but that would be extremely awkward in the Kernel Space.</p>
<p><em>Which means we need to implement this in our GPIO Expander?</em></p>
<p>Exactly! Our <strong>GPIO Expander</strong> shall take over these duties from BL602 EVB‚Ä¶</p>
<ul>
<li>
<p>Handle the <strong>GPIO IRQ Interrupt</strong></p>
</li>
<li>
<p><strong>Demultiplex</strong> the IRQ</p>
</li>
<li>
<p>Call the right <strong>GPIO Interrupt Handler</strong></p>
</li>
</ul>
<p>More about the implementation in a moment. Let‚Äôs talk about calling the GPIO Expander‚Ä¶</p>
<h2 id="attach-interrupt-handler"><a href="#attach-interrupt-handler">4.2 Attach Interrupt Handler</a></h2>
<p><em>How do we attach a GPIO Interrupt Handler?</em></p>
<p>Because GPIO Expander implements the I/O Expander Interface, we may call <strong>IOEP_ATTACH</strong> to attach an Interrupt Handler.</p>
<p>Let‚Äôs attach an Interrupt Handler that will be called when we press the <strong>Push Button</strong> (GPIO 12) on PineDio Stack: <a href="https://github.com/lupyuen/incubator-nuttx/blob/2982b3a99057c5935ca9150b9f0f1da3565c6061/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L696-L704">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#include &lt;nuttx/ioexpander/gpio.h&gt;
#include &lt;nuttx/ioexpander/bl602_expander.h&gt;
...
//  Get the Push Button Pinset and GPIO Pin Number
gpio_pinset_t pinset = BOARD_BUTTON_INT;
uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L143-L145">(<strong>BOARD_BUTTON_INT</strong> is defined in board.h)</a></p>
<p>First we get the <strong>GPIO Pin Number</strong> for the Push Button.</p>
<p>Then we configure our GPIO Expander to trigger the GPIO Interrupt on the <strong>Falling Edge</strong> (High to Low)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Configure GPIO interrupt to be triggered on falling edge
DEBUGASSERT(bl602_expander != NULL);
IOEXP_SETOPTION(
  bl602_expander,  //  BL602 GPIO Expander
  gpio_pin,        //  GPIO Pin
  IOEXPANDER_OPTION_INTCFG,            //  Configure interrupt trigger
  (FAR void *) IOEXPANDER_VAL_FALLING  //  Trigger on falling edge
);</code></pre></div>
<p>Finally we call GPIO Expander to <strong>attach our Interrupt Handler</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Attach our GPIO interrupt handler
void *handle = IOEP_ATTACH(
  bl602_expander,                //  BL602 GPIO Expander
  (ioe_pinset_t) 1 &lt;&lt; gpio_pin,  //  GPIO Pin converted to Pinset
  button_isr_handler,            //  GPIO Interrupt Handler
  NULL                           //  TODO: Set the callback argument
);
DEBUGASSERT(handle != NULL);</code></pre></div>
<p>The <strong>Interrupt Handler</strong> is defined as‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Our GPIO Interrupt Handler
static int button_isr_handler(FAR struct ioexpander_dev_s *dev, ioe_pinset_t pinset, FAR void *arg) {
  gpioinfo(&quot;Button Pressed\n&quot;);
  return 0;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/2982b3a99057c5935ca9150b9f0f1da3565c6061/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L1038-L1044">(Source)</a></p>
<p>Note that the Interrupt Handler runs in the <strong>BL602 Interrupt Context</strong>.</p>
<p>Be careful!</p>
<h2 id="gpio-command"><a href="#gpio-command">4.3 GPIO Command</a></h2>
<p>Another way to test the Push Button Interrupt is to use the <strong>GPIO Command</strong>. </p>
<p>(This only works if we don‚Äôt call <strong>IOEP_ATTACH</strong> to attach the Interrupt Handler)</p>
<p>Enter this in the NuttX Shell‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>gpio -t 8 -w 1 /dev/gpio12</code></pre></div>
<p>Which says‚Ä¶</p>
<ul>
<li>
<p>Configure the GPIO for <strong>Rising Edge Interrupt</strong></p>
</li>
<li>
<p>And wait 5 seconds for <strong>Signal 1</strong></p>
</li>
</ul>
<p>Quickly press the <strong>Push Button</strong> on PineDio Stack. We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Interrupt pin: Value=1
Verify:        Value=1</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander#test-push-button">(See the Complete Log)</a></p>
<p>If we don‚Äôt press the button <strong>within 5 seconds</strong>, the GPIO Command reports an Interrupt Timeout‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Interrupt pin: Value=1
[Five second timeout with no signal]</code></pre></div><h2 id="other-callers"><a href="#other-callers">4.4 Other Callers</a></h2>
<p><em>Who else is calling GPIO Expander to handle interrupts?</em></p>
<p>The <strong>CST816S Driver</strong> for PineDio Stack‚Äôs Touch Panel calls GPIO Expander to attach an Interrupt Handler (that‚Äôs called when the screen is touched)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/touch#initialise-driver"><strong>‚ÄúInitialise CST816S Driver‚Äù</strong></a></li>
</ul>
<p>The <strong>Semtech SX1262 LoRa Transceiver</strong> on PineDio Stack triggers a GPIO Interrupt (on pin DIO1) when a LoRa packet is transmitted or received‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/sx1262#handle-dio1-interrupt"><strong>‚ÄúHandle DIO1 Interrupt‚Äù</strong></a></li>
</ul>
<p>This code calls <strong><code>ioctl()</code></strong> in the User Space (instead of Kernel Space), so it works OK with GPIO Expander without modification.</p>
<p>(That‚Äôs because <strong><code>ioctl()</code></strong> calls the <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/drivers/ioexpander/gpio_lower_half.c"><strong>GPIO Lower Half Driver</strong></a>, which is integrated with our GPIO Expander)</p>
<h1 id="load-gpio-expander"><a href="#load-gpio-expander">5 Load GPIO Expander</a></h1>
<p>Here‚Äôs how we <strong>load our GPIO Expander</strong> at startup: <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L742-L768">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_IOEXPANDER_BL602_EXPANDER
#include &lt;nuttx/ioexpander/gpio.h&gt;
#include &lt;nuttx/ioexpander/bl602_expander.h&gt;

//  Global Instance of GPIO Expander
FAR struct ioexpander_dev_s *bl602_expander = NULL;
#endif  //  CONFIG_IOEXPANDER_BL602_EXPANDER
...
int bl602_bringup(void) {
  ...
//  Existing Code
#if defined(CONFIG_DEV_GPIO) &amp;&amp; !defined(CONFIG_GPIO_LOWER_HALF)
  ret = bl602_gpio_initialize();
  if (ret &lt; 0) {
    syslog(LOG_ERR, &quot;Failed to initialize GPIO Driver: %d\n&quot;, ret);
    return ret;
  }
#endif

//  New Code
#ifdef CONFIG_IOEXPANDER_BL602_EXPANDER
  //  Must load BL602 GPIO Expander before other drivers
  bl602_expander = bl602_expander_initialize(
    bl602_gpio_inputs,     sizeof(bl602_gpio_inputs) / sizeof(bl602_gpio_inputs[0]),
    bl602_gpio_outputs,    sizeof(bl602_gpio_outputs) / sizeof(bl602_gpio_outputs[0]),
    bl602_gpio_interrupts, sizeof(bl602_gpio_interrupts) / sizeof(bl602_gpio_interrupts[0]),
    bl602_other_pins,      sizeof(bl602_other_pins) / sizeof(bl602_other_pins[0]));
  if (bl602_expander == NULL) {
    syslog(LOG_ERR, &quot;Failed to initialize GPIO Expander\n&quot;);
    return -ENOMEM;
  }
#endif  //  CONFIG_IOEXPANDER_BL602_EXPANDER</code></pre></div>
<p>(We‚Äôll talk about <strong>bl602_gpio_*</strong> in the next chapter)</p>
<p>We must load the GPIO Expander <strong>before other drivers</strong> (like CST816S Touch Panel), because GPIO Expander provides GPIO functions for the drivers.</p>
<p>We need to <strong>disable the BL602 EVB GPIO Driver</strong>, because GPIO Expander needs the <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/drivers/ioexpander/gpio_lower_half.c"><strong>GPIO Lower Half Driver</strong></a> (which can‚Äôt coexist with BL602 EVB GPIO)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Added CONFIG_GPIO_LOWER_HALF below
#if defined(CONFIG_DEV_GPIO) &amp;&amp; !defined(CONFIG_GPIO_LOWER_HALF)
  ret = bl602_gpio_initialize();</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L646-L653">(Source)</a></p>
<p>Check the following in menuconfig‚Ä¶</p>
<ul>
<li>
<p>Enable ‚Äú<strong>BL602 GPIO Expander</strong>‚Äù under ‚ÄúDevice Drivers ‚Üí IO Expander/GPIO Support ‚Üí Enable IO Expander Support‚Äù</p>
</li>
<li>
<p>Set ‚Äú<strong>Number Of Pins</strong>‚Äù to 23</p>
</li>
<li>
<p>Enable ‚Äú<strong>GPIO Lower Half</strong>‚Äù</p>
</li>
</ul>
<p><a href="https://github.com/lupyuen/bl602_expander#install-driver">(Full instrunctions are here)</a></p>
<p><img src="https://lupyuen.github.io/images/expander-code3a.png" alt="Tracking all 23 GPIOs used by PineDio Stack can get challenging" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L61-L145">(Source)</a></p>
<h1 id="validate-gpio"><a href="#validate-gpio">6 Validate GPIO</a></h1>
<p><em>Managing 23 GPIOs sounds mighty challenging?</em></p>
<p>Indeed! Tracking all 23 GPIOs used by PineDio Stack can get challenging‚Ä¶ We might <strong>reuse the GPIOs</strong> by mistake!</p>
<p>Thankfully our GPIO Expander can help: It <strong>validates the GPIOs</strong> at startup.</p>
<p>Here are the <strong>GPIOs currently defined</strong> for PineDio Stack (more to come)‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L61-L145">boards/risc-v/bl602/bl602evb/include/board.h</a></li>
</ul>
<p>At startup, GPIO Expander verifies that the GPIO, UART, I2C, SPI and PWM Ports <strong>don‚Äôt reuse the same GPIO</strong>.</p>
<p>If a GPIO is reused like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  SPI CLK: GPIO 11
#define BOARD_SPI_CLK    (GPIO_PIN11 | GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI)
...
//  Push Button Interrupt: Also GPIO 11 (Oops!) 
#define BOARD_BUTTON_INT (GPIO_PIN11 | GPIO_INPUT | GPIO_FLOAT | GPIO_FUNC_SWGPIO)</code></pre></div>
<p>Then GPIO Expander will <strong>halt with an error</strong> at startup‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_expander_initialize: ERROR:
GPIO pin 11 is already in use</code></pre></div>
<p><em>Awesome! How do we enable this GPIO Validation?</em></p>
<p>To enable GPIO Validation, we <strong>add all GPIOs</strong> to the arrays <strong>bl602_gpio_inputs</strong>, <strong>bl602_gpio_outputs</strong>, <strong>bl602_gpio_interrupts</strong> and <strong>bl602_other_pins</strong>: <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L126-L222">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_IOEXPANDER_BL602_EXPANDER
//  GPIO Input Pins for BL602 GPIO Expander
static const gpio_pinset_t bl602_gpio_inputs[] =
{
#ifdef BOARD_SX1262_BUSY
  BOARD_SX1262_BUSY,
#endif  //  BOARD_SX1262_BUSY
//  Omitted: Other GPIO Input Pins
...
};

//  GPIO Output Pins for BL602 GPIO Expander
static const gpio_pinset_t bl602_gpio_outputs[] =
{
#ifdef BOARD_LCD_CS
  BOARD_LCD_CS,
#endif  //  BOARD_LCD_CS
//  Omitted: Other GPIO Output Pins
...
};

//  GPIO Interrupt Pins for BL602 GPIO Expander
static const gpio_pinset_t bl602_gpio_interrupts[] =
{
#ifdef BOARD_TOUCH_INT
  BOARD_TOUCH_INT,
#endif  //  BOARD_TOUCH_INT
//  Omitted: Other GPIO Interrupt Pins
...
};

//  Other Pins for BL602 GPIO Expander (For Validation Only)
static const gpio_pinset_t bl602_other_pins[] =
{
#ifdef BOARD_UART_0_RX_PIN
  BOARD_UART_0_RX_PIN,
#endif  //  BOARD_UART_0_RX_PIN
//  Omitted: Other UART, I2C, SPI and PWM Pins
...
};
#endif  //  CONFIG_IOEXPANDER_BL602_EXPANDER</code></pre></div>
<p>At startup, we <strong>pass the pins to GPIO Expander</strong> during initialisation‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Initialise GPIO Expander at startup
bl602_expander = bl602_expander_initialize(
  bl602_gpio_inputs,     sizeof(bl602_gpio_inputs) / sizeof(bl602_gpio_inputs[0]),
  bl602_gpio_outputs,    sizeof(bl602_gpio_outputs) / sizeof(bl602_gpio_outputs[0]),
  bl602_gpio_interrupts, sizeof(bl602_gpio_interrupts) / sizeof(bl602_gpio_interrupts[0]),
  bl602_other_pins,      sizeof(bl602_other_pins) / sizeof(bl602_other_pins[0]));</code></pre></div>
<p>GPIO Expander verifies that the <strong>GPIOs are not reused</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>FAR struct ioexpander_dev_s *bl602_expander_initialize(
  const gpio_pinset_t *gpio_inputs,     uint8_t gpio_input_count,
  const gpio_pinset_t *gpio_outputs,    uint8_t gpio_output_count,
  const gpio_pinset_t *gpio_interrupts, uint8_t gpio_interrupt_count,
  const gpio_pinset_t *other_pins,      uint8_t other_pin_count) {
  ...
  //  Mark the GPIOs in use
  bool gpio_is_used[CONFIG_IOEXPANDER_NPINS];
  memset(gpio_is_used, 0, sizeof(gpio_is_used));

  //  Validate the GPIO Inputs
  for (i = 0; i &lt; gpio_input_count; i++) {
    //  Get GPIO Pinset and GPIO Pin Number
    gpio_pinset_t pinset = gpio_inputs[i];
    uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;

    //  Check that the GPIO is not in use
    DEBUGASSERT(gpio_pin &lt; CONFIG_IOEXPANDER_NPINS);
    if (gpio_is_used[gpio_pin]) {
      gpioerr(&quot;ERROR: GPIO pin %d is already in use\n&quot;, gpio_pin);
      return NULL;
    }
    gpio_is_used[gpio_pin] = true;
  }

  //  Omitted: Validate the GPIO Outputs, GPIO Interrupts and Other Pins</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L958-L1123">(Source)</a></p>
<p>There‚Äôs something else we might validate at startup: Pin Functions‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/bl602-pins1a.png" alt="Pin Functions" /></p>
<h2 id="pin-functions"><a href="#pin-functions">6.1 Pin Functions</a></h2>
<p><em>We‚Äôre selecting a GPIO Pin for a UART / I2C / SPI / PWM Port‚Ä¶</em></p>
<p><em>Which pin can we use?</em></p>
<p>Refer to this table‚Ä¶</p>
<ul>
<li><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf"><strong>‚ÄúBL602 Reference Manual‚Äù</strong></a>, Table 3.1 ‚ÄúPin Description‚Äù (Page 26)</li>
</ul>
<p>In NuttX, we define the pins at‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L61-L145">boards/risc-v/bl602/bl602evb/include/board.h</a></li>
</ul>
<p>According to the pic above, <strong>SPI MISO</strong> must be either GPIO 0, 4, 8, 12, 16 or 20.</p>
<p><a href="https://lupyuen.github.io/articles/spi2#appendix-miso-and-mosi-are-swapped">(<strong>Beware:</strong> MISO and MOSI are swapped)</a></p>
<p>So this is OK‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  GPIO 0 for MISO is OK
#define BOARD_SPI_MISO (GPIO_PIN0 | GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI)</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L104">(Source)</a></p>
<p>But not this‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  GPIO 3 for MISO is NOT OK (Oops!)
#define BOARD_SPI_MISO (GPIO_PIN3 | GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI)</code></pre></div>
<p>BL602 / BL604 gives us incredible flexibility in selecting the pins‚Ä¶ But we might <strong>pick the wrong pin</strong> by mistake.</p>
<p>(Looks like an extreme form of STM32‚Äôs Alternate Pin Functions)</p>
<p><em>Is there a way to prevent such mistakes?</em></p>
<p>We have some ideas for <strong>validating the Pin Functions</strong> at compile-time or at startup‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/expander#appendix-validate-pin-function"><strong>‚ÄúValidate Pin Function‚Äù</strong></a></li>
</ul>
<p>But for now, be <strong>very careful when selecting pins</strong>!</p>
<h1 id="test-gpio-expander"><a href="#test-gpio-expander">7 Test GPIO Expander</a></h1>
<p><em>How shall we test our GPIO Expander on PineDio Stack?</em></p>
<p>We‚Äôll test with 3 features that are shipped with PineDio Stack‚Ä¶</p>
<ul>
<li>
<p><strong>CST816S Touch Panel</strong></p>
<p>(Which triggers a GPIO Interrupt when touched)</p>
</li>
<li>
<p><strong>Push Button</strong></p>
<p>(Which also triggers a GPIO Interrupt when pushed)</p>
</li>
<li>
<p><strong>LoRaWAN with Semtech SX1262 Transceiver</strong></p>
<p>(Which uses GPIO Input, Output and Interrupt)</p>
</li>
</ul>
<p>Follow these steps to <strong>build, flash and run</strong> NuttX on PineDio Stack‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#build-nuttx"><strong>‚ÄúBuild NuttX‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#flash-pinedio-stack"><strong>‚ÄúFlash PineDio Stack‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#boot-pinedio-stack"><strong>‚ÄúBoot PineDio Stack‚Äù</strong></a></p>
</li>
</ul>
<p>We‚Äôre ready to test GPIO Expander!</p>
<p><img src="https://lupyuen.github.io/images/touch-title.jpg" alt="Touch Panel Calibration for Pine64 PineDio Stack BL604 RISC-V Board" /></p>
<p><a href="https://lupyuen.github.io/articles/touch">(Source)</a></p>
<h2 id="test-touch-panel"><a href="#test-touch-panel">7.1 Test Touch Panel</a></h2>
<p>In the NuttX Shell, enter this command to start the <a href="https://github.com/lupyuen/lvgltest-nuttx"><strong>LVGL Test App</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>lvgltest</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/pinedio2#run-nuttx">(More about the LVGL Test App)</a></p>
<p>TODO</p>
<p>BL602 GPIO Expander tested OK with Touch Panel and LVGL Test App‚Ä¶</p>
<p>(With ‚ÄúGPIO Informational Output‚Äù logging enabled: <code>kconfig-tweak --enable CONFIG_DEBUG_GPIO_INFO</code>)</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_expander_irq_enable: Disable interrupt
bl602_expander_irq_enable: Enable interrupt
bl602_expander_direction: Unsupported direction: pin=10, direction=IN
bl602_expander_option: pin=10, option=2, value=0
bl602_expander_option: ERROR: Unsupported interrupt: 0, pin=10
gpio_pin_register: Registering /dev/gpio10
bl602_expander_direction: Unsupported direction: pin=20, direction=OUT
gpio_pin_register: Registering /dev/gpio20
bl602_expander_direction: Unsupported direction: pin=3, direction=OUT
gpio_pin_register: Registering /dev/gpio3
bl602_expander_direction: Unsupported direction: pin=21, direction=OUT
gpio_pin_register: Registering /dev/gpio21
bl602_expander_direction: Unsupported direction: pin=15, direction=OUT
gpio_pin_register: Registering /dev/gpio15
bl602_expander_direction: Unsupported direction: pin=14, direction=OUT
gpio_pin_register: Registering /dev/gpio14
bl602_expander_option: pin=9, option=2, value=0xe
bl602_expander_option: Unsupported interrupt both edge: pin=9
gplh_enable: pin9: Disabling callback=0 handle=0
gplh_enable: WARNING: pin9: Already detached
gpio_pin_register: Registering /dev/gpio9
bl602_expander_option: pin=12, option=2, value=0xe
bl602_expander_option: Unsupported interrupt both edge: pin=12
gplh_enable: pin12: Disabling callback=0 handle=0
gplh_enable: WARNING: pin12: Already detached
gpio_pin_register: Registering /dev/gpio12
bl602_expander_option: pin=19, option=2, value=0xe
bl602_expander_option: Unsupported interrupt both edge: pin=19
gplh_enable: pin19: Disabling callback=0 handle=0
gplh_enable: WARNING: pin19: Already detached
gpio_pin_register: Registering /dev/gpio19
cst816s_register: path=/dev/input0, addr=21
bl602_expander_option: pin=9, option=2, value=0xa
bl602_expander_option: Falling edge: pin=9
bl602_expander_set_intmod: gpio_pin=9, int_ctlmod=1, int_trgmod=0
bl602_expander_attach: pinset=200, callback=0x2305e47e, arg=0x42020f80
bl602_expander_attach: Attach callback for gpio=9, callback=0x2305e47e, arg=0x42020f80
cst816s_register: Driver registered

NuttShell (NSH) NuttX-10.3.0-RC0

nsh&gt; uname -a
NuttX 10.3.0-RC0 ffb275b71c Apr 24 2022 10:47:29 risc-v bl602evb

nsh&gt; ls /dev
/dev:
 console
 gpio10
 gpio12
 gpio14
 gpio15
 gpio19
 gpio20
 gpio21
 gpio3
 gpio9
 i2c0
 input0
 lcd0
 null
 spi0
 spitest0
 timer0
 urandom
 zero

nsh&gt; lvgltest
tp_init: Opening /dev/input0
cst816s_open:
bl602_expander_interrupt: Interrupt! context=0x42012db8, priv=0x4201df0
bl602_expander_interrupt: Call gpio=9, callback=0x2305e47e, arg=0x42020f80
cst816s_poll_notify:
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst86s_get_touch_data: Invalid touch data: id=9, touch=2, x=639, y=1688
cst816s_get_touch_data: UP: id=0, touch=2, x=190, y=18
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   0c
cst816s_get_touch_data:   x:       190
cst816s_get_touch_data:   y:       18
bl602_expander_interrupt: Interrupt! context=0x42012db8, priv=0x4201d0f0
bl602_expander_interrupt: Call gpio=9, callback=0x2305e47e, arg=0x42020f80
cst816s_poll_notify:
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=211, y=199
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       211
cst816s_get_touch_data:   y:       199
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=211, y=199
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       211
cst816s_get_touch_data:   y:       199
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: Invalid touch data: id=5, touch=2, x=652, y=514
cst816s_get_touch_data: UP: id=0, touch=2, x=211, y=199
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   0c
cst816s_get_touch_data:   x:       211
cst816s_get_touch_data:   y:       199
bl602_expander_interrupt: Interrupt! context=0x42012db8, priv=0x4201d0f0
bl602_expander_interrupt: Call gpio=9, callback=0x2305e47e, arg=0x42020f80
cst816s_poll_notify:
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=17, y=203
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       17
cst816s_get_touch_data:   y:      203
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=17, y=203
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       17
cst816s_get_touch_data:   y:       203
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: Invalid touch data: id=5, touch=2, x=652, y=514
cst816s_get_touch_data: UP: id=0, touch=2, x=17, y=203
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   0c
cst816s_get_touch_data:   x:       17
cst816s_get_touch_data:   y:       203
bl602_expander_interrupt: Interrupt! context=0x42012db8, priv=0x4201d0f0
bl602_expander_interrupt: Call gpio=9, callback=0x2305e47e, arg=0x42020f80
cst816s_poll_notify:
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=7, y=28
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       7
cst816s_get_touch_data:   y:       28
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=7, y=28
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       7
cst816s_get_touch_data:   y:       28
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: Invalid touch data: id=5, touch=2, x=652, y=514
cst816s_get_touch_data: UP: id=0, touch=2, x=7, y=28
cst816s_get_touch_data:   id:      0
st816s_get_touch_data:   flags:   0c
cst816s_get_touch_data:   x:       7
cst816s_get_touch_data:   y:       28
bl602_expander_interrupt: Interrupt! context=0x42012db8, priv=0x4201d0f0
bl602_expander_interrupt: Call gpio=9, callback=0x2305e47e, arg=0x42020f80
cst816s_poll_notify:
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=123, y=116
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       123
cst816s_get_touch_data:   y:       116
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: DOWN: id=0, touch=0, x=123, y=116
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       123
cst816s_get_touch_data:   y:       116
cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: i2c transfer success
cst816s_get_touch_data: Invalid touch data: id=5, touch=2, x=652, y=514
cst816s_get_touch_data: UP: id=0, touch=2, x=123, y=116
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   0c
cst816s_get_touch_data:   x:       123
cst816s_get_touch_data:   y:       116
tp_cal result
offset x:18, y:7
range x:181, y:183
invert x/y:1, x:0, y:1</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander#test-touch-panel">(See the Complete Log)</a></p>
<h2 id="test-push-button"><a href="#test-push-button">7.2 Test Push Button</a></h2>
<p>TODO</p>
<p>BL602 GPIO Expander tested OK with Push Button and GPIO Command‚Ä¶</p>
<p>(Comment out <code>IOEP_ATTACH</code> in <code>bl602_bringup</code>)</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; uname -a
NuttX 10.3.0-RC0 ffb275b71c Apr 24 2022 10:47:29 risc-v bl602evb

nsh&gt; ls /dev
/dev:
 console
 gpio10
 gpio12
 gpio14
 gpio15
 gpio19
 gpio20
 gpio21
 gpio3
 gpio9
 i2c0
 input0
 lcd0
 null
 spi0
 spitest0
 timer0
 urandom
 zero

nsh&gt; gpio -t 8 -w 1 /dev/gpio12
Driver: /dev/gpio12
gplh_enable: pin12: Disabling callback=0 handle=0
gplh_enable: WARNING: pin12: Already detached
bl602_expander_option: pin=12, option=2, value=0x6
bl602_expander_option: Rising edge: pin=12
bl602_expander_set_intmod: gpio_pin=12, int_ctlmod=1, int_trgmod=1
gplh_read: pin12: value=0x42021aef
bl602_expander_readpin: pin=12, value=1
  Interrupt pin: Value=1
gplh_attach: pin12: callback=0x23060808
gplh_enable: pin12: Enabling callback=0x23060808 handle=0
gplh_enable: pin12: Attaching 0x23060808
bl602_expander_attach: pinset=1000, callback=0x2305f4e2, arg=0x42020d40
bl602_expander_attach: Attach callback for gpio=12, callback=0x2305f4e2, arg=0x42020d40
bl602_expander_interrupt: Interrupt! context=0x42012db8, priv=0x4201d0f0
bl602_expander_interrupt: Call gpio=12, callback=0x2305f4e2, arg=0x42020d40
gplh_handler: pin12: pinset: c callback=0x23060808
gplh_enable: pin12: Disabling callback=0x23060808 handle=0x4201d1a0
gplh_enable: pin12: Detaching handle=0x4201d1a0
bl602_expander_detach: Detach callback for gpio=12, callback=0x2305f4e2, arg=0x42020d40
gplh_attach: pin12: callback=0
gplh_read: pin12: value=0x42021aef
bl602_expander_readpin: pin=12, value=1
  Verify:        Value=1</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander#test-push-button">(See the Complete Log)</a></p>
<h2 id="test-lorawan"><a href="#test-lorawan">7.3 Test LoRaWAN</a></h2>
<p>TODO</p>
<p>BL602 GPIO Expander tested OK with LoRaWAN Test App‚Ä¶</p>
<p>(With ‚ÄúGPIO Informational Output‚Äù logging disabled: <code>kconfig-tweak --disable CONFIG_DEBUG_GPIO_INFO</code>)</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_expander_direction: Unsupported direction: pin=10, direction=IN
bl602_expander_option: ERROR: Unsupported interrupt: 0, pin=10
bl602_expander_direction: Unsupported direction: pin=20, direction=OUT
bl602_expander_direction: Unsupported direction: pin=3, direction=OUT
bl602_expander_direction: Unsupported direction: pin=21, direction=OUT
bl602_expander_direction: Unsupported direction: pin=15, direction=OUT
bl602_expander_direction: Unsupported direction: pin=14, direction=OUT
bl602_expander_option: Unsupported interrupt both edge: pin=9
gplh_enable: WARNING: pin9: Already detached
bl602_expander_option: Unsupported interrupt both edge: pin=12
gplh_enable: WARNING: pin12: Already detached
bl602_expander_option: Unsupported interrupt both edge: pin=19
gplh_enable: WARNING: pin19: Already detached
cst816s_register: path=/dev/input0, addr=21
cst816s_register: Driver registered

NuttShell (NSH) NuttX-10.3.0-RC0

nsh&gt; uname -a
NuttX 10.3.0-RC0 cf01770616 Apr 24 2022 17:57:00 risc-v bl602evb

nsh&gt; ls /dev
/dev:
 console
 gpio10
 gpio12
 gpio14
 gpio15
 gpio19
 gpio20
 gpio21
 gpio3
 gpio9
 i2c0
 input0
 lcd0
 null
 spi0
 spitest0
 timer0
 urandom
 zero

nsh&gt; lorawan_test
init_entropy_pool
offset = 2228
temperature = 33.793369 Celsius
offset = 2228
temperature = 34.567265 Celsius
offset = 2228
temperature = 35.857086 Celsius
offset = 2228
temperature = 35.599121 Celsius

##### ===================================== ######

Application name   : lorawan_test
Application version: 1.2.0
GitHub base version: 5.0.0

##### ===================================== ######

init_event_queue
TimerInit:     0x4201c764
TimerInit:     0x4201c780
TimerInit:     0x4201c79c
TimerInit:     0x4201c818
TimerInit:     0x4201c8cc
TimerInit:     0x4201c8e8
TimerInit:     0x4201c904
TimerInit:     0x4201c920
TODO: RtcGetCalendarTime
TODO: SX126xReset
init_gpio
DIO1 pintype before=5
init_gpio: change DIO1 to Trigger GPIO gplh_enable: WARNING: pin19: Already detached
Interrupt on Rising Edge
DIO1 pintype after=8
Starting process_dio1
init_spi
SX126xSetTxParams: power=22, rampTime=7
SX126xSetPaConfig: paDutyCycle=4, hpMax=7, deviceSel=0, paLut=1
TimerInit:     0x4201b864
TimerInit:     0x4201b7d0
RadioSetModem
RadioSetModem
RadioSetPublicNetwork: public syncword=3444
RadioSleep
callout_handler: lock
process_dio1 started
process_dio1: event=0x4201b88c
TODO: EepromMcuReadBuffer
TODO: EepromMcuReadBuffer
TODO: EepromMcuReadBuffer
TODO: EepromMcuReadBuffer
TODO: EepromMcuReadBuffer
TODO: EepromMcuReadBuffer
TODO: EepromMcuReadBuffer
TODO: EepromMcuReadBuffer
RadioSetModem
RadioSetPublicNetwork: public syncword=3444
DevEui      : 4B-C1-5E-E7-37-7B-B1-5B
JoinEui     : 00-00-00-00-00-00-00-00
Pin         : 00-00-00-00

TimerInit:     0x4201c3bc
TimerInit:     0x4201c3d8
TimerInit:     0x4201c29c
TODO: RtcGetCalendarTime
TODO: RtcBkupRead
TODO: RtcBkupRead
RadioSetChannel: freq=923200000
RadioSetTxConfig: modem=1, power=13, fdev=0, bandwidth=0, datarate=10, coderate=1, preambleLen=8, fixLen=0, crcOn=1, freqHopOn=0, hopPeriod=0, iqInverted=0, timeout=4000
RadioSetTxConfig: SpreadingFactor=10, Bandwidth=4, CodingRate=1, LowDatarateOptimize=0, PreambleLength=8, HeaderType=0, PayloadLength=255, CrcMode=1, InvertIQ=0
RadioStandby
RadioSetModem
SX126xSetTxParams: power=13, rampTime=7
SX126xSetPaConfig: paDutyCycle=4, hpMax=7, deviceSel=0, paLut=1
SecureElementRandomNumber: 0x351affa5
RadioSend: size=23
00 00 00 00 00 00 00 00 00 5b b1 7b 37 e7 5e c1 4b a5 ff 18 96 ae 76
RadioSend: PreambleLength=8, HeaderType=0, PayloadLength=23, CrcMode=1, InvertIQ=0
TimerStop:     0x4201b864
TimerStart2:   0x4201b864, 4000 ms
callout_reset: evq=0x420131a8, ev=0x4201b864

##### =========== MLME-Request ============ ######
#####               MLME_JOIN               ######
##### ===================================== ######
STATUS      : OK
StartTxProcess
TimerInit:     0x42015b08
TimerSetValue: 0x42015b08, 42249 ms
OnTxTimerEvent: timeout in 42249 ms, event=0
TimerStop:     0x42015b08
TimerSetValue: 0x42015b08, 42249 ms
TimerStart:    0x42015b08
TimerStop:     0x42015b08
TimerStart2:   0x42015b08, 42249 ms
callout_reset: evq=0x420131a8, ev=0x42015b08
handle_event_queue
DIO1 add event
handle_event_queue: ev=0x4201b88c
RadioOnDioIrq
RadioIrqProcess
IRQ_TX_DONE
TimerStop:     0x4201b864
TODO: RtcGetCalendarTime
TODO: RtcBkupRead
RadioOnDioIrq
RadioIrqProcess
RadioSleep
TimerSetValue: 0x4201c780, 4988 ms
TimerStart:    0x4201c780
TimerStop:     0x4201c780
TimerStart2:   0x4201c780, 4988 ms
callout_reset: evq=0x420131a8, ev=0x4201c780
TimerSetValue: 0x4201c79c, 5988 ms
TimerStart:    0x4201c79c
TimerStop:     0x4201c79c
TimerStart2:   0x4201c79c, 5988 ms
callout_reset: evq=0x420131a8, ev=0x4201c79c
TODO: RtcGetCalendarTime
callout_handler: unlock
callout_handler: evq=0x420131a8, ev=0x4201c780
callout_handler: lock
handle_event_queue: ev=0x4201c780
TimerStop:     0x4201c780
RadioStandby
RadioSetChannel: freq=923200000
RadioSetRxConfig
RadioStandby
RadioSetModem
RadioSetRxConfig done
RadioRx
TimerStop:     0x4201b7d0
TimerStart2:   0x4201b7d0, 3000 ms
callout_reset: evq=0x420131a8, ev=0x4201b7d0
RadioOnDioIrq
RadioIrqProcess
DIO1 add event
handle_event_queue: ev=0x4201b88c
RadioOnDioIrq
RadioIrqProcess
IRQ_PREAMBLE_DETECTED
RadioOnDioIrq
RadioIrqProcess
DIO1 add event
handle_event_queue: ev=0x4201b88c
RadioOnDioIrq
RadioIrqProcess
IRQ_HEADER_VALID
RadioOnDioIrq
RadioIrqProcess
DIO1 add event
handle_event_queue: ev=0x4201b88c
RadioOnDioIrq
RadioIrqProcess
IRQ_RX_DONE
TimerStop:     0x4201b7d0
RadioOnDioIrq
RadioIrqProcess
RadioSleep
TimerStop:     0x4201c79c
OnTxData

##### =========== MLME-Confirm ============ ######
STATUS      : OK
OnJoinRequest
##### ===========   JOINED     ============ ######

OTAA

DevAddr     :  014C9548


DATA RATE   : DR_2

TODO: EepromMcuWriteBuffer
TODO: EepromMcuWriteBuffer
TODO: EepromMcuWriteBuffer
TODO: EepromMcuWriteBuffer
TODO: EepromMcuWriteBuffer
TODO: EepromMcuWriteBuffer
UplinkProcess
PrepareTxFrame: Transmit to LoRaWAN: Hi NuttX (9 bytes)
PrepareTxFrame: status=0, maxSize=11, currentSize=11
LmHandlerSend: Data frame
TODO: RtcGetCalendarTime
TODO: RtcBkupRead
RadioSetChannel: freq=923400000
RadioSetTxConfig: modem=1, power=13, fdev=0, bandwidth=0, datarate=9, coderate=1, preambleLen=8, fixLen=0, crcOn=1, freqHopOn=0, hopPeriod=0, iqInverted=0, timeout=4000
RadioSetTxConfig: SpreadingFactor=9, Bandwidth=4, CodingRate=1, LowDatarateOptimize=0, PreambleLength=8, HeaderType=0, PayloadLength=128, CrcMode=1, InvertIQ=0
RadioStandby
RadioSetModem
SX126xSetTxParams: power=13, rampTime=7
SX126xSetPaConfig: paDutyCycle=4, hpMax=7, deviceSel=0, paLut=1
RadioSend: size=22
40 48 95 4c 01 00 01 00 01 99 51 07 77 91 ab d5 56 9b 23 3b 29 16
RadioSend: PreambleLength=8, HeaderType=0, PayloadLength=22, CrcMode=1, InvertIQ=0
TimerStop:     0x4201b864
TimerStart2:   0x4201b864, 4000 ms
callout_reset: evq=0x420131a8, ev=0x4201b864

##### =========== MCPS-Request ============ ######
#####           MCPS_UNCONFIRMED            ######
##### ===================================== ######
STATUS      : OK
PrepareTxFrame: Transmit OK
DIO1 add event
handle_event_queue: ev=0x4201b88c
RadioOnDioIrq
RadioIrqProcess
IRQ_TX_DONE
TimerStop:     0x4201b864
TODO: RtcGetCalendarTime
TODO: RtcBkupRead
RadioOnDioIrq
RadioIrqProcess
RadioSleep
TimerSetValue: 0x4201c780, 980 ms
TimerStart:    0x4201c780
TimerStop:     0x4201c780
TimerStart2:   0x4201c780, 980 ms
callout_reset: evq=0x420131a8, ev=0x4201c780
TimerSetValue: 0x4201c79c, 1988 ms
TimerStart:    0x4201c79c
TimerStop:     0x4201c79c
TimerStart2:   0x4201c79c, 1988 ms
callout_reset: evq=0x420131a8, ev=0x4201c79c
TODO: RtcGetCalendarTime
callout_handler: unlock
callout_handler: evq=0x420131a8, ev=0x4201c780
callout_handler: lock
handle_event_queue: ev=0x4201c780
TimerStop:     0x4201c780
RadioStandby
RadioSetChannel: freq=923400000
RadioSetRxConfig
RadioStandby
RadioSetModem
RadioSetRxConfig done
RadioRx
TimerStop:     0x4201b7d0
TimerStart2:   0x4201b7d0, 3000 ms
callout_reset: evq=0x420131a8, ev=0x4201b7d0
RadioOnDioIrq
RadioIrqProcess
DIO1 add event
handle_event_queue: ev=0x4201b88c
RadioOnDioIrq
RadioIrqProcess
IRQ_RX_TX_TIMEOUT
TimerStop:     0x4201b7d0
RadioOnDioIrq
RadioIrqProcess
RadioSleep
TimerStop:     0x4201c79c
TimerStop:     0x4201c764
OnTxData

##### =========== MCPS-Confirm ============ ######
STATUS      : OK

##### =====   UPLINK FRAME        1   ===== ######

CLASS       : A

TX PORT     : 1
TX DATA     : UNCONFIRMED
48 69 20 4E 75 74 74 58 00

DATA RATE   : DR_3
U/L FREQ    : 923400000
TX POWER    : 0
CHANNEL MASK: 0003

TODO: EepromMcuWriteBuffer
TODO: EepromMcuWriteBuffer
UplinkProcess
callout_handler: unlock
callout_handler: evq=0x420131a8, ev=0x42015b08
callout_handler: lock
handle_event_queue: ev=0x42015b08
OnTxTimerEvent: timeout in 42249 ms, event=0x42015b08
TimerStop:     0x42015b08
TimerSetValue: 0x42015b08, 42249 ms
TimerStart:    0x42015b08
TimerStop:     0x42015b08
TimerStart2:   0x42015b08, 42249 ms
callout_reset: evq=0x420131a8, ev=0x42015b08
RadioOnDioIrq
RadioIrqProcess
UplinkProcess
PrepareTxFrame: Transmit to LoRaWAN: Hi NuttX (9 bytes)
PrepareTxFrame: status=0, maxSize=53, currentSize=53
LmHandlerSend: Data frame
TODO: RtcGetCalendarTime
TODO: RtcBkupRead
RadioSetChannel: freq=923200000
RadioSetTxConfig: modem=1, power=13, fdev=0, bandwidth=0, datarate=9, coderate=1, preambleLen=8, fixLen=0, crcOn=1, freqHopOn=0, hopPeriod=0, iqInverted=0, timeout=4000
RadioSetTxConfig: SpreadingFactor=9, Bandwidth=4, CodingRate=1, LowDatarateOptimize=0, PreambleLength=8, HeaderType=0, PayloadLength=128, CcMode=1, InvertIQ=0
RadioStandby
RadioSetModem
SX126xSetTxParams: power=13, rampTime=7
SX126xSetPaConfig: paDutyCycle=4, hpMax=7, deviceSel=0, paLut=1
RadioSend: size=22
40 48 95 4c 01 00 02 00 01 2c b3 54 eb c4 e8 2c a5 04 59 aa e1 2f
RadioSend: PreambleLength=8, HeaderType=0, PayloadLength=22, CrcMode=1, InvertIQ=0
TimerStop:     0x4201b864
TimerStart2:   0x4201b864, 4000 ms
callout_reset: evq=0x420131a8, ev=0x4201b864

##### =========== MCPS-Request ============ ######
#####           MCPS_UNCONFIRMED            ######
##### ===================================== ######
STATUS      : OK
PrepareTxFrame: Transmit OK
DIO1 add event
handle_event_queue: ev=0x4201b88c
RadioOnDioIrq
RadioIrqProcess
IRQ_TX_DONE
TimerStop:     0x4201b864
TODO: RtcGetCalendarTime
TODO: RtcBkupRead
RadioOnDioIrq
RadioIrqProcess
RadioSleep
TimerSetValue: 0x4201c780, 980 ms
TimerStart:    0x4201c780
TimerStop:     0x4201c780
TimerStart2:   0x4201c780, 980 ms
callout_reset: evq=0x420131a8, ev=0x4201c780
TimerSetValue: 0x4201c79c, 1988 ms
TimerStart:    0x4201c79c
TimerStop:     0x4201c79c
TimerStart2:   0x4201c79c, 1988 ms
callout_reset: evq=0x420131a8, ev=0x4201c79c
TODO: RtcGetCalendarTime
callout_handler: unlock
callout_handler: evq=0x420131a8, ev=0x4201c780
callout_handler: lock
handle_event_queue: ev=0x4201c780
TimerStop:     0x4201c780
RadioStandby
RadioSetChannel: freq=923200000
RadioSetRxConfig
RadioStandby
RadioSetModem
RadioSetRxConfig done
RadioRx
TimerStop:     0x4201b7d0
TimerStart2:   0x4201b7d0, 3000 ms
callout_reset: evq=0x420131a8, ev=0x4201b7d0
RadioOnDioIrq
RadioIrqProcess
DIO1 add event
handle_event_queue: ev=0x4201b88c
RadioOnDioIrq
RadioIrqProcess
IRQ_RX_TX_TIMEOUT
TimerStop:     0x4201b7d0
RadioOnDioIrq
RadioIrqProcess
RadioSleep
TimerStop:     0x4201c79c
TimerStop:     0x4201c764
OnTxData

##### =========== MCPS-Confirm ============ ######
STATUS      : OK

##### =====   UPLINK FRAME        2   ===== ######

CLASS       : A

TX PORT     : 1
TX DATA     : UNCONFIRMED
48 69 20 4E 75 74 74 58 00

DATA RATE   : DR_3
U/L FREQ    : 923200000
TX POWER    : 0
CHANNEL MASK: 0003

TODO: EepromMcuWriteBuffer
TODO: EepromMcuWriteBuffer
UplinkProcess
callout_handler: unlock
callout_handler: evq=0x420131a8, ev=0x42015b08
callout_handler: lock
handle_event_queue: ev=0x42015b08
OnTxTimerEvent: timeout in 42249 ms, event=0x42015b08
TimerStop:     0x42015b08
TimerSetValue: 0x42015b08, 42249 ms
TimerStart:    0x42015b08
TimerStop:     0x42015b08
TimerStart2:   0x42015b08, 42249 ms
callout_reset: evq=0x420131a8, ev=0x42015b08
RadioOnDioIrq
RadioIrqProcess
UplinkProcess
PrepareTxFrame: Transmit to LoRaWAN: Hi NuttX (9 bytes)
PrepareTxFrame: status=0, maxSize=53, currentSize=53
LmHandlerSend: Data frame
TODO: RtcGetCalendarTime
TODO: RtcBkupRead
RadioSetChannel: freq=923400000
RadioSetTxConfig: modem=1, power=13, fdev=0, bandwidth=0, datarate=9, coderate=1, preambleLen=8, fixLen=0, crcOn=1, freqHopOn=0, hopPeriod=0, iqInverted=0, timeout=4000
RadioSetTxConfig: SpreadingFactor=9, Bandwidth=4, CodingRate=1, LowDatarateOptimize=0, PreambleLength=8, HeaderType=0, PayloadLength=128, CrcMode=1, InvertIQ=0
RadioStandby
RadioSetModem
SX126xSetTxParams: power=13, rampTime=7
SX126xSetPaConfig: paDutyCycle=4, hpMax=7, deviceSel=0, paLut=1
RadioSend: size=22
40 48 95 4c 01 00 03 00 01 67 ec 95 34 1f 0d 3e 8f f0 99 35 f9 a4
RadioSend: PreambleLength=8, HeaderType=0, PayloadLength=22, CrcMode=1, InvertIQ=0
TimerStop:     0x4201b864
TimerStart2:   0x4201b864, 4000 ms
callout_reset: evq=0x420131a8, ev=0x4201b864

##### =========== MCPS-Request ============ ######
#####           MCPS_UNCONFIRMED            ######
##### ===================================== ######
STATUS      : OK
PrepareTxFrame: Transmit OK
DIO1 add event
handle_event_queue: ev=0x4201b88c
RadioOnDioIrq
RadioIrqProcess
IRQ_TX_DONE
TimerStop:     0x4201b864
TODO: RtcGetCalendarTime
TODO: RtcBkupRead
RadioOnDioIrq
RadioIrqProcess
RadioSleep
TimerSetValue: 0x4201c780, 980 ms
TimerStart:    0x4201c780
TimerStop:     0x4201c780
TimerStart2:   0x4201c780, 980 ms
callout_reset: evq=0x420131a8, ev=0x4201c780
TimerSetValue: 0x4201c79c, 1988 ms
TimerStart:    0x4201c79c
TimerStop:     0x4201c79c
TimerStart2:   0x4201c79c, 1988 ms
callout_reset: evq=0x420131a8, ev=0x4201c79c
TODO: RtcGetCalendarTime
callout_handler: unlock
callout_handler: evq=0x420131a8, ev=0x4201c780
callout_handler: lock
handle_event_queue: ev=0x4201c780
TimerStop:     0x4201c780
RadioStandby
RadioSetChannel: freq=923400000
RadioSetRxConfig
RadioStandby
RadioSetModem
RadioSetRxConfig done
RadioRx
TimerStop:     0x4201b7d0
TimerStart2:   0x4201b7d0, 3000 ms
callout_reset: evq=0x420131a8, ev=0x4201b7d0
RadioOnDioIrq
RadioIrqProcess
DIO1 add event
handle_event_queue: ev=0x4201b88c
RadioOnDioIrq
RadioIrqProcess
IRQ_RX_TX_TIMEOUT
TimerStop:     0x4201b7d0
RadioOnDioIrq
RadioIrqProcess
RadioSleep
TimerStop:     0x4201c79c
TimerStop:     0x4201c764
OnTxData

##### =========== MCPS-Confirm ============ ######
STATUS      : OK

##### =====   UPLINK FRAME        3   ===== ######

CLASS       : A

TX PORT     : 1
TX DATA     : UNCONFIRMED
48 69 20 4E 75 74 74 58 00

DATA RATE   : DR_3
U/L FREQ    : 923400000
TX POWER    : 0
CHANNEL MASK: 0003

TODO: EepromMcuWriteBuffer
TODO: EepromMcuWriteBuffer
UplinkProcess</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander#test-lorawan">(See the Complete Log)</a></p>
<h1 id="whats-next"><a href="#whats-next">8 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>I hope this article has provided everything you need to get started on creating <strong>your own NuttX Drivers and Apps</strong> on PineDio Stack.</p>
<p>Lemme know what you‚Äôre building with PineDio Stack!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/expander.md"><strong><code>lupyuen.github.io/src/expander.md</code></strong></a></p>
<h1 id="notes"><a href="#notes">9 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1518352162966802432"><strong>this Twitter Thread</strong></a></li>
</ol>
<h1 id="appendix-validate-pin-function"><a href="#appendix-validate-pin-function">10 Appendix: Validate Pin Function</a></h1>
<p>TODO</p>
<p>In future, our BL602 GPIO Expander will validate that the SPI / I2C / UART Pin Functions are correctly assigned to the GPIO Pin Numbers‚Ä¶</p>
<ul>
<li><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL602_RM/en/BL602_BL604_RM_1.2_en.pdf">BL602 Reference Manual (Table 3.1 ‚ÄúPin Description‚Äù, Page 26)</a></li>
</ul>
<p>For example: SPI MISO must be either GPIO 0, 4, 8, 12, 16 or 20.</p>
<p>Any other GPIO Pin for SPI MISO will be disallowed by our BL602 GPIO Expander. (And fail at startup)</p>
<p><em>But the BL602 Pinset only tells us the Function Group (like SPI), not the specific Pin Function (like MISO)?</em></p>
<p>Yeah we might have to make the Pin Functions position-dependent. So SPI Pins will always be listed in this sequence: CS, MOSI, MISO, then CLK.</p>
<p>Here‚Äôs how it might look‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* Other Pins for BL602 GPIO Expander (For Validation Only) */

static const gpio_pinset_t bl602_other_pins[] =
{
#ifdef BOARD_UART_0_RX_PIN
  RX_TX
  (
    BOARD_UART_0_RX_PIN,
    BOARD_UART_0_TX_PIN
  ),
#endif  /* BOARD_UART_0_RX_PIN */

#ifdef BOARD_UART_1_RX_PIN
  RX_TX
  (
    BOARD_UART_1_RX_PIN,
    BOARD_UART_1_TX_PIN
  ),
#endif  /* BOARD_UART_1_RX_PIN */

#ifdef BOARD_PWM_CH0_PIN
  CH(
    BOARD_PWM_CH0_PIN
  ),
#endif  /* BOARD_PWM_CH0_PIN */
...
#ifdef BOARD_I2C_SCL
  SCL_SDA
  (
    BOARD_I2C_SCL, 
    BOARD_I2C_SDA 
  ),
#endif  /* BOARD_I2C_SCL */

#ifdef BOARD_SPI_CS
  CS_MOSI_MISO_CLK
  (
    BOARD_SPI_CS, 
    BOARD_SPI_MOSI, 
    BOARD_SPI_MISO, 
    BOARD_SPI_CLK
  ),
#endif  /* BOARD_SPI_CS */
};</code></pre></div>
<p>(Which looks neater with the clustering by Function Group)</p>
<p>The macros are simple passthroughs‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define CH(ch)            ch
#define RX_TX(rx, tx)     rx,  tx
#define SCL_SDA(scl, sda) scl, sda
#define CS_MOSI_MISO_CLK(cs, mosi, miso, clk) cs, mosi, miso, clk</code></pre></div>
<p>At startup, GPIO Expander iterates through the pins and discovers that <code>BOARD_SPI_MISO</code> is the third pin (MISO) of the SPI Function Group. So it verifies that it‚Äôs either GPIO 0, 4, 8, 12, 16 or 20.</p>
<p>Are devs OK with this? Lemme know what you think!</p>
<p><em>Can we validate the Pin Functions at compile-time?</em></p>
<p>Possibly. We can enumerate all valid combinations of Pin Functions and Pin Numbers‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  MISO can be either GPIO 0, 4, 8, 12, 16 or 20
#define SPI_MISO_PIN0  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN0)
#define SPI_MISO_PIN4  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN4)
#define SPI_MISO_PIN8  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN8)
#define SPI_MISO_PIN12 (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN12)
#define SPI_MISO_PIN16 (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN16)
#define SPI_MISO_PIN20 (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN20)</code></pre></div>
<p>And we select the desired combination for each pin‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Select GPIO0 as MISO
#define BOARD_SPI_MISO SPI_MISO_PIN0</code></pre></div>
<p>To check whether the Pin Numbers are unique, we would still need GPIO Expander to do this at runtime.</p>
<p><em>But shouldn‚Äôt the pins be defined in Kconfig / menuconfig?</em></p>
<p>Perhaps. NuttX on ESP32 uses Kconfig / menuconfig to define the pins. <a href="https://github.com/apache/incubator-nuttx/blob/master/arch/xtensa/src/esp32/Kconfig#L938-L984">(See this)</a></p>
<p>Then we would need GPIO Expander to validate the Pin Functions at runtime.</p>
<p><a href="https://mastodon.social/@Ralim/108201458447291513"><strong>@Ralim</strong></a> has an interesting suggestion‚Ä¶</p>
<blockquote>
<p>If each pin can only be used once, could we flip the arrignment matrix and instead have it always have an entry for each pin, which is either a selected value or hi-z by default; then use kconfig rules to prevent collisions ?</p>
</blockquote>
<p>Which begs the question: Shouldn‚Äôt we do the same for NuttX on ESP32? What about other NuttX platforms? ü§î</p>
<p>TODO: Pins with multiple functions</p>
<p>TODO1</p>
<p><img src="https://lupyuen.github.io/images/bl602-pins1a.png" alt="" /></p>
<h1 id="appendix-status"><a href="#appendix-status">11 Appendix: Status</a></h1>
<p>TODO</p>
<p>GPIO Expander calls <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L58-L140"><code>bl602_configgpio</code></a>, <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L218-L230"><code>bl602_gpioread</code></a> and <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L197-L216"><code>bl602_gpiowrite</code></a> to configure / read / write GPIOs</p>
<p>Warning: <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c">BL602 EVB GPIO Driver</a> will be disabled when we enable GPIO Expander.</p>
<p>(Because GPIO Expander needs GPIO Lower Half which conflicts with BL602 EVB GPIO Driver)</p>
<p>GPIO Expander verifies that the GPIO, SPI, I2C and UART Pins don‚Äôt reuse the same GPIO.</p>
<p>Robert Lipe has an excellent article that explains the current limitations of the BL602 EVB GPIO Driver (and why we need the GPIO Expander)‚Ä¶</p>
<ul>
<li><a href="https://www.robertlipe.com/buttons-on-bl602-nuttx/"><strong>‚ÄúButtons on BL602 NuttX‚Äù</strong></a></li>
</ul>
<p>Here‚Äôs the current status‚Ä¶</p>
<ul>
<li>
<p>Tested OK with GPIO Interrupts from Touch Panel and LVGL Test App <code>lvgltest</code></p>
<p>(With <code>IOEP_ATTACH</code> in <code>cst816s_register</code>)</p>
</li>
<li>
<p>Tested OK with Push Button</p>
<p>(With <code>IOEP_ATTACH</code> in <code>bl602_bringup</code>)</p>
</li>
<li>
<p>Tested OK with Push Button GPIO Command: <code>gpio -t 8 -w 1 /dev/gpio12</code></p>
<p>(Comment out <code>IOEP_ATTACH</code> in <code>bl602_bringup</code>)</p>
</li>
<li>
<p>Tested OK with LoRaWAN Test App <code>lorawan_test</code></p>
<p>(With ‚ÄúGPIO Informational Output‚Äù logging disabled)</p>
</li>
<li>
<p>SX1262 Library is now configured by Kconfig / menuconfig to access <code>/dev/gpio10</code>, <code>/dev/gpio15</code>, <code>/dev/gpio19</code> (instead of <code>dev/gpio0</code>, <code>/dev/gpio1</code>, <code>/dev/gpio2</code>). </p>
<p>In menuconfig: Library Routines ‚Üí Semtech SX1262 Library</p>
<ul>
<li>SPI Test device path</li>
<li>Chip Select device path </li>
<li>Busy device path</li>
<li>DIO1 device path</li>
</ul>
</li>
<li>
<p>Logging for SX1262 Library is now disabled by default and can be configured by Kconfig / menuconfig.</p>
<p>In menuconfig: Library Routines ‚Üí Semtech SX1262 Library ‚Üí Logging ‚Üí Debugging</p>
</li>
<li>
<p>Logging for SPI Test Driver has been moved from ‚ÄúEnable Informational Debug Output‚Äù to ‚ÄúSPI Informational Output‚Äù</p>
</li>
</ul>
<p><strong>TODO</strong>: GPIO Expander will check that the SPI / I2C / UART Pin Functions are correctly defined (e.g. MISO vs MOSI)</p>
<h1 id="appendix-configure-gpio"><a href="#appendix-configure-gpio">12 Appendix: Configure GPIO</a></h1>
<p>TODO</p>
<p>At startup our BL602 GPIO Expander configures the GPIO Input / Output / Interrupt Pins by calling <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L58-L140"><code>bl602_configgpio</code></a> and <code>gpio_lower_half</code> (which registers ‚Äú/dev/gpioN‚Äù)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Initialise the BL602 GPIO Expander
FAR struct ioexpander_dev_s *bl602_expander_initialize(
  const gpio_pinset_t *gpio_inputs,
  uint8_t gpio_input_count,
  const gpio_pinset_t *gpio_outputs,
  uint8_t gpio_output_count,
  const gpio_pinset_t *gpio_interrupts,
  uint8_t gpio_interrupt_count,
  const gpio_pinset_t *other_pins,
  uint8_t other_pin_count)
{
  int i;
  int ret;
  uint8_t pin;
  bool gpio_is_used[CONFIG_IOEXPANDER_NPINS];
  FAR struct bl602_expander_dev_s *priv;

  DEBUGASSERT(gpio_input_count + gpio_output_count + gpio_interrupt_count +
    other_pin_count &lt;= CONFIG_IOEXPANDER_NPINS);

#ifdef CONFIG_BL602_EXPANDER_MULTIPLE
  /* Allocate the device state structure */

  priv = (FAR struct bl602_expander_dev_s *)kmm_zalloc(sizeof(struct bl602_expander_dev_s));
  if (!priv)
    {
      gpioerr(&quot;ERROR: Failed to allocate driver instance\n&quot;);
      return NULL;
    }
#else
  /* Use the one-and-only I/O Expander driver instance */

  priv = &amp;g_skel;
#endif

  /* Initialize the device state structure */

  priv-&gt;dev.ops = &amp;g_bl602_expander_ops;
  nxsem_init(&amp;priv-&gt;exclsem, 0, 1);

#ifdef CONFIG_IOEXPANDER_INT_ENABLE
  /* Disable GPIO interrupts */

  ret = bl602_expander_irq_enable(false);
  if (ret &lt; 0)
    {
      gpioerr(&quot;ERROR: Failed to disable GPIO interrupts\n&quot;);
      kmm_free(priv);
      return NULL;
    }

  /* Disable interrupts for all GPIO Pins */

  for (pin = 0; pin &lt; CONFIG_IOEXPANDER_NPINS; pin++)
    {
      bl602_expander_intmask(pin, 1);
    }

  /* Attach the I/O expander interrupt handler and enable interrupts */

  irq_attach(BL602_IRQ_GPIO_INT0, bl602_expander_interrupt, priv);

  ret = bl602_expander_irq_enable(true);
  if (ret &lt; 0)
    {
      gpioerr(&quot;ERROR: Failed to enable GPIO interrupts\n&quot;);
      kmm_free(priv);
      return NULL;
    }
#endif

  /* Mark the GPIOs in use */

  memset(gpio_is_used, 0, sizeof(gpio_is_used));

  /* Configure and register the GPIO Inputs */

  for (i = 0; i &lt; gpio_input_count; i++)
    {
      gpio_pinset_t pinset = gpio_inputs[i];
      uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;

      DEBUGASSERT(gpio_pin &lt; CONFIG_IOEXPANDER_NPINS);
      if (gpio_is_used[gpio_pin])
        {
          gpioerr(&quot;ERROR: GPIO pin %d is already in use\n&quot;, gpio_pin);
          kmm_free(priv);
          return NULL;
        }
      gpio_is_used[gpio_pin] = true;

      ret = bl602_configgpio(pinset);
      DEBUGASSERT(ret == OK);
      gpio_lower_half(&amp;priv-&gt;dev, gpio_pin, GPIO_INPUT_PIN, gpio_pin);
    }

  /* Configure and register the GPIO Outputs */

  for (i = 0; i &lt; gpio_output_count; i++)
    {
      gpio_pinset_t pinset = gpio_outputs[i];
      uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;

      DEBUGASSERT(gpio_pin &lt; CONFIG_IOEXPANDER_NPINS);
      if (gpio_is_used[gpio_pin])
        {
          gpioerr(&quot;ERROR: GPIO pin %d is already in use\n&quot;, gpio_pin);
          kmm_free(priv);
          return NULL;
        }
      gpio_is_used[gpio_pin] = true;

      ret = bl602_configgpio(pinset);
      DEBUGASSERT(ret == OK);
      gpio_lower_half(&amp;priv-&gt;dev, gpio_pin, GPIO_OUTPUT_PIN, gpio_pin);
    }

  /* Configure and register the GPIO Interrupts */

  for (i = 0; i &lt; gpio_interrupt_count; i++)
    {
      gpio_pinset_t pinset = gpio_interrupts[i];
      uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;

      DEBUGASSERT(gpio_pin &lt; CONFIG_IOEXPANDER_NPINS);
      if (gpio_is_used[gpio_pin])
        {
          gpioerr(&quot;ERROR: GPIO pin %d is already in use\n&quot;, gpio_pin);
          kmm_free(priv);
          return NULL;
        }
      gpio_is_used[gpio_pin] = true;

      ret = bl602_configgpio(pinset);
      DEBUGASSERT(ret == OK);
      gpio_lower_half(&amp;priv-&gt;dev, gpio_pin, GPIO_INTERRUPT_PIN, gpio_pin);
    }

  /* Validate the other pins (I2C, SPI, etc) */

  for (i = 0; i &lt; other_pin_count; i++)
    {
      gpio_pinset_t pinset = other_pins[i];
      uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;

      DEBUGASSERT(gpio_pin &lt; CONFIG_IOEXPANDER_NPINS);
      if (gpio_is_used[gpio_pin])
        {
          gpioerr(&quot;ERROR: GPIO pin %d is already in use\n&quot;, gpio_pin);
          kmm_free(priv);
          return NULL;
        }
      gpio_is_used[gpio_pin] = true;
    }

  /* TODO: Validate the Pin Functions (e.g. MISO vs MOSI) */

  return &amp;priv-&gt;dev;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L956-L1121">(Source)</a></p>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L164-L197">(<code>bl602_expander_intmask</code> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L301-L325">(<code>bl602_expander_irq_enable</code> is defined here)</a></p>
<p>TODO7</p>
<p><img src="https://lupyuen.github.io/images/expander-code6a.png" alt="" /></p>
<h1 id="appendix-set-gpio-options"><a href="#appendix-set-gpio-options">13 Appendix: Set GPIO Options</a></h1>
<p>TODO</p>
<p>Our GPIO Expander will configure the GPIO Interrupts: Rising Edge Trigger vs Falling Edge Trigger‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Set GPIO Options
static int bl602_expander_option(FAR struct ioexpander_dev_s *dev, uint8_t pin,
                       int opt, FAR void *value)
{
  FAR struct bl602_expander_dev_s *priv = (FAR struct bl602_expander_dev_s *)dev;
  int ret = -ENOSYS;

  gpioinfo(&quot;pin=%u, option=%u, value=%p\n&quot;, pin, opt, value);

  DEBUGASSERT(priv != NULL);

  /* Get exclusive access to the I/O Expander */

  ret = bl602_expander_lock(priv);
  if (ret &lt; 0)
    {
      return ret;
    }

  /* Handle each option */

  switch(opt)
    {
      case IOEXPANDER_OPTION_INTCFG: /* Interrupt Trigger */
        {
          switch((uint32_t)value)
            {
              case IOEXPANDER_VAL_RISING: /* Rising Edge */
                {
                  gpioinfo(&quot;Rising edge: pin=%u\n&quot;, pin);
                  bl602_expander_set_intmod(pin, 1, GLB_GPIO_INT_TRIG_POS_PULSE);
                  break;
                }

              case IOEXPANDER_VAL_FALLING: /* Falling Edge */
                {
                  gpioinfo(&quot;Falling edge: pin=%u\n&quot;, pin);
                  bl602_expander_set_intmod(pin, 1, GLB_GPIO_INT_TRIG_NEG_PULSE);
                  break;
                }

              case IOEXPANDER_VAL_BOTH: /* Both Edge (Unimplemented) */
                {
                  gpioinfo(&quot;WARNING: Unimplemented interrupt both edge: pin=%u\n&quot;, pin);
                  break;
                }

              case IOEXPANDER_VAL_DISABLE: /* Disable (Unimplemented) */
                {
                  gpioinfo(&quot;WARNING: Unimplemented disable interrupt, use detach instead: pin=%u\n&quot;, pin);
                  break;
                }

              default: /* Unsupported Interrupt */
                {
                  gpioerr(&quot;ERROR: Unsupported interrupt: %d, pin=%u\n&quot;, value, pin);
                  ret = -EINVAL;
                  break;
                }
            }
          break;
        }

      default: /* Unsupported Option */
        {
          gpioerr(&quot;ERROR: Unsupported option: %d, pin=%u\n&quot;, opt, pin);
          ret = -ENOSYS;
        }
    }

  /* Unlock the I/O Expander */

  bl602_expander_unlock(priv);
  return ret;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L456-L548">(Source)</a></p>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L198-L246">(<code>bl602_expander_set_intmod</code> is defined here)</a></p>
<p>TODO8</p>
<p><img src="https://lupyuen.github.io/images/expander-code7a.png" alt="" /></p>
<h1 id="appendix-read-gpio"><a href="#appendix-read-gpio">14 Appendix: Read GPIO</a></h1>
<p>TODO</p>
<p>Our GPIO Expander calls the BL602 GPIO Driver to read GPIO Inputs‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Read the GPIO Input Pin
static int bl602_expander_readpin(FAR struct ioexpander_dev_s *dev, 
                                  uint8_t pin,
                                  FAR bool *value)
{
  FAR struct bl602_expander_dev_s *priv = (FAR struct bl602_expander_dev_s *)dev;
  int ret;

  DEBUGASSERT(priv != NULL &amp;&amp; pin &lt; CONFIG_IOEXPANDER_NPINS &amp;&amp;
              value != NULL);

  /* Get exclusive access to the I/O Expander */

  ret = bl602_expander_lock(priv);
  if (ret &lt; 0)
    {
      return ret;
    }

  /* Read the pin value. Warning: Pin Number passed as BL602 Pinset */

  *value = bl602_gpioread(pin &lt;&lt; GPIO_PIN_SHIFT);

  /* Unlock the I/O Expander */

  bl602_expander_unlock(priv);
  gpioinfo(&quot;pin=%u, value=%u\n&quot;, pin, *value);
  return ret;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L596-L642">(Source)</a></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L218-L230">(<code>bl602_gpioread</code> comes from the BL602 GPIO Driver)</a></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/expander-code8a.png" alt="" /></p>
<h1 id="appendix-write-gpio"><a href="#appendix-write-gpio">15 Appendix: Write GPIO</a></h1>
<p>TODO</p>
<p>Our GPIO Expander calls the BL602 GPIO Driver to write GPIO Outputs ‚Ä¶ Wonder what happens if we flip between Input and Output ‚Ä¶ Like for PineDio Stack‚Äôs Push Button / Vibrator ü§î</p>
<div class="example-wrap"><pre class="language-c"><code>//  Write to the GPIO Output Pin
static int bl602_expander_writepin(FAR struct ioexpander_dev_s *dev,
                                   uint8_t pin,
                                   bool value)
{
  FAR struct bl602_expander_dev_s *priv = (FAR struct bl602_expander_dev_s *)dev;
  int ret;

  gpioinfo(&quot;pin=%u, value=%u\n&quot;, pin, value);

  DEBUGASSERT(priv != NULL &amp;&amp; pin &lt; CONFIG_IOEXPANDER_NPINS);

  /* Get exclusive access to the I/O Expander */

  ret = bl602_expander_lock(priv);
  if (ret &lt; 0)
    {
      return ret;
    }

  /* Write the pin value. Warning: Pin Number passed as BL602 Pinset */

  bl602_gpiowrite(pin &lt;&lt; GPIO_PIN_SHIFT, value);

  /* Unlock the I/O Expander */

  bl602_expander_unlock(priv);
  return ret;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L550-L594">(Source)</a></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L197-L216">(<code>bl602_gpiowrite</code> comes from the BL602 GPIO Driver)</a></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/expander-code9a.png" alt="" /></p>
<h1 id="appendix-attach-gpio-interrupt"><a href="#appendix-attach-gpio-interrupt">16 Appendix: Attach GPIO Interrupt</a></h1>
<p>TODO</p>
<p>Here‚Äôs how our BL602 GPIO Expander attaches a GPIO Interrupt Handler‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Attach a Callback Function to a GPIO Interrupt
#ifdef CONFIG_IOEXPANDER_INT_ENABLE
static FAR void *bl602_expander_attach(FAR struct ioexpander_dev_s *dev,
                       ioe_pinset_t pinset,
                       ioe_callback_t callback, FAR void *arg)
{
  FAR struct bl602_expander_dev_s *priv = (FAR struct bl602_expander_dev_s *)dev;
  FAR struct bl602_expander_callback_s *cb = NULL;
  int ret = 0;

  gpioinfo(&quot;pinset=%x, callback=%p, arg=%p\n&quot;, pinset, callback, arg);
  DEBUGASSERT(priv != NULL);

  /* Get exclusive access to the I/O Expander */

  ret = bl602_expander_lock(priv);
  if (ret &lt; 0)
    {
      gpioerr(&quot;ERROR: Lock failed\n&quot;);
      return NULL;
    }

  /* Handle each GPIO Pin in the pinset */

  for (uint8_t gpio_pin = 0; gpio_pin &lt; CONFIG_IOEXPANDER_NPINS; gpio_pin++)
    {
      /* If GPIO Pin is set in the pinset... */

      if (pinset &amp; ((ioe_pinset_t)1 &lt;&lt; gpio_pin))
        {
          cb = &amp;priv-&gt;cb[gpio_pin];

          if (callback == NULL) /* Detach Callback */
            {
              /* Disable GPIO Interrupt and clear Interrupt Callback */

              gpioinfo(&quot;Detach callback for gpio=%d, callback=%p, arg=%p\n&quot;,
                      cb-&gt;pinset, cb-&gt;cbfunc, cb-&gt;cbarg);
              bl602_expander_intmask(gpio_pin, 1);
              cb-&gt;pinset = 0;
              cb-&gt;cbfunc = NULL;
              cb-&gt;cbarg  = NULL;
              ret = 0;
            }
          else if (cb-&gt;cbfunc == NULL) /* Attach Callback */
            {
              /* Set Interrupt Callback and enable GPIO Interrupt */

              gpioinfo(&quot;Attach callback for gpio=%d, callback=%p, arg=%p\n&quot;, 
                      gpio_pin, callback, arg);
              cb-&gt;pinset = gpio_pin;
              cb-&gt;cbfunc = callback;
              cb-&gt;cbarg  = arg;
              bl602_expander_intmask(gpio_pin, 0);
              ret = 0;
            }
          else /* Callback already attached */
            {
              gpioerr(&quot;ERROR: GPIO %d already attached\n&quot;, gpio_pin);
              ret = -EBUSY;
            }

          /* Only 1 GPIO Pin allowed */

          DEBUGASSERT(pinset == ((ioe_pinset_t)1 &lt;&lt; gpio_pin));
          break;
        }
    }

  /* Unlock the I/O Expander and return the handle */

  bl602_expander_unlock(priv);
  return (ret == 0) ? cb : NULL;
}
#endif</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L814-L906">(Source)</a></p>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L164-L197">(<code>bl602_expander_intmask</code> is defined here)</a></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/expander-code10a.png" alt="" /></p>
<h1 id="appendix-detach-gpio-interrupt"><a href="#appendix-detach-gpio-interrupt">17 Appendix: Detach GPIO Interrupt</a></h1>
<p>TODO</p>
<p>Here‚Äôs how our BL602 GPIO Expander detaches a GPIO Interrupt Handler‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Detach and disable a GPIO Interrupt
#ifdef CONFIG_IOEXPANDER_INT_ENABLE
static int bl602_expander_detach(FAR struct ioexpander_dev_s *dev, FAR void *handle)
{
  FAR struct bl602_expander_dev_s *priv = (FAR struct bl602_expander_dev_s *)dev;
  FAR struct bl602_expander_callback_s *cb =
    (FAR struct bl602_expander_callback_s *)handle;

  DEBUGASSERT(priv != NULL &amp;&amp; cb != NULL);
  DEBUGASSERT((uintptr_t)cb &gt;= (uintptr_t)&amp;priv-&gt;cb[0] &amp;&amp;
              (uintptr_t)cb &lt;=
              (uintptr_t)&amp;priv-&gt;cb[CONFIG_IOEXPANDER_NPINS - 1]);
  UNUSED(priv);
  gpioinfo(&quot;Detach callback for gpio=%d, callback=%p, arg=%p\n&quot;,
           cb-&gt;pinset, cb-&gt;cbfunc, cb-&gt;cbarg);

  /* Disable the GPIO Interrupt */

  DEBUGASSERT(cb-&gt;pinset &lt; CONFIG_IOEXPANDER_NPINS);
  bl602_expander_intmask(cb-&gt;pinset, 1);

  /* Clear the Interrupt Callback */

  cb-&gt;pinset = 0;
  cb-&gt;cbfunc = NULL;
  cb-&gt;cbarg  = NULL;
  return OK;
}
#endif</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L908-L950">(Source)</a></p>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L164-L197">(<code>bl602_expander_intmask</code> is defined here)</a></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/expander-code11a.png" alt="" /></p>
<h1 id="appendix-handle-gpio-interrupt"><a href="#appendix-handle-gpio-interrupt">18 Appendix: Handle GPIO Interrupt</a></h1>
<p>TODO</p>
<p>Here‚Äôs how our BL602 GPIO Expander handles a GPIO Interrupt‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Handle GPIO Interrupt. Based on
//  https://github.com/apache/incubator-nuttx/blob/master/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L256-L304
static int bl602_expander_interrupt(int irq, void *context, void *arg)
{
  FAR struct bl602_expander_dev_s *priv = (FAR struct bl602_expander_dev_s *)arg;
  uint32_t time_out = 0;
  uint8_t gpio_pin;

  gpioinfo(&quot;Interrupt! context=%p, priv=%p\n&quot;, context, priv);
  DEBUGASSERT(priv != NULL);

  /* TODO: Check only the GPIO Pins that have registered for interrupts */

  for (gpio_pin = 0; gpio_pin &lt; CONFIG_IOEXPANDER_NPINS; gpio_pin++)
    {
      /* Found the GPIO for the interrupt */

      if (1 == bl602_expander_get_intstatus(gpio_pin))
        {
          FAR struct bl602_expander_callback_s *cb = &amp;priv-&gt;cb[gpio_pin];
          ioe_callback_t cbfunc = cb-&gt;cbfunc;
          FAR void* cbarg = cb-&gt;cbarg;

          /* Attempt to clear the Interrupt Status */

          bl602_expander_intclear(gpio_pin, 1);

          /* Check Interrupt Status with timeout */

          time_out = 32;
          do
            {
              time_out--;
            }
          while ((1 == bl602_expander_get_intstatus(gpio_pin)) &amp;&amp; time_out);
          if (!time_out)
            {
              gpiowarn(&quot;WARNING: Clear GPIO interrupt status fail.\n&quot;);
            }

          /* If time_out==0, Interrupt Status not cleared */

          bl602_expander_intclear(gpio_pin, 0);

          /* NOTE: Callback will run in the context of Interrupt Handler */

          if (cbfunc == NULL)
            {
              gpioinfo(&quot;Missing callback for GPIO %d\n&quot;, gpio_pin);
            }
          else
            {
              gpioinfo(&quot;Call gpio=%d, callback=%p, arg=%p\n&quot;, gpio_pin, cbfunc, cbarg);
              cbfunc(&amp;priv-&gt;dev, gpio_pin, cbarg);
            }
        }
    }

  return OK;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L327-L393">(Source)</a></p>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L275-L300">(<code>bl602_expander_intclear</code> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/bl602_expander/blob/main/bl602_expander.c#L247-L274">(<code>bl602_expander_get_intstatus</code> is defined here)</a></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/expander-code12a.png" alt="" /></p>
<h1 id="appendix-gpio-interrupt"><a href="#appendix-gpio-interrupt">19 Appendix: GPIO Interrupt</a></h1>
<p>TODO</p>
<p>Earlier we called these functions at startup to handle GPIO Interrupts‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L731-L772"><strong>bl602_irq_attach</strong></a>: Attach our GPIO Interrupt Handler</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L774-L804"><strong>bl602_irq_enable</strong></a>: Enable GPIO Interrupt</p>
</li>
</ul>
<p>Let‚Äôs look inside the functions.</p>
<h2 id="attach-interrupt-handler-1"><a href="#attach-interrupt-handler-1">19.1 Attach Interrupt Handler</a></h2>
<p>TODO</p>
<p>We call <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L731-L772"><strong>bl602_irq_attach</strong></a> to attach our GPIO Interrupt Handler.</p>
<p><strong>bl602_irq_attach</strong> is defined below: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L686-L727">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Attach Interrupt Handler to GPIO Interrupt for Touch Controller
//  Based on https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L477-L505
static int bl602_irq_attach(gpio_pinset_t pinset, FAR isr_handler *callback, FAR void *arg)
{
  int ret = 0;
  uint8_t gpio_pin = (pinset &amp; GPIO_PIN_MASK) &gt;&gt; GPIO_PIN_SHIFT;
  FAR struct bl602_gpint_dev_s *dev = NULL;  //  TODO

  DEBUGASSERT(callback != NULL);

  /* Configure the pin that will be used as interrupt input */

  #warning Check GLB_GPIO_INT_TRIG_NEG_PULSE  //  TODO
  bl602_expander_set_intmod(gpio_pin, 1, GLB_GPIO_INT_TRIG_NEG_PULSE);
  ret = bl602_configgpio(pinset);
  if (ret &lt; 0)
    {
      gpioerr(&quot;Failed to configure GPIO pin %d\n&quot;, gpio_pin);
      return ret;
    }

  /* Make sure the interrupt is disabled */

  bl602_expander_pinset = pinset;
  bl602_expander_callback = callback;
  bl602_expander_arg = arg;
  bl602_expander_intmask(gpio_pin, 1);

  irq_attach(BL602_IRQ_GPIO_INT0, bl602_expander_interrupt, dev);
  bl602_expander_intmask(gpio_pin, 0);

  gpioinfo(&quot;Attach %p\n&quot;, callback);

  return 0;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_gpio.c#L58-L140">(<strong>bl602_configgpio</strong> is defined in the BL602 GPIO Driver)</a></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/sched/irq/irq_attach.c#L37-L136">(<strong>irq_attach</strong> comes from the BL602 IRQ Driver)</a></p>
<p>This code calls two functions from the <strong>BL602 GPIO Expander</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L890-L937"><strong>bl602_expander_set_intmod</strong></a>: Set GPIO Interrupt Mode</p>
<p><a href="https://github.com/apache/incubator-nuttx/issues/5810#issuecomment-1098633538">(We fixed this bug)</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L856-L888"><strong>bl602_expander_intmask</strong></a>: Set GPIO Interrupt Mask</p>
</li>
</ul>
<h2 id="enable-gpio-interrupt"><a href="#enable-gpio-interrupt">19.2 Enable GPIO Interrupt</a></h2>
<p>TODO</p>
<p>We call <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L774-L804"><strong>bl602_irq_enable</strong></a> to enable (or disable) GPIO Interrupts.  Here‚Äôs the function: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L774-L804">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Enable or disable GPIO Interrupt for Touch Controller.
//  Based on https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_gpio.c#L507-L535
static int bl602_irq_enable(bool enable)
{
  if (enable)
    {
      if (bl602_expander_callback != NULL)
        {
          gpioinfo(&quot;Enable interrupt\n&quot;);
          up_enable_irq(BL602_IRQ_GPIO_INT0);
        }
      else
        {
          gpiowarn(&quot;No callback attached\n&quot;);
        }
    }
  else
    {
      gpioinfo(&quot;Disable interrupt\n&quot;);
      up_disable_irq(BL602_IRQ_GPIO_INT0);
    }

  return 0;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_irq.c#L110-L170">(<strong>up_enable_irq</strong> and <strong>up_disable_irq</strong> are defined in the BL602 IRQ Driver)</a></p>

    
</body>
</html>