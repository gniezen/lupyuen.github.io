# Apache NuttX Driver for BME280 Sensor: Ported from Zephyr OS

üìù _7 Mar 2022_

![Bosch BME280 Sensor connected to Pine64 PineCone BL602 RISC-V Board](https://lupyuen.github.io/images/bme280-title.jpg)

_"Will [__Apache NuttX OS__](https://lupyuen.github.io/articles/nuttx) talk I2C with [__Bosch BME280 Sensor__](https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/)... On the [__BL602 RISC-V SoC__](https://lupyuen.github.io/articles/pinecone)?"_

...A friend and I pondered (8,000 miles apart) while working on the [__Temperature + Humidity + Air Pressure__](https://learn.sparkfun.com/tutorials/sparkfun-bme280-breakout-hookup-guide) combo sensor.

Sounds like a fun challenge...

-   NuttX __doesn't have a driver__ for the BME280 Sensor

    (Though it supports BMP280)

-   Can we port the BME280 Driver from __Zephyr OS__ with a few tweaks?

    (Spoiler: Yes we can!)

-   What's inside a __NuttX Sensor Driver__ anyway?

    (How to build our own driver)

-   NuttX on BL602 is __kinda new-ish__

    (Some features might not work the way we expect)

-   BL602's I2C Port has __interesting quirks__. Will it work?

    (Specifically: I2C Sub Address)

Read on to find out how we solved the challenge and created this driver...

-   [__lupyuen/bme280-nuttx__](https://github.com/lupyuen/bme280-nuttx)

(This BME280 Driver should work OK on other NuttX platforms, like ESP32)

![Bus Pirate connected to BME280](https://lupyuen.github.io/images/i2c-buspirate.jpg)

# Test and Connect BME280

Before we begin our exploration, verify that our BME280 Sensor works OK.

(Because we'll see some unexpected behaviour in a while)

We used [__Bus Pirate__](http://dangerousprototypes.com/docs/Bus_Pirate) (pic above) for testing our BME280 Sensor.

[(Here's how)](https://lupyuen.github.io/articles/i2c#appendix-test-bme280-with-bus-pirate)

Next we connect BME280 to Pine64's [__PineCone BL602 Board__](https://lupyuen.github.io/articles/pinecone)...

| BL602 Pin | BME280 Pin | Wire Colour
|:---:|:---:|:---|
| __`GPIO 3`__ | `SDA` | Green 
| __`GPIO 4`__ | `SCL` | Blue
| __`3V3`__ | `3.3V` | Red
| __`GND`__ | `GND` | Black

![Bosch BME280 Sensor connected to Pine64 PineCone BL602 RISC-V Board](https://lupyuen.github.io/images/bme280-connect.jpg)

The __I2C Pins__ on BL602 are defined here: [board.h](https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/include/board.h#L85-L88)

```c
/* I2C Configuration */
#define BOARD_I2C_SCL \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN4)
#define BOARD_I2C_SDA \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN3)
```

We disabled the __UART1 Port__ because it uses the same pins as I2C: [board.h](https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/include/board.h#L63-L68)

```c
#ifdef TODO  /* Remember to check for duplicate pins! */
#define BOARD_UART_1_RX_PIN \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_UART | \
  GPIO_PIN3)
#define BOARD_UART_1_TX_PIN \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_UART | \
  GPIO_PIN4)
#endif  /* TODO */
```

(UART0 is used by the Serial Console)

_What if we're connecting to ESP32?_

__For ESP32:__ The GPIO Pin Numbers for the I2C Port (I2C0) are defined in [Kconfig](https://github.com/lupyuen/incubator-nuttx/blob/bme280/arch/xtensa/src/esp32/Kconfig#L797-L805) and menuconfig...

```text
config ESP32_I2C0_SCLPIN
  int "I2C0 SCL Pin"
  default 22
  range 0 39

config ESP32_I2C0_SDAPIN
  int "I2C0 SDA Pin"
  default 23
  range 0 39
```

_Do we need Pull-Up Resistors?_

We're using the [__SparkFun BME280 Breakout Board__](https://learn.sparkfun.com/tutorials/sparkfun-bme280-breakout-hookup-guide/all), which has __Pull-Up Resistors__. (So we don't need to add our own)

_What happens now?_

Coming up we have a lengthy exploration of BME280 on BL602.

If we're only interesting in __running the NuttX BME280 Driver__ (on BL602, ESP32 and other platforms), jump to this section for the instructions...

-   [__"Build, Flash and Run NuttX with BME280"__](https://lupyuen.github.io/articles/bme280#appendix-build-flash-and-run-nuttx)

But if we're keen to go deep inside the BME280 driver... Read on!

# Start with BMP280 Driver

NuttX doesn't have a BME280 Driver, but there's a __NuttX Driver for BMP280__, the downsized (rightsized?) sibling of BME280.

(BMP280 works like BME280 for sensing Air Pressure and Temperature, but __without Humidity__)

Let's test the __BMP280 Driver on BL602__ and fix any I2C quirks.

1.  Follow these steps to __download and configure__ NuttX...

    [__"Download NuttX"__](https://lupyuen.github.io/articles/bme280#download-nuttx)

    [__"Configure NuttX"__](https://lupyuen.github.io/articles/bme280#configure-nuttx)

    ![Enable the I2C Port and I2C Character Driver](https://lupyuen.github.io/images/bme280-config1.png)

1.  Enable the __BMP280 Driver__ in menuconfig...

    Check the box for __"Device Drivers"__ ‚Üí __"Sensor Device Support"__

    Select __"Sensor Device Support"__

    Check the box for __"Bosch BMP280 Barometic Pressure Sensor"__

    ![BMP280 Driver](https://lupyuen.github.io/images/bme280-config3.png)

## Change I2C Address and Device ID

_Will NuttX's BMP280 Driver really work with our BME280?_

Yep the BMP280 Driver ought to read the __Air Pressure__ and __Temperature__ from our BME280 Sensor. (But not Humidity)

Just that we need to we change the __I2C Address__ and __Device ID__ in the BMP280 Driver: [bmp280.c](https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L45-L57)

```c
//  Previously: I2C Address of BMP280
//  #define BMP280_ADDR     0x76

//  Testing: I2C Address of BME280
#define BMP280_ADDR         0x77

//  Previously: Device ID of BMP280
//  #define DEVID           0x58

//  Testing: Device ID of BME280
#define DEVID               0x60
```

[(FYI: Zephyr uses the same driver for BMP280 and BME280)](https://github.com/zephyrproject-rtos/zephyr/issues/1709)

![Change I2C Address and Device ID](https://lupyuen.github.io/images/bme280-code1.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L45-L57)

## Register BMP280 Driver

Next we __load the BMP280 Driver__ at startup: [bl602_bringup.c](https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L623-L640)

```c
#ifdef CONFIG_SENSORS_BMP280
#include <nuttx/sensors/bmp280.h>
#endif  //  CONFIG_SENSORS_BMP280
...
int bl602_bringup(void) {
...
#ifdef CONFIG_SENSORS_BMP280
  //  Init I2C bus for BMP280
  struct i2c_master_s *bmp280_i2c_bus = 
    bl602_i2cbus_initialize(0);
  if (!bmp280_i2c_bus) {
    _err("ERROR: Failed to get I2C%d interface\n", 0);
  }

  //  Register the BMP280 driver
  ret = bmp280_register(0, bmp280_i2c_bus);
  if (ret < 0) {
    _err("ERROR: Failed to register BMP280\n");
  }
#endif  //  CONFIG_SENSORS_BMP280
```

[(__bmp280_register__ is defined here)](https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L691-L760)

__For ESP32:__ Edit the function [esp32_bringup](https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L134-L497) in [esp32_bringup.c](https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L134-L497) so that it calls [bmp280_register](https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L691-L760)

![Register BMP280 Driver](https://lupyuen.github.io/images/bme280-code2a.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx/blob/bmp280/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L623-L640)

## Invalid Device ID

We're ready to test the BMP280 Driver! __Build, flash and run__ NuttX with these steps...

1.  [__"Build NuttX"__](https://lupyuen.github.io/articles/bme280#build-nuttx)

1.  [__"Flash NuttX"__](https://lupyuen.github.io/articles/bme280#flash-nuttx)

1.  [__"Run NuttX"__](https://lupyuen.github.io/articles/bme280#run-nuttx)

Something unexpected happens when we boot NuttX on BL602...

```text
bl602_i2c_transfer: i2c transfer success
bmp280_checkid:  devid: 0x00
bmp280_checkid:  Wrong Device ID! 00
bmp280_register: Failed to register driver: -19
bl602_bringup:   ERROR: Failed to register BMP280
```

[(See the complete log)](https://github.com/lupyuen/bme280-nuttx#invalid-device-id)

This says that the BMP280 Driver was expecting __Device ID `0x60`__... But it got __`0x00`__ instead!

Let's find out why ü§î

![Invalid Device ID](https://lupyuen.github.io/images/bme280-run1.png)

[(Source)](https://github.com/lupyuen/bme280-nuttx#invalid-device-id)

## Incorrect Register ID

To track down why we're not reading the right Device ID, let's connect a __Logic Analyser__ and inspect the bits on the I2C Bus...

![Logic Analyser connected between BL602 and BME280](https://lupyuen.github.io/images/bme280-logic2.jpg)

The I2C Data captured by our Logic Analyser looks surprising...

![I2C Data captured by Logic Analyser](https://lupyuen.github.io/images/bme280-logic1.png)

The pic above shows that BL602 sent the __wrong Register ID__ to BME280...

```text
Write  [0xEE]
0x00 + ACK (Register ID is 0x00, which is incorrect!)
Read   [0xEF]
0x00 + NAK (No Acknowledgement, because Register ID is incorrect!)
```

To read the Device ID, the Register ID should be __`0xD0`__, not __`0x00`__!

Let's fix this ü§î

[(Here's why Register ID should be `0xD0`)](https://lupyuen.github.io/articles/i2c#appendix-test-bme280-with-bus-pirate)

## Set I2C Sub Address

_Is there something special about BL602's I2C Port?_

BL602 has a peculiar I2C Port...

We need to send the __I2C Sub Address__ (Register ID) separately from the I2C Data! 

(Which might have caused the BMP280 Driver to fail)

![I2C Sub Address](https://lupyuen.github.io/images/bme280-subaddress2.png)

[(From BL602 Reference Manual)](https://github.com/bouffalolab/bl_docs/tree/main/BL602_RM/en)

When we browse the NuttX code for BL602's I2C Driver, we realise that it __supports I2C Sub Addresses__: [bl602_i2c.c](https://github.com/lupyuen/incubator-nuttx/blob/bmp280/arch/risc-v/src/bl602/bl602_i2c.c#L719-L738)

```c
static int bl602_i2c_transfer(struct i2c_master_s *dev, struct i2c_msg_s *msgs, int count) {
  ...
  //  if msgs[i].flag I2C_M_NOSTOP,means start i2c with subddr
  if (msgs[i].flags & I2C_M_NOSTOP) {
    priv->subflag = 1;
    priv->subaddr = 0;
    for (j = 0; j < msgs[i].length; j++) {
      priv->subaddr += msgs[i].buffer[j] << (j * 8);
    }
    priv->sublen = msgs[i].length;
    i++;
```

But it needs the flag __I2C_M_NOSTOP__ to be set!

Let's patch the NuttX BMP280 Driver to send the __Register ID as I2C Sub Address__ (instead of I2C Data) when we're reading a BMP280 Register: [bmp280.c](https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L209-L219)

```c
//  Read a single BME280 Register
static uint8_t bmp280_getreg8(FAR struct bmp280_dev_s *priv, uint8_t regaddr) {
  ...
  msg[0].frequency = priv->freq;
  msg[0].addr      = priv->addr;

#ifdef CONFIG_BL602_I2C0
  //  For BL602: Register ID must be passed as I2C Sub Address
  msg[0].flags     = I2C_M_NOSTOP;
#else
  //  Otherwise pass Register ID as I2C Data
  msg[0].flags     = 0;
#endif  //  CONFIG_BL602_I2C0

  msg[0].buffer    = &regaddr;
  msg[0].length    = 1;
```

[(We patch __bmp280_getregs__ too)](https://github.com/lupyuen/incubator-nuttx/blob/bmp280/drivers/sensors/bmp280.c#L253-L263)

_What about writing to BMP280 Registers? Do we need to set the I2C Sub Address?_

We don't need to set the I2C Sub Address when writing to BMP280 registers.

In a while we'll see the log which says that the BMP280 Driver works fine for writing to BMP280 registers.

[(Besides BL602, NXP Microcontrollers are probably the only ones that support I2C Sub Addresses)](https://mcuxpresso.nxp.com/api_doc/dev/116/group__i2c.html)

![Send the Register ID as I2C Sub Address (instead of I2C Data) when we're reading a BMP280 Register](https://lupyuen.github.io/images/bme280-code5a.png)

## BMP280 Driver Loads OK

We've patched the BMP280 Driver to send the Register ID as I2C Sub Address. Let's run it!

```text
sensor_custom_register: Registering /dev/sensor/baro0
bmp280_register: BMP280 driver loaded successfully!
NuttShell (NSH) NuttX-10.2.0-RC0
```

[(See the complete log)](https://github.com/lupyuen/bme280-nuttx#bmp280-driver-loads-ok)

Yep our patched BMP280 Driver __loads successfully__!

(Because it receives the correct Device ID from BMP280)

BMP280 appears on NuttX as __/dev/sensor/baro0__...

```bash
nsh> ls /dev/sensor
/dev/sensor:
 baro0
```

Let's read the __baro0__ device.

[(How we enable logging for BL602 I2C Driver)](https://lupyuen.github.io/articles/bme280#appendix-log-i2c-transfers)

![Our patched BMP280 Driver loads successfully](https://lupyuen.github.io/images/bme280-run2a.png)

## Run Sensor Test App

NuttX provides a __Sensor Test App__ that will read our BMP280 Device at __/dev/sensor/baro0__...

-   [__testing/sensortest/sensortest.c__](https://github.com/lupyuen/incubator-nuttx-apps/blob/bme280/testing/sensortest/sensortest.c)

(We'll study the code later)

We configure NuttX to enable the __Sensor Test App__...

-   "Application Configuration" ‚Üí "Testing" ‚Üí "Sensor Driver Test"

[(Details here)](https://lupyuen.github.io/articles/bme280#configure-nuttx)

![Enable the Sensor Test App](https://lupyuen.github.io/images/bme280-config4a.png)

Build, flash and run NuttX. To read 10 sensor values from __/dev/sensor/baro0__, enter this at the NuttX Shell...

```text
nsh> sensortest -n 10 baro0
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30680000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:674.93 value2:22.18
baro0: timestamp:30690000 value1:1006.21 value2:30.78
baro0: timestamp:30690000 value1:1006.21 value2:30.78
SensorTest: Received message: baro0, number:10/10
bl602_i2c_transfer: i2c transfer error, event = 4
```

[(See the complete log)](https://github.com/lupyuen/bme280-nuttx#run-sensor-test-app)

We see the Air Pressure and Temperature: __1,006.21 millibars__ at __30.78 ¬∞C__.

(Air Pressure at Sea Level is 1,013.25 millibars)

Yep this looks reasonable for Sunny Singapore by the Seaside!

![Read sensor values from BMP280](https://lupyuen.github.io/images/bme280-run5a.png)

_Are we sure that BL602 is writing correctly to I2C Registers?_

This log shows that writing to I2C Registers works OK...

```text
## Register F5 has value 00
bmp280_getreg8: regaddr=0xf5, regval=0x00
...
## Set Register F5 to value A0
bmp280_putreg8: regaddr=0xf5, regval=0xa0
...
## Register F5 now has value A0
bmp280_getreg8: regaddr=0xf5, regval=0xa0
```

[(See the complete log)](https://github.com/lupyuen/bme280-nuttx#run-sensor-test-app)

Yep the NuttX BMP280 Driver works OK! Now let's port the BME280 Driver from Zephyr OS to NuttX, so we can get the Humidity.

![NuttX BMP280 Driver vs Zephyr BME280 Driver](https://lupyuen.github.io/images/bme280-code6a.png)

_[NuttX BMP280 Driver](https://github.com/apache/incubator-nuttx/blob/master/drivers/sensors/bmp280.c) vs [Zephyr BME280 Driver](https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/sensor/bme280/bme280.c)_

# Port BME280 Driver from Zephyr OS

NuttX's BMP280 Driver works OK with our BME280 Sensor. But we're missing one thing: __Humidity__.

Let's port the BME280 Driver from __Zephyr OS__ to NuttX...

-   [__Zephyr BME280 Driver__](https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/sensor/bme280/bme280.c)

_Why not code the BME280 Driver based on the datasheet?_

Well yes we could... But then the rest of this article would become an academic exercise üòâ

_Why port from Zephyr OS?_

Zephyr has an [__extensive collection__](https://github.com/zephyrproject-rtos/zephyr/tree/main/drivers) of drivers. 

The NuttX porting steps that we establish today might work for other Zephyr drivers, with minimal changes!

_Porting a driver from Zephyr to NuttX sounds hard!_

Zephyr's BME280 Driver looks __highly similar__ to NuttX's BMP280 Driver. (Pic above)

Thus porting Zephyr BME280 Driver to NuttX might not be so hard!

## Zephyr to NuttX

__Zephyr's BME280 Driver__ exposes these functions: [bme280-nuttx/bme280.c](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c)

![Zephyr BME280 Driver](https://lupyuen.github.io/images/bme280-port2.jpg)

-   [__bme280_chip_init__](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L348-L417): Initialise the BME280 Sensor

-   [__bme280_pm_action__](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L419-L446): Suspend the BME280 Sensor (Low Power Mode) or resume to Normal Power Mode

-   [__bme280_sample_fetch__](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L194-L245): Fetch a sample from the BME280 Sensor

-   [__bme280_channel_get__](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c#L247-L286): Get the Temperature / Humidity / Pressure from the fetched sample

[(__bme280_sample_fetch__ and __bme280_channel_get__ are explained in the Zephyr Sensor Docs)](https://docs.zephyrproject.org/latest/reference/peripherals/sensor.html)

But NuttX expects a different interface for __Sensor Drivers__: [bme280-nuttx/driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c)

![NuttX Driver](https://lupyuen.github.io/images/bme280-port3.jpg)

-   [__bme280_register__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L668-L773): Register the sensor at startup and suspend the sensor

-   [__bme280_activate__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L397-L431): Suspend the sensor (Low Power Mode) or resume to Normal Power Mode

-   [__bme280_fetch__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L487-L572): Fetch the sensor values (Temperature / Humidity / Pressure)

-   [__bme280_set_interval__](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L287-L341): Set the Standby Interval for the sensor

Our job is to __map the Zephyr BME280 Driver__ to the Sensor Driver Interface expected by NuttX...

![Zephyr BME280 Driver mapped to NuttX Driver](https://lupyuen.github.io/images/bme280-port4.jpg)


| Zephyr Driver | NuttX Driver |
| ------------- | -------------|
| bme280_chip_init,<br>bme280_pm_action | __bme280_register__
| bme280_pm_action | __bme280_activate__
| bme280_sample_fetch,<br>bme280_channel_get | __bme280_fetch__
| _(Static Interval)_ | __bme280_set_interval__

We'll cover the details in the next section.

_What about bme280_set_interval?_

Zephyr assumes that the __Standby Interval is Static__. (Defined at compile time)

Whereas NuttX expects the Standby Interval to be __set at runtime__.

To handle this, we code the __bme280_set_interval__ function ourselves in NuttX.

## Wrap Zephyr Driver as NuttX Driver

TODO

Zephyr BME280 Driver builds OK on #NuttX (with a few tweaks) üéâ 

TODO7

![](https://lupyuen.github.io/images/bme280-code7a.png)

[(Source)](https://github.com/lupyuen/bme280-nuttx/blob/main/bme280.c)

Now we wrap the Zephyr Driver as a NuttX Driver...

[(Source)](https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c)

Our NuttX Driver Wrapper wraps around the Zephyr BME280 Driver ... So it works like a NuttX Driver: [driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L349-L424)

```c
static int bme280_fetch(FAR struct sensor_lowerhalf_s *lower,
                        FAR char *buffer, size_t buflen)
{
  sninfo("buflen=%d\n", buflen);
  FAR struct device *priv = container_of(lower,
                                               FAR struct device,
                                               sensor_lower);

  int ret;
  struct timespec ts;
  struct sensor_event_baro baro_data;
  struct sensor_value val;

  if (buflen != sizeof(baro_data))
    {
      return -EINVAL;
    }

  /* Zephyr BME280 Driver assumes that sensor is not in sleep mode */
  if (!priv->activated)
    {
      snerr("Device must be active before fetch\n");
      return -EIO;
    }

  /* Fetch the sensor data (from Zephyr BME280 Driver) */

  ret = bme280_sample_fetch(priv, SENSOR_CHAN_ALL);
  if (ret < 0)
    {
      return ret;
    }

  /* Get the temperature (from Zephyr BME280 Driver) */

  ret = bme280_channel_get(priv, SENSOR_CHAN_AMBIENT_TEMP, &val);
  if (ret < 0)
    {
      return ret;
    }
  baro_data.temperature = get_sensor_value(&val);

  /* Get the pressure (from Zephyr BME280 Driver) */

  ret = bme280_channel_get(priv, SENSOR_CHAN_PRESS, &val);
  if (ret < 0)
    {
      return ret;
    }
  baro_data.pressure = get_sensor_value(&val) * 10;

  /* Get the humidity (from Zephyr BME280 Driver) */

  ret = bme280_channel_get(priv, SENSOR_CHAN_HUMIDITY, &val);
  if (ret < 0)
    {
      return ret;
    }
  float humidity = get_sensor_value(&val);

  /* Get the timestamp */
  
#ifdef CONFIG_CLOCK_MONOTONIC
  clock_gettime(CLOCK_MONOTONIC, &ts);
#else
  clock_gettime(CLOCK_REALTIME, &ts);
#endif
  baro_data.timestamp = 1000000ull * ts.tv_sec + ts.tv_nsec / 1000;

  /* Return the sensor data */

  memcpy(buffer, &baro_data, sizeof(baro_data));
  sninfo("temperature=%f ¬∞C, pressure=%f mbar, humidity=%f %%\n", baro_data.temperature, baro_data.pressure, humidity);

  return buflen;
}
```

TODO8

![](https://lupyuen.github.io/images/bme280-code8a.png)

## Read Sensor Data from Zephyr Driver

TODO

Our NuttX BME280 Driver reads the Sensor Data from Zephyr Driver in two steps: 1Ô∏è‚É£ Fetch the sensor sample 2Ô∏è‚É£ Get the channel data

[driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L374-L421)

```c
  /* Fetch the sensor data (from Zephyr BME280 Driver) */

  ret = bme280_sample_fetch(priv, SENSOR_CHAN_ALL);
  if (ret < 0)
    {
      return ret;
    }

  /* Get the temperature (from Zephyr BME280 Driver) */

  ret = bme280_channel_get(priv, SENSOR_CHAN_AMBIENT_TEMP, &val);
  if (ret < 0)
    {
      return ret;
    }
  baro_data.temperature = get_sensor_value(&val);

  /* Get the pressure (from Zephyr BME280 Driver) */

  ret = bme280_channel_get(priv, SENSOR_CHAN_PRESS, &val);
  if (ret < 0)
    {
      return ret;
    }
  baro_data.pressure = get_sensor_value(&val) * 10;

  /* Get the humidity (from Zephyr BME280 Driver) */

  ret = bme280_channel_get(priv, SENSOR_CHAN_HUMIDITY, &val);
  if (ret < 0)
    {
      return ret;
    }
  float humidity = get_sensor_value(&val);

  /* Get the timestamp */
  
#ifdef CONFIG_CLOCK_MONOTONIC
  clock_gettime(CLOCK_MONOTONIC, &ts);
#else
  clock_gettime(CLOCK_REALTIME, &ts);
#endif
  baro_data.timestamp = 1000000ull * ts.tv_sec + ts.tv_nsec / 1000;

  /* Return the sensor data */

  memcpy(buffer, &baro_data, sizeof(baro_data));
  sninfo("temperature=%f ¬∞C, pressure=%f mbar, humidity=%f %%\n", baro_data.temperature, baro_data.pressure, humidity);
```

TODO9

![](https://lupyuen.github.io/images/bme280-code9a.png)

## Power Management

TODO

Power Management works a little differently in NuttX vs Zephyr ... Here's how our NuttX BME280 Driver calls the Zephyr Driver to do Power Management: [driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L315-L343)

```c
static int bme280_activate(FAR struct sensor_lowerhalf_s *lower,
                           bool enable)
{
  sninfo("enable=%d\n", enable);
  int ret = 0;

  FAR struct device *priv = container_of(lower,
                                               FAR struct device,
                                               sensor_lower);
  if (enable)
    {
      /* Set power mode to normal */

      ret = bme280_pm_action(priv, PM_DEVICE_ACTION_RESUME);
    }
  else
    {
      /* Set to sleep mode */

      ret = bme280_pm_action(priv, PM_DEVICE_ACTION_SUSPEND);
    }

  if (ret >= 0)
    {
      priv->activated = enable;
    }

  return ret;
}
```

TODO10

![](https://lupyuen.github.io/images/bme280-code10.png)

## Standby Duration

TODO

BME280 Standby Duration is static in Zephyr but configured at runtime in NuttX ... So we set it in our NuttX BME280 Driver: [driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L217-L255)

```c
static int bme280_set_standby(FAR struct device *priv, uint8_t value)
{
  sninfo("value=%d\n", value);
  
  uint8_t v_data_u8;
  uint8_t v_sb_u8;
  int ret;

  /* Set the standby duration value */

  ret = bme280_reg_read(priv, BME280_REG_CONFIG, &v_data_u8, 1);
  if (ret < 0)
    {
      return ret;
    }
  v_data_u8 = (v_data_u8 & ~(0x07 << 5)) | (value << 5);
  ret = bme280_reg_write(priv, BME280_REG_CONFIG, v_data_u8);
  if (ret < 0)
    {
      return ret;
    }

  /* Check the standby duration value */

  ret = bme280_reg_read(priv, BME280_REG_CONFIG, &v_data_u8, 1);
  if (ret < 0)
    {
      return ret;
    }
  v_sb_u8 = (v_data_u8 >> 5) & 0x07;

  if (v_sb_u8 != value)
    {
      snerr("Failed to set value for standby time.");
      return ERROR;
    }

  return OK;
}
```

TODO11

![](https://lupyuen.github.io/images/bme280-code11.png)

## Zephyr Driver Modified For NuttX

TODO

Here are the minor modifications we made to the Zephyr BME280 Driver while porting to NuttX...

[bme280.c](https://github.com/lupyuen/bme280-nuttx/pull/1/files#diff-80464162211b7180f107757b7aee91398cdc088e5775ffadf7e6e1f0bbb4ad65)

[bme280.h](https://github.com/lupyuen/bme280-nuttx/pull/1/files#diff-e13ff0ab44de7ead31a3dd6cbbbbf2a6fbfb2f04889300993b87ff5a31ffc233)

The above files are wrapped by [bundle.c](https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.c) and [bundle.h](https://github.com/lupyuen/bme280-nuttx/blob/main/bundle.h) to become a NuttX Driver.

TODO12

![](https://lupyuen.github.io/images/bme280-code12.png)

## Output Log

TODO

Zephyr BME280 Driver ported to Apache #NuttX OS ... Works great on NuttX! üéâ

```text
spi_test_driver_register: devpath=/dev/spitest0, spidev=0
bme280_register: devno=0
bme280_reg_read: start=0xd0, size=1
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: "BME280" OK
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
sensor_custom_register: Registering /dev/sensor/baro0
bme280_register: BME280 driver loaded successfully!

NuttShell (NSH) NuttX-10.2.0-RC0
nsh> sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: period_us=1107411860
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: enable=1
bme280_reg_read: start=0xd0, size=1
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: "BME280" OK
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21140000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21160000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21180000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21200000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21220000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21240000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21260000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21280000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21300000 value1:1010.60 value2:29.62
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.620001 ¬∞C, pressure=1010.603760 mbar, humidity=88.342773 %
baro0: timestamp:21320000 value1:1010.60 value2:29.62
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: enable=0
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4

nsh> sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: period_us=1107411860
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: enable=1
bme280_reg_read: start=0xd0, size=1
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: "BME280" OK
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25440000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25460000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25480000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25500000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25520000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25540000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25560000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25580000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25600000 value1:1010.60 value2:29.65
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.650000 ¬∞C, pressure=1010.595825 mbar, humidity=88.250000 %
baro0: timestamp:25620000 value1:1010.60 value2:29.65
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: enable=0
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: 2c transfer error, event = 4

nsh> sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: period_us=1107411860
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: enable=1
bme280_reg_read: start=0xd0, size=1
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: "BME280" OK
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27510000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27530000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27550000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27570000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27590000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27610000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27630000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27650000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27670000 value1:1010.58 value2:29.66
sensor_pollnotify: Report events: 01
bme280_fetch: buflen=16
bme280_reg_read: start=0xf3, size=1
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=29.660000 ¬∞C, pressure=1010.583862 mbar, humidity=88.229492 %
baro0: timestamp:27690000 value1:1010.58 value2:29.66
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: enable=0
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
nsh>
```

Detailed Log:

```text
gpio_pin_register: Registering /dev/gpio0
gpio_pin_register: Registering /dev/gpio1
gpint_enable: Disable the interrupt
gpio_pin_register: Registering /dev/gpio2
bl602_gpio_set_intmod: ****gpio_pin=115, int_ctlmod=1, int_trgmod=0
bl602_spi_setfrequency: frequency=400000, actual=0
bl602_spi_setbits: nbits=8
bl602_spi_setmode: mode=0
spi_test_driver_register: devpath=/dev/spitest0, spidev=0
bl602_spi_select: devid: 0, CS: free
bme280_reg_read: start=0xd0, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xd0, sublen=1
bl602_i2c_recvdata: count=1, temp=0x60
bl602_i2c_transfer: i2c transfer success
bme280_chip_init: ID OKbme280_reg_write: reg=0xe0, val=0xb6
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0xb6e0
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x0
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0x88, size=24
bl602_i2c_transfer: subflag=1, subaddr=0x88, sublen=1
bl602_i2c_recvdata: count=24, temp=0x65e66e97
bl602_i2c_recvdata: count=20, temp=0x8f990032
bl602_i2c_recvdata: count=16, temp=0xbd0d581
bl602_i2c_recvdata: count=12, temp=0xffdb1e71
bl602_i2c_recvdata: count=8, temp=0x26acfff9
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xa1, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xa1, sublen=1
bl602_i2c_recvdata: count=1, temp=0x10bdd84b
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xe1, size=7
bl602_i2c_transfer: subflag=1, subaddr=0xe1, sublen=1
bl602_i2c_recvdata: count=7, temp=0x14000165
bl602_i2c_recvdata: count=3, temp=0x141e000b
bl602_i2c_transfer: i2c transfer success
bme280_reg_write: reg=0xf2, val=0x05
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0x5f2
bl602_i2c_transfer: i2c transfer success
bme280_reg_write: reg=0xf4, val=0x57
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0x57f4
bl602_i2c_transfer: i2c transfer success
bme280_reg_write: reg=0xf5, val=0xa8
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_send_data: count=2, temp=0xa8f5
bl602_i2c_transfer: i2c transfer success
bme280_chip_init: "BME280" OKsensor_custom_register: Registering /dev/sensor/baro0
bme280_register: BME280 driver loaded successfully!

NuttShell (NSH) NuttX-10.2.0-RC0
nsh> sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: TODO period_us=1107411860
bme280_set_standby: TODO value=5
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: TODO enable=1
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x141e0000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38390000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38410000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38430000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38450000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38470000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38490000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38510000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38530000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38550000 value1:106.94 value2:30.11
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86604d52
bl602_i2c_recvdata: count=4, temp=0x2a8f503a
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.110001 ¬∞C, pressure=106.937820 mbar, humidity=86.075195 %
baro0: timestamp:38570000 value1:106.94 value2:30.11
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: TODO enable=0

nsh> sensortest -n 10 baro0
sensor_ioctl: cmd=a81 arg=4201c394
bme280_set_interval: TODO period_us=1107411860
bme280_set_standby: TODO value=5
sensor_ioctl: cmd=a82 arg=4201c398
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate: TODO enable=1
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2a8f5000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47120000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_trasfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47140000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47160000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47180000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47200000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47220000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47240000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2crecvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47260000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, sublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47280000 value1:106.94 value2:30.12
sensor_pollnotify: Report events: 01
bme280_reg_read: start=0xf3, size=1
bl602_i2c_transfer: subflag=1, subaddr=0xf3, sublen=1
bl602_i2c_recvdata: count=1, temp=0x2c8f8000
bl602_i2c_transfer: i2c transfer success
bme280_reg_read: start=0xf7, size=8
bl602_i2c_transfer: subflag=1, subaddr=0xf7, ublen=1
bl602_i2c_recvdata: count=8, temp=0x86f04d52
bl602_i2c_recvdata: count=4, temp=0x2c8f803b
bl602_i2c_transfer: i2c transfer success
bme280_fetch: temperature=30.120001 ¬∞C, pressure=106.937500 mbar, humidity=86.087891 %
baro0: timestamp:47300000 value1:106.94 value2:30.12
SensorTest: Received message: baro0, number:10/10
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate: TODO enable=0
nsh>
```

TODO32

![](https://lupyuen.github.io/images/bme280-run6a.png)

# Combined Barometer and Humidity Sensor

TODO

NuttX doesn't have a Sensor Type that supports BME280 Temperature + Humidity + Pressure ... So our NuttX BME280 Driver combines 2 Sensor Types: 1Ô∏è‚É£ Barometer Sensor (Pressure + Temperature) 2Ô∏è‚É£ Humidity Sensor

[device.h](https://github.com/lupyuen/bme280-nuttx/blob/main/device.h#L36-L49)

```c
/* NuttX Device for BME280 */

struct device
{
  FAR struct sensor_lowerhalf_s sensor_baro;  /* Barometer and Temperature Sensor */
  FAR struct sensor_lowerhalf_s sensor_humi;  /* Humidity Sensor */
  FAR struct i2c_master_s *i2c; /* I2C interface */
  uint8_t addr;                 /* BME280 I2C address */
  int freq;                     /* BME280 Frequency <= 3.4MHz */
  bool activated;               /* True if device is not in sleep mode */

  char *name;                   /* Name of the device */
  struct bme280_data *data;     /* Compensation parameters (bme280.c) */
};
```

TODO14

![](https://lupyuen.github.io/images/bme280-combine1.png)


Each NuttX Sensor defines its operations for 1Ô∏è‚É£ Activating the sensor 2Ô∏è‚É£ Fetching sensor data 3Ô∏è‚É£ Setting the standby interval

[driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L71-L87)

```c
/* Operations for Barometer and Temperature Sensor */

static const struct sensor_ops_s g_baro_ops =
{
  .activate      = bme280_activate_baro,
  .fetch         = bme280_fetch_baro,
  .set_interval  = bme280_set_interval_baro,
};

/* Operations for Humidity Sensor */

static const struct sensor_ops_s g_humi_ops =
{
  .activate      = bme280_activate_humi,
  .fetch         = bme280_fetch_humi,
  .set_interval  = bme280_set_interval_humi,
};
```

![](https://lupyuen.github.io/images/bme280-combine2a.png)

At NuttX Startup we register both BME280 sensors: Barometer Sensor and Humidity Sensor: [driver.c](https://github.com/lupyuen/bme280-nuttx/blob/main/driver.c#L755-L773)

```c
int bme280_register(int devno, FAR struct i2c_master_s *i2c)
{
  ...
  /* Register the Barometer Sensor */

  ret = sensor_register(&priv->sensor_baro, devno);
  if (ret < 0)
    {
      snerr("Failed to register barometer sensor: %d\n", ret);
      kmm_free(data);
      kmm_free(priv);
    }

  /* Register the Humidity Sensor */

  ret = sensor_register(&priv->sensor_humi, devno);
  if (ret < 0)
    {
      snerr("Failed to register humidity sensor: %d\n", ret);
      kmm_free(data);
      kmm_free(priv);
    }
```

TODO17

![](https://lupyuen.github.io/images/bme280-combine3.png)

Our NuttX BME280 Driver appears as 2 sensors: 1Ô∏è‚É£ "/dev/sensor/baro0" (Barometer Sensor) 2Ô∏è‚É£ "/dev/sensor/humi0" (Humidity Sensor)

# Run BME280 Driver

TODO

Edit the function `bl602_bringup` or `esp32_bringup` in this file...

```text
## For BL602:
nuttx/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c

## For ESP32: Change "esp32-devkitc" to our ESP32 board 
nuttx/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c
```

And call `bme280_register` to register our BME280 Driver:

https://github.com/lupyuen/incubator-nuttx/blob/bme280/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L623-L640    

```c
#ifdef CONFIG_SENSORS_BME280
#include <nuttx/sensors/bme280.h>
#endif /* CONFIG_SENSORS_BME280 */

...

int bl602_bringup(void) {
  ...

#ifdef CONFIG_SENSORS_BME280

  /* Init I2C bus for BME280 */

  struct i2c_master_s *bme280_i2c_bus = bl602_i2cbus_initialize(0);
  if (!bme280_i2c_bus)
    {
      _err("ERROR: Failed to get I2C%d interface\n", 0);
    }

  /* Register the BME280 driver */

  ret = bme280_register(0, bme280_i2c_bus);
  if (ret < 0)
    {
      _err("ERROR: Failed to register BME280\n");
    }
#endif /* CONFIG_SENSORS_BME280 */
```

This is how we read each sensor:

```text
NuttShell (NSH) NuttX-10.2.0-RC0
nsh> ls /dev/sensor
/dev/sensor:
 baro0
 humi0
nsh> 
nsh> sensortest -n 1 baro0
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
baro0: timestamp:43760000 value1:1011.29 value2:29.09
SensorTest: Received message: baro0, number:1/1
bl602_i2c_transfer: i2c transfer error, event = 4
nsh> 
nsh> sensortest -n 1 humi0
SensorTest: Test /dev/sensor/humi0 with interval(1000000us), latency(0us)
humi0: timestamp:60120000 value:90.58
SensorTest: Received message: humi0, number:1/1
bl602_i2c_transfer: i2c transfer error, event = 4
nsh> 
nsh> 
```

TODO

![](https://lupyuen.github.io/images/bme280-run8a.jpg)

Detailed Log:

```text
spi_test_driver_register: devpath=/dev/spitest0, spidev=0
bme280_register: devno=0
bme280_register: priv=4201b770, sensor_baro=4201b770, sensor_humi=4201b78c
bme280_reg_read: start=0xd0, size=1, buf[0]=0x60
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1, buf[0]=0x00
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1, buf[0]=0x4b
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: "BME280" OK
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
sensor_custom_register: Registering /dev/sensor/baro0
sensor_custom_register: Registering /dev/sensor/humi0
bme280_register: BME280 driver loaded successfully!

NuttShell (NSH) NuttX-10.2.0-RC0
nsh> sensortest -n 1 baro0
sensor_ioctl: cmd=a81 arg=4201c424
bme280_set_interval_baro: period_us=1107412004
bme280_set_interval_baro: priv=4201b770, sensor_baro=4201b770
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1, buf[0]=0xa8
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1, buf[0]=0xa8
sensor_ioctl: cmd=a82 arg=4201c428
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate_baro: enable=1
bme280_activate_baro: priv=4201b770, sensor_baro=4201b770
bme280_reg_read: start=0xd0, size=1, buf[0]=0x60
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1, buf[0]=0x00
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1, buf[0]=0x4b
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: "BME280" OK
SensorTest: Test /dev/sensor/baro0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch_baro: buflen=16
bme280_fetch_baro: priv=4201b770, sensor_baro=4201b770
bme280_reg_read: start=0xf3, size=1, buf[0]=0x0c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x0c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x04
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=30.820000 ¬∞C, pressure=1006.847229 mbar, humidity=75.403320 %
baro0: timestamp:45090000 value1:1006.85 value2:30.82
SensorTest: Received message: baro0, number:1/1
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate_baro: enable=0
bme280_activate_baro: priv=4201b770, sensor_baro=4201b770
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
nsh>
nsh>
nsh> sensortest -n 1 humi0
sensor_ioctl: cmd=a81 arg=4201c424
bme280_set_interval_humi: period_us=1107412004
bme280_set_interval_humi: priv=4201b770, sensor_humi=4201b78c
bme280_set_standby: value=5
bme280_reg_read: start=0xf5, size=1, buf[0]=0xa8
bme280_reg_write: reg=0xf5, val=0xa8
bme280_reg_read: start=0xf5, size=1, buf[0]=0xa8
sensor_ioctl: cmd=a82 arg=4201c428
sensor_ioctl: cmd=a80 arg=00000001
bme280_activate_humi: enable=1
bme280_activate_humi: priv=4201b770, sensor_humi=4201b78c
bme280_reg_read: start=0xd0, size=1, buf[0]=0x60
bme280_chip_init: ID OK
bme280_reg_write: reg=0xe0, val=0xb6
bme280_reg_read: start=0xf3, size=1, buf[0]=0x00
bme280_reg_read: start=0x88, size=24
bme280_reg_read: start=0xa1, size=1, buf[0]=0x4b
bme280_reg_read: start=0xe1, size=7
bme280_reg_write: reg=0xf2, val=0x05
bme280_reg_write: reg=0xf4, val=0x57
bme280_reg_write: reg=0xf5, val=0xa8
bme280_chip_init: "BME280" OK
SensorTest: Test /dev/sensor/humi0 with interval(1000000us), latency(0us)
sensor_pollnotify: Report events: 01
bme280_fetch_humi: buflen=16
bme280_fetch_humi: priv=4201b770, sensor_humi=4201b78c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x0c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x0c
bme280_reg_read: start=0xf3, size=1, buf[0]=0x04
bme280_reg_read: start=0xf7, size=8
bme280_fetch: temperature=30.820000 ¬∞C, pressure=1006.873535 mbar, humidity=75.338867 %
humi0: timestamp:57950000 value:75.34
SensorTest: Received message: humi0, number:1/1
sensor_ioctl: cmd=a80 arg=00000000
bme280_activate_humi: enable=0
bme280_activate_humi: priv=4201b770, sensor_humi=4201b78c
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
nsh>
```

# Pending Issues

TODO

Why does this fail? Perhaps because BME280 is in low power mode?

```text
## Resume BME280: This is OK
bme280_reg_write: reg=0xf4, val=0x57
...
## Suspend BME280: This fails
bme280_reg_write: reg=0xf4, val=0x54
bl602_i2c_transfer: i2c transfer error, event = 4
```

The BME280 Driver writes a different value to Register F4 and doesn't fail...

```text
## Resume BMP280: This is OK
bmp280_putreg8: regaddr=0xf4, regval=0x2f
...
## Suspend BMP280: This is OK
bmp280_putreg8: regaddr=0xf4, regval=0x00
```

# What's Next

TODO

Many Thanks to my [__GitHub Sponsors__](https://github.com/sponsors/lupyuen) for supporting my work! This article wouldn't have been possible without your support.

-   [Sponsor me a coffee](https://github.com/sponsors/lupyuen)

-   [Read "The RISC-V BL602 / BL604 Book"](https://lupyuen.github.io/articles/book)

-   [Check out my articles](https://lupyuen.github.io)

-   [RSS Feed](https://lupyuen.github.io/rss.xml)

_Got a question, comment or suggestion? Create an Issue or submit a Pull Request here..._

[`lupyuen.github.io/src/bme280.md`](https://github.com/lupyuen/lupyuen.github.io/blob/master/src/bme280.md)

# Notes

1.  This article is the expanded version of [this Twitter Thread](https://twitter.com/MisterTechBlog/status/1494301654186823683)

# Appendix: Log I2C Transfers

TODO

BL602 NuttX I2C Driver doesn't log the data transferred ... Let's log ourselves: [bl602_i2c.c](https://github.com/lupyuen/incubator-nuttx/blob/bme280/arch/risc-v/src/bl602/bl602_i2c.c#L194-L197)

```c
static void bl602_i2c_send_data(struct bl602_i2c_priv_s *priv)
{
  ...
  putreg32(temp, BL602_I2C_FIFO_WDATA);
  priv->bytes += count;
  i2cinfo("count=%d, temp=0x%x\n", count, temp); ////
}
```

[bl602_i2c.c](https://github.com/lupyuen/incubator-nuttx/blob/bme280/arch/risc-v/src/bl602/bl602_i2c.c#L207-L216)

```c
static void bl602_i2c_recvdata(struct bl602_i2c_priv_s *priv)
{
  ...
  count = msg->length - priv->bytes;
  temp  = getreg32(BL602_I2C_FIFO_RDATA);
  i2cinfo("count=%d, temp=0x%x\n", count, temp); ////
```

[bl602_i2c.c](https://github.com/lupyuen/incubator-nuttx/blob/bme280/arch/risc-v/src/bl602/bl602_i2c.c#L740-L742)

```c
static int bl602_i2c_transfer(struct i2c_master_s *dev,
                              struct i2c_msg_s *   msgs,
                              int                      count)
{
  ...
  for (i = 0; i < count; i++)
    {
      ...
      priv->msgid = i;
      i2cinfo("subflag=%d, subaddr=0x%x, sublen=%d\n", priv->subflag, priv->subaddr, priv->sublen); ////
      bl602_i2c_start_transfer(priv);
```

TODO3

![](https://lupyuen.github.io/images/bme280-code3a.png)

# Appendix: Build, Flash and Run NuttX

_(For BL602, BL604 and ESP32)_

Below are the steps to build, flash and run NuttX on BL602, BL604 and ESP32.

The instructions below will work on __Linux (Ubuntu)__, __WSL (Ubuntu)__ and __macOS__.

[(Instructions for other platforms)](https://nuttx.apache.org/docs/latest/quickstart/install.html)

[(See this for Arch Linux)](https://popolon.org/gblog3/?p=1977&lang=en)

## Download NuttX

To use the NuttX BME280 Driver, download the modified source code for __NuttX OS and NuttX Apps__...

```bash
mkdir nuttx
cd nuttx
git clone --recursive --branch bme280 https://github.com/lupyuen/incubator-nuttx nuttx
git clone --recursive --branch bme280 https://github.com/lupyuen/incubator-nuttx-apps apps
```

Or if we prefer to __add the BME280 Driver__ to our NuttX Project, follow these instructions...

-   [__"Install BME280 Driver"__](https://github.com/lupyuen/bme280-nuttx#install-driver)

## Configure NuttX

Now we configure our NuttX project...

1.  Install the build prerequisites...

    [__"Install Prerequisites"__](https://lupyuen.github.io/articles/nuttx#install-prerequisites)

1.  Configure the build...

    ```bash
    cd nuttx

    ## For BL602 / BL604: Configure the build for BL602 / BL604
    ./tools/configure.sh bl602evb:nsh

    ## For ESP32: Configure the build for ESP32.
    ## TODO: Change "esp32-devkitc" to our ESP32 board.
    ./tools/configure.sh esp32-devkitc:nsh

    ## Edit the Build Config
    make menuconfig 
    ```

1.  Enable __I2C0 Port__...

    __For BL602 / BL604:__ Check the box for __"System Type"__ ‚Üí __"BL602 Peripheral Support"__ ‚Üí __"I2C0"__

    __For ESP32:__ Check the box for __"System Type"__ ‚Üí __"ESP32 Peripheral Select"__ ‚Üí __"I2C 0"__

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

    ![Enable the I2C Port and I2C Character Driver](https://lupyuen.github.io/images/bme280-config1.png)

1.  Enable __I2C Character Driver__...

    Check the box for __"Device Drivers"__ ‚Üí __"I2C Driver Support"__ ‚Üí __"I2C Character Driver"__

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

1.  Enable __Sensor Driver Test App__...

    Check the box for __"Application Configuration"__ ‚Üí __"Testing"__ ‚Üí __"Sensor Driver Test"__

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

    ![Enable the Sensor Test App](https://lupyuen.github.io/images/bme280-config4a.png)

1.  Enable __ls__ command...

    Select __"Application Configuration"__ ‚Üí __"NSH Library"__ ‚Üí __"Disable Individual commands"__
    
    Uncheck __"Disable ls"__

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

1.  Enable __Logging and Assertion Checks__...

    Select __"Build Setup"__ ‚Üí __"Debug Options"__

    Check the boxes for the following...

    ```text
    Enable Debug Features
    Enable Error Output
    Enable Warnings Output
    Enable Informational Debug Output
    Enable Debug Assertions
    I2C Debug Features
    I2C Error Output
    I2C Warnings Output
    I2C Informational Output  
    Sensor Debug Features
    Sensor Error Output
    Sensor Warnings Output  
    Sensor Informational Output 
    ```

    Hit __"Exit"__ until the Top Menu appears. ("NuttX/x64_64 Configuration")

1.  Save the configuration and exit menuconfig

    [(See the .config for BL602)](https://gist.github.com/lupyuen/9d84889f5e2415ecb0f28cea2c2a657f)

The BME280 Driver will appear in NuttX at __/dev/baro0__ and __/dev/humi0__

## Build NuttX

Follow these steps to build NuttX for BL602, BL604 or ESP32...

1.  To build NuttX, enter this command...

    ```bash
    make
    ```

1.  We should see...

    ```text
    LD: nuttx
    CP: nuttx.hex
    CP: nuttx.bin
    ```

    [(See the complete log for BL602 / BL604)](https://gist.github.com/lupyuen/8f725c278c25e209c1654469a2855746)

1.  __For WSL:__ Copy the __NuttX Firmware__ to the __c:\blflash__ directory in the Windows File System...

    ```bash
    ##  /mnt/c/blflash refers to c:\blflash in Windows
    mkdir /mnt/c/blflash
    cp nuttx.bin /mnt/c/blflash
    ```

    For WSL we need to run __blflash__ under plain old Windows CMD (not WSL) because it needs to access the COM port.

1.  In case of problems, refer to the __NuttX Docs__...

    [__"BL602 / BL604 NuttX"__](https://nuttx.apache.org/docs/latest/platforms/risc-v/bl602/index.html)

    [__"ESP32 NuttX"__](https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html)

    [__"Installing NuttX"__](https://nuttx.apache.org/docs/latest/quickstart/install.html)

> ![Building NuttX](https://lupyuen.github.io/images/nuttx-build2.png)

## Flash NuttX

__For ESP32:__ [__See instructions here__](https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html#flashing) [(Also check out this article)](https://popolon.org/gblog3/?p=1977&lang=en)

__For BL602 / BL604:__ Follow these steps to install __blflash__...

1.  [__"Install rustup"__](https://lupyuen.github.io/articles/flash#install-rustup)

1.  [__"Download and build blflash"__](https://lupyuen.github.io/articles/flash#download-and-build-blflash)

We assume that our Firmware Binary File __nuttx.bin__ has been copied to the __blflash__ folder.

Set BL602 / BL604 to __Flashing Mode__ and restart the board...

__For PineDio Stack BL604:__

1.  Set the __GPIO 8 Jumper__ to __High__ [(Like this)](https://lupyuen.github.io/images/pinedio-high.jpg)

1.  Disconnect the USB cable and reconnect

    Or use the Improvised Reset Button [(Here's how)](https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack)

__For PineCone BL602:__

1.  Set the __PineCone Jumper (IO 8)__ to the __`H` Position__ [(Like this)](https://lupyuen.github.io/images/pinecone-jumperh.jpg)

1.  Press the Reset Button

__For BL10:__

1.  Connect BL10 to the USB port

1.  Press and hold the __D8 Button (GPIO 8)__

1.  Press and release the __EN Button (Reset)__

1.  Release the D8 Button

__For Pinenut and MagicHome BL602:__

1.  Disconnect the board from the USB Port

1.  Connect __GPIO 8__ to __3.3V__

1.  Reconnect the board to the USB port

Enter these commands to flash __nuttx.bin__ to BL602 / BL604 over UART...

```bash
## For Linux: Change "/dev/ttyUSB0" to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/ttyUSB0 

## For macOS: Change "/dev/tty.usbserial-1410" to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/tty.usbserial-1410 \
  --initial-baud-rate 230400 \
  --baud-rate 230400

## For Windows: Change "COM5" to the BL602 / BL604 Serial Port
blflash flash c:\blflash\nuttx.bin --port COM5
```

[(See the Output Log)](https://gist.github.com/lupyuen/9c0dbd75bb6b8e810939a36ffb5c399f)

For WSL: Do this under plain old Windows CMD (not WSL) because __blflash__ needs to access the COM port.

[(Flashing WiFi apps to BL602 / BL604? Remember to use __bl_rfbin__)](https://github.com/apache/incubator-nuttx/issues/4336)

[(More details on flashing firmware)](https://lupyuen.github.io/articles/flash#flash-the-firmware)

![Flashing NuttX](https://lupyuen.github.io/images/nuttx-flash2.png)

## Run NuttX

__For ESP32:__ Use Picocom to connect to ESP32 over UART...

```bash
picocom -b 115200 /dev/ttyUSB0
```

[(More about this)](https://popolon.org/gblog3/?p=1977&lang=en)

__For BL602 / BL604:__ Set BL602 / BL604 to __Normal Mode__ (Non-Flashing) and restart the board...

__For PineDio Stack BL604:__

1.  Set the __GPIO 8 Jumper__ to __Low__ [(Like this)](https://lupyuen.github.io/images/pinedio-low.jpg)

1.  Disconnect the USB cable and reconnect

    Or use the Improvised Reset Button [(Here's how)](https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack)

__For PineCone BL602:__

1.  Set the __PineCone Jumper (IO 8)__ to the __`L` Position__ [(Like this)](https://lupyuen.github.io/images/pinecone-jumperl.jpg)

1.  Press the Reset Button

__For BL10:__

1.  Press and release the __EN Button (Reset)__

__For Pinenut and MagicHome BL602:__

1.  Disconnect the board from the USB Port

1.  Connect __GPIO 8__ to __GND__

1.  Reconnect the board to the USB port

After restarting, connect to BL602 / BL604's UART Port at 2 Mbps like so...

__For Linux:__

```bash
screen /dev/ttyUSB0 2000000
```

__For macOS:__ Use CoolTerm ([See this](https://lupyuen.github.io/articles/flash#watch-the-firmware-run))

__For Windows:__ Use `putty` ([See this](https://lupyuen.github.io/articles/flash#watch-the-firmware-run))

__Alternatively:__ Use the Web Serial Terminal ([See this](https://lupyuen.github.io/articles/flash#watch-the-firmware-run))

Press Enter to reveal the __NuttX Shell__...

```text
NuttShell (NSH) NuttX-10.2.0-RC0
nsh>
```

Congratulations NuttX is now running on BL602 / BL604!

[(More details on connecting to BL602 / BL604)](https://lupyuen.github.io/articles/flash#watch-the-firmware-run)

![Running NuttX](https://lupyuen.github.io/images/nuttx-boot2.png)

__macOS Tip:__ Here's the script I use to build, flash and run NuttX on macOS, all in a single step: [run.sh](https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af)

![Script to build, flash and run NuttX on macOS](https://lupyuen.github.io/images/spi2-script.png)

[(Source)](https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af)

Connect BME280 to #RISCV PineCone #BL602 @PINE64 ... Preferably not on a cooking pot üòÇ

TODO24

![](https://lupyuen.github.io/images/bme280-pot.jpg)

